var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-extglob-npm-2.1.1-0870ea68b5-df033653d0.zip/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-extglob-npm-2.1.1-0870ea68b5-df033653d0.zip/node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-glob-npm-4.0.2-b2f6958c65-0b7e3ea119.zip/node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-glob-npm-4.0.2-b2f6958c65-0b7e3ea119.zip/node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (str[index] === "[" && str[index + 1] !== "]") {
          var closeIndex = str.indexOf("]", index);
          if (closeIndex > index) {
            var slashIndex = str.indexOf("\\", index);
            if (slashIndex === -1 || slashIndex > closeIndex) {
              return true;
            }
          }
        }
        if (str[index] === "{" && str[index + 1] !== "}") {
          closeIndex = str.indexOf("}", index);
          if (closeIndex > index) {
            slashIndex = str.indexOf("\\", index);
            if (slashIndex === -1 || slashIndex > closeIndex) {
              return true;
            }
          }
        }
        if (str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeIndex = str.indexOf(")", index);
          if (closeIndex > index) {
            slashIndex = str.indexOf("\\", index);
            if (slashIndex === -1 || slashIndex > closeIndex) {
              return true;
            }
          }
        }
        if (str[index] === "(" && str[index + 1] !== "|") {
          var pipeIndex = str.indexOf("|", index);
          if (pipeIndex > index && str[pipeIndex + 1] !== ")") {
            closeIndex = str.indexOf(")", pipeIndex);
            if (closeIndex > pipeIndex) {
              slashIndex = str.indexOf("\\", pipeIndex);
              if (slashIndex === -1 || slashIndex > closeIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/glob-parent-npm-5.1.2-021ab32634-f4f2bfe242.zip/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/glob-parent-npm-5.1.2-021ab32634-f4f2bfe242.zip/node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-number-npm-7.0.0-060086935c-456ac6f8e0.zip/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/is-number-npm-7.0.0-060086935c-456ac6f8e0.zip/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/to-regex-range-npm-5.0.1-f1e8263b00-f76fa01b3d.zip/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/to-regex-range-npm-5.0.1-f1e8263b00-f76fa01b3d.zip/node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj2 = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj2.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj2.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj2.string = zeros + obj2.pattern + toQuantifier(obj2.count);
        tokens.push(obj2);
        start = max2 + 1;
        prev = obj2;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fill-range-npm-7.0.1-b8b1817caa-cc283f4e65.zip/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fill-range-npm-7.0.1-b8b1817caa-cc283f4e65.zip/node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject2(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject2(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk2 = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk2(child, node);
          }
        }
        return output;
      };
      return walk2(ast);
    };
    module2.exports = compile;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk2 = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify2(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk2(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk2(ast));
    };
    module2.exports = expand;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse3 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify2(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse3;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/index.js
var require_braces = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/braces-npm-3.0.2-782240b28a-e2a8e769a8.zip/node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse3 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse3(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t2 of toks) {
              state.output += t2.output || t2.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse3 = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/picomatch-npm-2.3.0-5e60e6c82d-16818720ea.zip/node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/micromatch-npm-4.0.4-9fdcbb7a0e-ef3d1c88e7.zip/node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/micromatch-npm-4.0.4-9fdcbb7a0e-ef3d1c88e7.zip/node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch(list, patterns, { ...options, onResult });
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj2, patterns, options) => {
      if (!utils.isObject(obj2)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj2), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj2[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/merge2-npm-1.4.1-a2507bd06c-7268db63ed.zip/node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/merge2-npm-1.4.1-a2507bd06c-7268db63ed.zip/node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs2 = require_fs();
    exports2.fs = fs2;
    var path = require_path();
    exports2.path = path;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate2(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate2;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs2 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.stat-npm-2.0.5-01f4dd3030-012480b5ca.zip/node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/queue-microtask-npm-1.2.3-fcc98e4e2d-b676f8c040.zip/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/queue-microtask-npm-1.2.3-fcc98e4e2d-b676f8c040.zip/node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/run-parallel-npm-1.2.0-3f47ff2034-cb4f97ad25.zip/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/run-parallel-npm-1.2.0-3f47ff2034-cb4f97ad25.zip/node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs2 = require_fs3();
    exports2.fs = fs2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var fs2 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.scandir-npm-2.1.5-89c67370dd-a970d595bd.zip/node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/reusify-npm-1.0.4-95ac4aec11-c3076ebcc2.zip/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/reusify-npm-1.0.4-95ac4aec11-c3076ebcc2.zip/node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj2) {
        tail.next = obj2;
        tail = obj2;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fastq-npm-1.13.0-a45963881c-32cf15c29a.zip/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fastq-npm-1.13.0-a45963881c-32cf15c29a.zip/node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@nodelib-fs.walk-npm-1.2.8-b4a89da548-190c643f15.zip/node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk2(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk2;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
      }
    };
    exports2.default = EntryFilter;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/async.js
var require_async5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream3();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      lstatSync: fs2.lstatSync,
      stat: fs2.stat,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/fast-glob-npm-3.2.7-a2f0a45f5b-2f4708ff11.zip/node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async5();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/ms-npm-2.1.2-ec0c1512ff-673cdb2c31.zip/node_modules/ms/index.js
var require_ms = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/ms-npm-2.1.2-ec0c1512ff-673cdb2c31.zip/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/node.js
var require_node = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj2, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj2[prop] = val;
      return obj2;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/index.js
var require_src = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/debug-virtual-20a8f1b36b/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-shared-npm-3.2.4-01cda0cc89-e1194c482c.zip/node_modules/@vue/shared/dist/shared.cjs.js
var require_shared_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-shared-npm-3.2.4-01cda0cc89-e1194c482c.zip/node_modules/@vue/shared/dist/shared.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeMap(str, expectsLowerCase) {
      const map = Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `HYDRATE_EVENTS`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
    var range = 2;
    function generateCodeFrame(source, start = 0, end = source.length) {
      let lines = source.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
          for (let j = i - range; j <= i + range || end > count; j++) {
            if (j < 0 || j >= lines.length)
              continue;
            const line = j + 1;
            res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
            const lineLength = lines[j].length;
            const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
            if (j === i) {
              const pad = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(1, end > count ? lineLength - pad : end - start);
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
    var isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
    var isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
    function normalizeStyle(value) {
      if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value)) {
        return value;
      } else if (isObject2(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret2 = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret2[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret2;
    }
    function stringifyStyle(styles) {
      let ret2 = "";
      if (!styles || isString(styles)) {
        return ret2;
      }
      for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
          ret2 += `${normalizedKey}:${value};`;
        }
      }
      return ret2;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject2(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
    var escapeRE = /["'&<>]/;
    function escapeHtml(string) {
      const str = "" + string;
      const match = escapeRE.exec(str);
      if (!match) {
        return str;
      }
      let html = "";
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escaped = "&quot;";
            break;
          case 38:
            escaped = "&amp;";
            break;
          case 39:
            escaped = "&#39;";
            break;
          case 60:
            escaped = "&lt;";
            break;
          case 62:
            escaped = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src) {
      return src.replace(commentStripRE, "");
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isArray(a);
      bValidType = isArray(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject2(a);
      bValidType = isObject2(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return val == null ? "" : isArray(val) || isObject2(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject2(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var babelParserDefaultPlugins = [
      "bigInt",
      "optionalChaining",
      "nullishCoalescingOperator"
    ];
    var EMPTY_OBJ = Object.freeze({});
    var EMPTY_ARR = Object.freeze([]);
    var NOOP = () => {
    };
    var NO = () => false;
    var onRE = /^on[^a-z]/;
    var isOn = (key) => onRE.test(key);
    var isModelListener = (key) => key.startsWith("onUpdate:");
    var extend = Object.assign;
    var remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasOwn = (val, key) => hasOwnProperty.call(val, key);
    var isArray = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => val instanceof Date;
    var isFunction = (val) => typeof val === "function";
    var isString = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject2 = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return isObject2(val) && isFunction(val.then) && isFunction(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    var cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
    var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    var invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    var def = (obj2, key, value) => {
      Object.defineProperty(obj2, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    var toNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    exports2.EMPTY_ARR = EMPTY_ARR;
    exports2.EMPTY_OBJ = EMPTY_OBJ;
    exports2.NO = NO;
    exports2.NOOP = NOOP;
    exports2.PatchFlagNames = PatchFlagNames;
    exports2.babelParserDefaultPlugins = babelParserDefaultPlugins;
    exports2.camelize = camelize;
    exports2.capitalize = capitalize;
    exports2.def = def;
    exports2.escapeHtml = escapeHtml;
    exports2.escapeHtmlComment = escapeHtmlComment;
    exports2.extend = extend;
    exports2.generateCodeFrame = generateCodeFrame;
    exports2.getGlobalThis = getGlobalThis;
    exports2.hasChanged = hasChanged;
    exports2.hasOwn = hasOwn;
    exports2.hyphenate = hyphenate;
    exports2.includeBooleanAttr = includeBooleanAttr;
    exports2.invokeArrayFns = invokeArrayFns;
    exports2.isArray = isArray;
    exports2.isBooleanAttr = isBooleanAttr;
    exports2.isDate = isDate;
    exports2.isFunction = isFunction;
    exports2.isGloballyWhitelisted = isGloballyWhitelisted;
    exports2.isHTMLTag = isHTMLTag;
    exports2.isIntegerKey = isIntegerKey;
    exports2.isKnownHtmlAttr = isKnownHtmlAttr;
    exports2.isKnownSvgAttr = isKnownSvgAttr;
    exports2.isMap = isMap;
    exports2.isModelListener = isModelListener;
    exports2.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
    exports2.isObject = isObject2;
    exports2.isOn = isOn;
    exports2.isPlainObject = isPlainObject;
    exports2.isPromise = isPromise;
    exports2.isReservedProp = isReservedProp;
    exports2.isSSRSafeAttrName = isSSRSafeAttrName;
    exports2.isSVGTag = isSVGTag;
    exports2.isSet = isSet;
    exports2.isSpecialBooleanAttr = isSpecialBooleanAttr;
    exports2.isString = isString;
    exports2.isSymbol = isSymbol;
    exports2.isVoidTag = isVoidTag;
    exports2.looseEqual = looseEqual;
    exports2.looseIndexOf = looseIndexOf;
    exports2.makeMap = makeMap;
    exports2.normalizeClass = normalizeClass;
    exports2.normalizeProps = normalizeProps;
    exports2.normalizeStyle = normalizeStyle;
    exports2.objectToString = objectToString;
    exports2.parseStringStyle = parseStringStyle;
    exports2.propsToAttrMap = propsToAttrMap;
    exports2.remove = remove;
    exports2.slotFlagsText = slotFlagsText;
    exports2.stringifyStyle = stringifyStyle;
    exports2.toDisplayString = toDisplayString;
    exports2.toHandlerKey = toHandlerKey;
    exports2.toNumber = toNumber;
    exports2.toRawType = toRawType;
    exports2.toTypeString = toTypeString;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-shared-npm-3.2.4-01cda0cc89-e1194c482c.zip/node_modules/@vue/shared/index.js
var require_shared = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-shared-npm-3.2.4-01cda0cc89-e1194c482c.zip/node_modules/@vue/shared/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_shared_cjs();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj2 = Object.create(null);
      return !("__proto__" in obj2);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/quick-sort.js"(exports2) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret2 = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret2;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.6.1-1a3621db16-59ce8640cf.zip/node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-parser-npm-7.15.3-8a396303bd-4b9ba7e8ff.zip/node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-parser-npm-7.15.3-8a396303bd-4b9ba7e8ff.zip/node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var TokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.updateContext = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        this.updateContext = null;
      }
    };
    var keywords$1 = new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = new TokenType(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return new TokenType(name, {
        beforeExpr,
        binop
      });
    }
    var types$1 = {
      num: new TokenType("num", {
        startsExpr
      }),
      bigint: new TokenType("bigint", {
        startsExpr
      }),
      decimal: new TokenType("decimal", {
        startsExpr
      }),
      regexp: new TokenType("regexp", {
        startsExpr
      }),
      string: new TokenType("string", {
        startsExpr
      }),
      name: new TokenType("name", {
        startsExpr
      }),
      privateName: new TokenType("#name", {
        startsExpr
      }),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: new TokenType("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: new TokenType("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: new TokenType("]"),
      bracketBarR: new TokenType("|]"),
      braceL: new TokenType("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: new TokenType("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: new TokenType("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: new TokenType("}", {
        beforeExpr
      }),
      braceBarR: new TokenType("|}"),
      parenL: new TokenType("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", {
        beforeExpr
      }),
      semi: new TokenType(";", {
        beforeExpr
      }),
      colon: new TokenType(":", {
        beforeExpr
      }),
      doubleColon: new TokenType("::", {
        beforeExpr
      }),
      dot: new TokenType("."),
      question: new TokenType("?", {
        beforeExpr
      }),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", {
        beforeExpr
      }),
      template: new TokenType("template"),
      ellipsis: new TokenType("...", {
        beforeExpr
      }),
      backQuote: new TokenType("`", {
        startsExpr
      }),
      dollarBraceL: new TokenType("${", {
        beforeExpr,
        startsExpr
      }),
      at: new TokenType("@"),
      hash: new TokenType("#", {
        startsExpr
      }),
      interpreterDirective: new TokenType("#!..."),
      eq: new TokenType("=", {
        beforeExpr,
        isAssign
      }),
      assign: new TokenType("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: new TokenType("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: new TokenType("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: new TokenType("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: new TokenType("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: new TokenType("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: new TokenType("%", {
        binop: 10,
        startsExpr
      }),
      star: new TokenType("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: new TokenType("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _for: createKeyword("for", {
        isLoop
      }),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _while: createKeyword("while", {
        isLoop
      }),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      })
    };
    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(code) {
      switch (code) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var Position = class {
      constructor(line, col) {
        this.line = void 0;
        this.column = void 0;
        this.line = line;
        this.column = col;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function getLineInfo(input, offset) {
      let line = 1;
      let lineStart = 0;
      let match;
      lineBreakG.lastIndex = 0;
      while ((match = lineBreakG.exec(input)) && match.index < offset) {
        line++;
        lineStart = lineBreakG.lastIndex;
      }
      return new Position(line, offset - lineStart);
    }
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(name) {
        return this.plugins.has(name);
      }
      getPluginOption(plugin, name) {
        if (this.hasPlugin(plugin))
          return this.plugins.get(plugin)[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else if (comments !== void 0) {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename)
          comment.loc.filename = this.filename;
        this.state.comments.push(comment);
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            commentWS.trailingNode.leadingComments = comments;
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
    };
    var ErrorCodes = Object.freeze({
      SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
      SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
    });
    var ErrorMessages = makeErrorTemplates({
      AccessorIsGenerator: "A %0ter cannot be a generator.",
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accesor must not have any formal parameters.",
      BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: "'%0' require an initialization value.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: "Unsyntactic %0.",
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: "`import()` requires exactly %0.",
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: "Expected number in radix %0.",
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
      InvalidIdentifier: "Invalid identifier %0.",
      InvalidLhs: "Invalid left-hand side in %0.",
      InvalidLhsBinding: "Binding invalid left-hand side in %0.",
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: "Unexpected character '%0'.",
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: "Label '%0' is already declared.",
      LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
      ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
      ModuleExportUndefined: "Export '%0' is not defined.",
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
      PrivateNameRedeclaration: "Duplicate private name #%0.",
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      StaticPrototype: "Classes may not have static property named prototype.",
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: "Assigning to '%0' in strict mode.",
      StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: "Unexpected keyword '%0'.",
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
      UnexpectedReservedWord: "Unexpected reserved word '%0'.",
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: "Unexpected token '%0'.",
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      VarRedeclaration: "Identifier '%0' has already been declared.",
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    }, ErrorCodes.SyntaxError);
    var SourceTypeModuleErrorMessages = makeErrorTemplates({
      ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
      ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
    }, ErrorCodes.SourceTypeModuleError);
    function makeErrorTemplates(messages, code) {
      const templates = {};
      Object.keys(messages).forEach((reasonCode) => {
        templates[reasonCode] = Object.freeze({
          code,
          reasonCode,
          template: messages[reasonCode]
        });
      });
      return Object.freeze(templates);
    }
    var ParserError = class extends CommentsParser {
      getLocationForPosition(pos) {
        let loc;
        if (pos === this.state.start)
          loc = this.state.startLoc;
        else if (pos === this.state.lastTokStart)
          loc = this.state.lastTokStartLoc;
        else if (pos === this.state.end)
          loc = this.state.endLoc;
        else if (pos === this.state.lastTokEnd)
          loc = this.state.lastTokEndLoc;
        else
          loc = getLineInfo(this.input, pos);
        return loc;
      }
      raise(pos, {
        code,
        reasonCode,
        template: template2
      }, ...params) {
        return this.raiseWithData(pos, {
          code,
          reasonCode
        }, template2, ...params);
      }
      raiseOverwrite(pos, {
        code,
        template: template2
      }, ...params) {
        const loc = this.getLocationForPosition(pos);
        const message = template2.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
        if (this.options.errorRecovery) {
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.pos === pos) {
              return Object.assign(error, {
                message
              });
            } else if (error.pos < pos) {
              break;
            }
          }
        }
        return this._raise({
          code,
          loc,
          pos
        }, message);
      }
      raiseWithData(pos, data, errorTemplate, ...params) {
        const loc = this.getLocationForPosition(pos);
        const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
        return this._raise(Object.assign({
          loc,
          pos
        }, data), message);
      }
      _raise(errorContext, message) {
        const err = new SyntaxError(message);
        Object.assign(err, errorContext);
        if (this.options.errorRecovery) {
          if (!this.isLookahead)
            this.state.errors.push(err);
          return err;
        } else {
          throw err;
        }
      }
    };
    var estree = (superClass) => class extends superClass {
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const directiveLiteral = directive.value;
        const stmt = this.startNodeAt(directive.start, directive.loc.start);
        const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.extra.expressionValue;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      stmtToDirective(stmt) {
        const value = stmt.expression.value;
        const directive = super.stmtToDirective(stmt);
        this.addExtra(directive.value, "expressionValue", value);
        return directive;
      }
      parseBlockBody(node, ...args) {
        super.parseBlockBody(node, ...args);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parseMaybePrivateName(...args) {
        const node = super.parseMaybePrivateName(...args);
        if (node.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        return node;
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.isPrivateName(node);
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.getPrivateNameSV(node);
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        type = "MethodDefinition";
        return this.finishNode(node, type);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        if (this.getPluginOption("estree", "classFeatures")) {
          propertyNode.type = "PropertyDefinition";
        }
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        if (this.getPluginOption("estree", "classFeatures")) {
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
        }
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method")
            node.kind = "init";
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          this.toAssignable(node.value, isLHS);
          return node;
        }
        return super.toAssignable(node, isLHS);
      }
      toAssignableObjectExpressionProp(prop, ...args) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
        } else if (prop.method) {
          this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
        } else {
          super.toAssignableObjectExpressionProp(prop, ...args);
        }
      }
      finishCallExpression(node, optional) {
        super.finishCallExpression(node, optional);
        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          if (this.hasPlugin("importAssertions")) {
            var _node$arguments$;
            node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
          }
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(node) {
        super.parseExport(node);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isOptionalChain(node) {
        return node.type === "ChainExpression";
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.method || node.kind === "get" || node.kind === "set";
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      template: new TokContext("`", true)
    };
    types$1.braceR.updateContext = (context) => {
      context.pop();
    };
    types$1.braceL.updateContext = types$1.braceHashL.updateContext = types$1.dollarBraceL.updateContext = (context) => {
      context.push(types.brace);
    };
    types$1.backQuote.updateContext = (context) => {
      if (context[context.length - 1] === types.template) {
        context.pop();
      } else {
        context.push(types.template);
      }
    };
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next) {
      return current === 64 && next === 64;
    }
    var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var SCOPE_OTHER = 0;
    var SCOPE_PROGRAM = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_ARROW = 4;
    var SCOPE_SIMPLE_CATCH = 8;
    var SCOPE_SUPER = 16;
    var SCOPE_DIRECT_SUPER = 32;
    var SCOPE_CLASS = 64;
    var SCOPE_STATIC_BLOCK = 128;
    var SCOPE_TS_MODULE = 256;
    var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
    var BIND_KIND_VALUE = 1;
    var BIND_KIND_TYPE = 2;
    var BIND_SCOPE_VAR = 4;
    var BIND_SCOPE_LEXICAL = 8;
    var BIND_SCOPE_FUNCTION = 16;
    var BIND_FLAGS_NONE = 64;
    var BIND_FLAGS_CLASS = 128;
    var BIND_FLAGS_TS_ENUM = 256;
    var BIND_FLAGS_TS_CONST_ENUM = 512;
    var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
    var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
    var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
    var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
    var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
    var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
    var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
    var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
    var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
    var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
    var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
    var CLASS_ELEMENT_FLAG_STATIC = 4;
    var CLASS_ELEMENT_KIND_GETTER = 2;
    var CLASS_ELEMENT_KIND_SETTER = 1;
    var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
    var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_OTHER = 0;
    var Scope = class {
      constructor(flags) {
        this.var = new Set();
        this.lexical = new Set();
        this.functions = new Set();
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(raise, inModule) {
        this.scopeStack = [];
        this.undefinedExports = new Map();
        this.undefinedPrivateNames = new Map();
        this.raise = raise;
        this.inModule = inModule;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & SCOPE_STATIC_BLOCK) {
            return true;
          }
          if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        this.scopeStack.pop();
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
      }
      declareName(name, bindingType, pos) {
        let scope = this.currentScope();
        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          if (bindingType & BIND_SCOPE_FUNCTION) {
            scope.functions.add(name);
          } else {
            scope.lexical.add(name);
          }
          if (bindingType & BIND_SCOPE_LEXICAL) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & BIND_SCOPE_VAR) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, pos);
            scope.var.add(name);
            this.maybeExportDefined(scope, name);
            if (scope.flags & SCOPE_VAR)
              break;
          }
        }
        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, pos) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.raise(pos, ErrorMessages.VarRedeclaration, name);
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & BIND_KIND_VALUE))
          return false;
        if (bindingType & BIND_SCOPE_LEXICAL) {
          return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
        }
        if (bindingType & BIND_SCOPE_FUNCTION) {
          return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
        }
        return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
          this.undefinedExports.set(name, id.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & SCOPE_VAR) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, pos) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(...arguments);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(...arguments))
          return true;
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var State = class {
      constructor() {
        this.strict = void 0;
        this.curLine = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.inPropertyName = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.decoratorStack = [[]];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.lineStart = 0;
        this.type = types$1.eof;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.lastTokEnd = 0;
        this.context = [types.brace];
        this.exprAllowed = true;
        this.containsEsc = false;
        this.strictErrors = new Map();
        this.tokensLength = 0;
      }
      init(options) {
        this.strict = options.strictMode === false ? false : options.strictMode === true ? true : options.sourceType === "module";
        this.curLine = options.startLine;
        this.startLoc = this.endLoc = this.curPosition();
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
      clone(skipArrays) {
        const state = new State();
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          let val = this[key];
          if (!skipArrays && Array.isArray(val)) {
            val = val.slice();
          }
          state[key] = val;
        }
        return state;
      }
    };
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
      hex: [46, 88, 95, 120]
    };
    var allowedNumericSeparatorSiblings = {};
    allowedNumericSeparatorSiblings.bin = [48, 49];
    allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
    allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
    allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
    var Token = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends ParserError {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEnd = this.state.end;
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          lastTokEnd: state.end,
          context: [this.curContext()],
          inType: state.inType
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace)
          this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead)
          this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(types$1.eof);
          return;
        }
        if (curContext === types.template) {
          this.readTmplToken();
        } else {
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf("*/", start + 2);
        if (end === -1)
          throw this.raise(start, ErrorMessages.UnterminatedComment);
        this.state.pos = end + 2;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead)
          return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start,
          end: end + 2,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead)
          return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start,
          end,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop:
          while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment = this.skipBlockComment();
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  case 47: {
                    const comment = this.skipLineComment(2);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment = this.skipLineComment(3);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment = this.skipLineComment(4);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
        if (comments.length > 0) {
          const end = this.state.pos;
          const CommentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(CommentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.state.endLoc = this.state.curPosition();
          this.updateContext(prevType);
        }
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
            throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(types$1.braceHashL);
          } else {
            this.finishToken(types$1.bracketHashL);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(types$1.privateName, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(types$1.privateName, this.readWord1());
        } else {
          this.finishOp(types$1.hash, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(types$1.ellipsis);
        } else {
          ++this.state.pos;
          this.finishToken(types$1.dot);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(types$1.slashAssign, 2);
        } else {
          this.finishOp(types$1.slash, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
          return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33)
          return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(types$1.interpreterDirective, value);
        return true;
      }
      readToken_mult_modulo(code) {
        let type = code === 42 ? types$1.star : types$1.modulo;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = types$1.exponent;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code === 37 ? types$1.moduloAssign : types$1.assign;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(types$1.assign, 3);
          } else {
            this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
          }
          return;
        }
        if (code === 124) {
          if (next === 62) {
            this.finishOp(types$1.pipeline, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
            }
            this.state.pos += 2;
            this.finishToken(types$1.braceBarR);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
            }
            this.state.pos += 2;
            this.finishToken(types$1.bracketBarR);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(types$1.assign, 2);
          return;
        }
        this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(types$1.assign, 2);
        } else {
          this.finishOp(types$1.bitwiseXOR, 1);
        }
      }
      readToken_plus_min(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          this.finishOp(types$1.incDec, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(types$1.assign, 2);
        } else {
          this.finishOp(types$1.plusMin, 1);
        }
      }
      readToken_lt_gt(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        let size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.state.pos + size) === 61) {
            this.finishOp(types$1.assign, size + 1);
            return;
          }
          this.finishOp(types$1.bitShift, size);
          return;
        }
        if (next === 61) {
          size = 2;
        }
        this.finishOp(types$1.relational, size);
      }
      readToken_eq_excl(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(types$1.arrow);
          return;
        }
        this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(types$1.assign, 3);
          } else {
            this.finishOp(types$1.nullishCoalescing, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(types$1.questionDot);
        } else {
          ++this.state.pos;
          this.finishToken(types$1.question);
        }
      }
      getTokenFromCode(code) {
        switch (code) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(types$1.parenL);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(types$1.parenR);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(types$1.semi);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(types$1.comma);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
              }
              this.state.pos += 2;
              this.finishToken(types$1.bracketBarL);
            } else {
              ++this.state.pos;
              this.finishToken(types$1.bracketL);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(types$1.bracketR);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
              }
              this.state.pos += 2;
              this.finishToken(types$1.braceBarL);
            } else {
              ++this.state.pos;
              this.finishToken(types$1.braceL);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(types$1.braceR);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(types$1.doubleColon, 2);
            } else {
              ++this.state.pos;
              this.finishToken(types$1.colon);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            ++this.state.pos;
            this.finishToken(types$1.backQuote);
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code);
            return;
          case 60:
          case 62:
            this.readToken_lt_gt(code);
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code);
            return;
          case 126:
            this.finishOp(types$1.tilde, 1);
            return;
          case 64:
            ++this.state.pos;
            this.finishToken(types$1.at);
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code)) {
              this.readWord(code);
              return;
            }
        }
        throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(start, ErrorMessages.UnterminatedRegExp);
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(start, ErrorMessages.UnterminatedRegExp);
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (mods.includes(char)) {
              this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(types$1.regexp, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen, allowNumSeparator = true) {
        const start = this.state.pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = this.input.charCodeAt(this.state.pos);
          let val;
          if (code === 95) {
            const prev = this.input.charCodeAt(this.state.pos - 1);
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (allowedSiblings.indexOf(next) === -1) {
              this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
            } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
              this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
            }
            if (!allowNumSeparator) {
              this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
            }
            ++this.state.pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (this.options.errorRecovery && val <= 9) {
              val = 0;
              this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++this.state.pos;
          total = total * radix + val;
        }
        if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
          return null;
        }
        return total;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(start, ErrorMessages.InvalidDecimal);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
        }
        if (isBigInt) {
          const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(types$1.bigint, str);
          return;
        }
        this.finishToken(types$1.num, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidNumber);
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, ErrorMessages.InvalidOrMissingExponent);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(start, ErrorMessages.InvalidBigIntLiteral);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.pos);
          if (hasExponent || hasLeadingZero) {
            this.raise(start, ErrorMessages.InvalidDecimal);
          }
          ++this.state.pos;
          isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(types$1.bigint, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(types$1.decimal, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(types$1.num, val);
      }
      readCodePoint(throwOnInvalid) {
        const ch = this.input.charCodeAt(this.state.pos);
        let code;
        if (ch === 123) {
          const codePos = ++this.state.pos;
          code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
          ++this.state.pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              this.raise(codePos, ErrorMessages.InvalidCodePoint);
            } else {
              return null;
            }
          }
        } else {
          code = this.readHexChar(4, false, throwOnInvalid);
        }
        return code;
      }
      readString(quote) {
        let out = "", chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.state.pos;
          } else if (ch === 8232 || ch === 8233) {
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
          } else if (isNewLine(ch)) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(types$1.string, out);
      }
      readTmplToken() {
        let out = "", chunkStart = this.state.pos, containsInvalid = false;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
            if (this.state.pos === this.state.start && this.match(types$1.template)) {
              if (ch === 36) {
                this.state.pos += 2;
                this.finishToken(types$1.dollarBraceL);
                return;
              } else {
                ++this.state.pos;
                this.finishToken(types$1.backQuote);
                return;
              }
            }
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(types$1.template, containsInvalid ? null : out);
            return;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            const escaped = this.readEscapedChar(true);
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            ++this.state.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.state.pos) === 10) {
                  ++this.state.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
      }
      recordStrictModeErrors(pos, message) {
        if (this.state.strict && !this.state.strictErrors.has(pos)) {
          this.raise(pos, message);
        } else {
          this.state.strictErrors.set(pos, message);
        }
      }
      readEscapedChar(inTemplate) {
        const throwOnInvalid = !inTemplate;
        const ch = this.input.charCodeAt(++this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120: {
            const code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }
          case 117: {
            const code = this.readCodePoint(throwOnInvalid);
            return code === null ? null : String.fromCodePoint(code);
          }
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }
          case 10:
            this.state.lineStart = this.state.pos;
            ++this.state.curLine;
          case 8232:
          case 8233:
            return "";
          case 56:
          case 57:
            if (inTemplate) {
              return null;
            } else {
              this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const codePos = this.state.pos - 1;
              const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.state.pos += octalStr.length - 1;
              const next = this.input.charCodeAt(this.state.pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return null;
                } else {
                  this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
                }
              }
              return String.fromCharCode(octal);
            }
            return String.fromCharCode(ch);
        }
      }
      readHexChar(len, forceLen, throwOnInvalid) {
        const codePos = this.state.pos;
        const n = this.readInt(16, len, forceLen, false);
        if (n === null) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
          } else {
            this.state.pos = codePos - 1;
          }
        }
        return n;
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.pos;
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word) || types$1.name;
        this.finishToken(type, word);
      }
      checkKeywordEscapes() {
        const kw = this.state.type.keyword;
        if (kw && this.state.containsEsc) {
          this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
        }
      }
      updateContext(prevType) {
        var _this$state$type$upda, _this$state$type;
        (_this$state$type$upda = (_this$state$type = this.state.type).updateContext) == null ? void 0 : _this$state$type$upda.call(_this$state$type, this.state.context);
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = new Set();
        this.loneAccessors = new Map();
        this.undefinedPrivateNames = new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(raise) {
        this.stack = [];
        this.undefinedPrivateNames = new Map();
        this.raise = raise;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, pos);
            }
          } else {
            this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
          }
        }
      }
      declarePrivateName(name, elementType, pos) {
        const classScope = this.current();
        let redefined = classScope.privateNames.has(name);
        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
          const accessor = redefined && classScope.loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
            const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
            const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
            const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined)
              classScope.loneAccessors.delete(name);
          } else if (!redefined) {
            classScope.loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
        }
        classScope.privateNames.add(name);
        classScope.undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, pos) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name))
            return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, pos);
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    };
    var kExpression = 0;
    var kMaybeArrowParameterDeclaration = 1;
    var kMaybeAsyncArrowParameterDeclaration = 2;
    var kParameterDeclaration = 3;
    var ExpressionScope = class {
      constructor(type = kExpression) {
        this.type = void 0;
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
      }
      isCertainlyParameterDeclaration() {
        return this.type === kParameterDeclaration;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.errors = new Map();
      }
      recordDeclarationError(pos, template2) {
        this.errors.set(pos, template2);
      }
      clearDeclarationError(pos) {
        this.errors.delete(pos);
      }
      iterateErrors(iterator) {
        this.errors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(raise) {
        this.stack = [new ExpressionScope()];
        this.raise = raise;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(pos, template2) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(pos, template2);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.raise(pos, template2);
      }
      recordParenthesizedIdentifierError(pos, template2) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        if (scope.isCertainlyParameterDeclaration()) {
          this.raise(pos, template2);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, template2);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(pos, template2) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
            scope.recordDeclarationError(pos, template2);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration())
          return;
        currentScope.iterateErrors((template2, pos) => {
          this.raise(pos, template2);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(pos);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(kParameterDeclaration);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var PARAM = 0;
    var PARAM_YIELD = 1;
    var PARAM_AWAIT = 2;
    var PARAM_RETURN = 4;
    var PARAM_IN = 8;
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & PARAM_IN) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, val) {
        if (!node)
          return;
        const extra = node.extra = node.extra || {};
        extra[key] = val;
      }
      isRelational(op) {
        return this.match(types$1.relational) && this.state.value === op;
      }
      expectRelational(op) {
        if (this.isRelational(op)) {
          this.next();
        } else {
          this.unexpected(null, types$1.relational);
        }
      }
      isContextual(name) {
        return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(name) {
        return this.isContextual(name) && this.eat(types$1.name);
      }
      expectContextual(name, template2) {
        if (!this.eatContextual(name))
          this.unexpected(null, template2);
      }
      canInsertSemicolon() {
        return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(types$1.semi) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi))
          return;
        this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
      }
      expect(type, pos) {
        this.eat(type) || this.unexpected(pos, type);
      }
      assertNoSpace(message = "Unexpected space.") {
        if (this.state.start > this.state.lastTokEnd) {
          this.raise(this.state.lastTokEnd, {
            code: ErrorCodes.SyntaxError,
            reasonCode: "UnexpectedSpace",
            template: message
          });
        }
      }
      unexpected(pos, messageOrType = {
        code: ErrorCodes.SyntaxError,
        reasonCode: "UnexpectedToken",
        template: "Unexpected token"
      }) {
        if (messageOrType instanceof TokenType) {
          messageOrType = {
            code: ErrorCodes.SyntaxError,
            reasonCode: "UnexpectedToken",
            template: `Unexpected token, expected "${messageOrType.label}"`
          };
        }
        throw this.raise(pos != null ? pos : this.state.start, messageOrType);
      }
      expectPlugin(name, pos) {
        if (!this.hasPlugin(name)) {
          throw this.raiseWithData(pos != null ? pos : this.state.start, {
            missingPlugin: [name]
          }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
        }
        return true;
      }
      expectOnePlugin(names, pos) {
        if (!names.some((n) => this.hasPlugin(n))) {
          throw this.raiseWithData(pos != null ? pos : this.state.start, {
            missingPlugin: names
          }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
          return false;
        const {
          shorthandAssign,
          doubleProto,
          optionalParameters
        } = refExpressionErrors;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
        }
        if (shorthandAssign >= 0) {
          this.unexpected(shorthandAssign);
        }
        if (doubleProto >= 0) {
          this.raise(doubleProto, ErrorMessages.DuplicateProto);
        }
        if (optionalParameters >= 0) {
          this.unexpected(optionalParameters);
        }
      }
      isLiteralPropertyName() {
        return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isOptionalChain(node) {
        return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this.raise.bind(this));
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = PARAM;
        if (this.inModule) {
          paramFlags |= PARAM_AWAIT;
        }
        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssign = -1;
        this.doubleProto = -1;
        this.optionalParameters = -1;
      }
    };
    var Node2 = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges)
          this.range = [pos, 0];
        if (parser != null && parser.filename)
          this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node2.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node2();
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = "StringLiteral";
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        return new Node2(this, this.state.start, this.state.startLoc);
      }
      startNodeAt(pos, loc) {
        return new Node2(this, pos, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.start, type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        node.loc.end = loc;
        if (this.options.ranges)
          node.range[1] = pos;
        if (this.options.attachComment)
          this.processComment(node);
        return node;
      }
      resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges)
          node.range[0] = start;
      }
      resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
        node.end = end;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = end;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
    };
    var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = makeErrorTemplates({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: "Cannot overwrite reserved type %0.",
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
      EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
      EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
      EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
      EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
      EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
      EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
      EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
      EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: "Unexpected reserved type %0.",
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    }, ErrorCodes.SyntaxError);
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    function isMaybeDefaultImport(state) {
      return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== types$1.string && type !== types$1.semi && type !== types$1.interpreterDirective) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        return super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches)
            ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        return super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types$1.colon);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloPos = this.state.start;
        this.next();
        this.expectContextual("checks");
        if (this.state.lastTokStart > moduloPos + 1) {
          this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
        }
        if (this.eat(types$1.parenL)) {
          node.value = this.parseExpression();
          this.expect(types$1.parenR);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types$1.colon);
        let type = null;
        let predicate = null;
        if (this.match(types$1.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(types$1.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.isRelational("<")) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(types$1.parenL);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(types$1.parenR);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(types$1._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types$1._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types$1._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual("module")) {
          if (this.match(types$1.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual("type")) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual("opaque")) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual("interface")) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types$1._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(SCOPE_OTHER);
        if (this.match(types$1.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(types$1.braceL);
        while (!this.match(types$1.braceR)) {
          let bodyNode2 = this.startNode();
          if (this.match(types$1._import)) {
            this.next();
            if (!this.isContextual("type") && !this.match(types$1._typeof)) {
              this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
            }
            this.parseImport(bodyNode2);
          } else {
            this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(types$1.braceR);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
            }
            if (kind === "ES") {
              this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types$1._export);
        if (this.eat(types$1._default)) {
          if (this.match(types$1._function) || this.match(types$1._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
            const label = this.state.value;
            const suggestion = exportSuggestions[label];
            throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
          }
          if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
            node = this.parseExport(node);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual("exports");
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass2 = false) {
        node.id = this.flowParseRestrictedIdentifier(!isClass2, true);
        this.scope.declareName(node.id.name, isClass2 ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        node.implements = [];
        node.mixins = [];
        if (this.eat(types$1._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass2 && this.eat(types$1.comma));
        }
        if (this.isContextual("mixins")) {
          this.next();
          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }
        if (this.isContextual("implements")) {
          this.next();
          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass2,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass2,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word))
          return;
        this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(types$1.eq);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual("type");
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(types$1.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types$1.colon);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types$1.eq);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStart = this.state.start;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(types$1.eq)) {
          this.eat(types$1.eq);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        } while (!this.isRelational(">"));
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.isRelational(">")) {
          node.params.push(this.flowParseType());
          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        while (!this.isRelational(">")) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        }
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual("interface");
        node.extends = [];
        if (this.eat(types$1._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === types$1.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(types$1.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types$1.bracketR);
        this.expect(types$1.bracketR);
        if (this.isRelational("<") || this.match(types$1.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;
          if (this.eat(types$1.question)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(types$1.parenL);
        if (this.match(types$1._this)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }
        while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }
        if (this.eat(types$1.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(types$1.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(types$1.braceBarL)) {
          this.expect(types$1.braceBarL);
          endDelim = types$1.braceBarR;
          exact = true;
        } else {
          this.expect(types$1.braceL);
          endDelim = types$1.braceR;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStart = null;
          let inexactStart = null;
          const node = this.startNode();
          if (allowProto && this.isContextual("proto")) {
            const lookahead = this.lookahead();
            if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual("static")) {
            const lookahead = this.lookahead();
            if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(types$1.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }
            if (this.eat(types$1.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(types$1.parenL) || this.isRelational("<")) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }
            if (variance) {
              this.unexpected(variance.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual("get") || this.isContextual("set")) {
              const lookahead = this.lookahead();
              if (lookahead.type === types$1.name || lookahead.type === types$1.string || lookahead.type === types$1.num) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
            this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types$1.ellipsis)) {
          const isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
            } else if (!allowInexact) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
            }
            if (variance) {
              this.raise(variance.start, FlowErrors.InexactVariance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
          }
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (variance) {
            this.raise(variance.start, FlowErrors.SpreadVariance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          let optional = false;
          if (this.isRelational("<") || this.match(types$1.parenL)) {
            node.method = true;
            if (protoStart != null) {
              this.unexpected(protoStart);
            }
            if (variance) {
              this.unexpected(variance.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(node.value.this.start, FlowErrors.ThisParamBannedInConstructor);
            }
          } else {
            if (kind !== "init")
              this.unexpected();
            node.method = false;
            if (this.eat(types$1.question)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const start = property.start;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
        }
        if (length !== paramCount) {
          if (property.kind === "get") {
            this.raise(start, ErrorMessages.BadGetterArity);
          } else {
            this.raise(start, ErrorMessages.BadSetterArity);
          }
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(types$1.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startPos, startLoc, id) {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(types$1._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(types$1.bracketL);
        while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types$1.bracketR))
            break;
          this.expect(types$1.comma);
        }
        this.expect(types$1.bracketR);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === types$1._this;
        if (lh.type === types$1.colon || lh.type === types$1.question) {
          if (isThis && !first) {
            this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(types$1.question)) {
            optional = true;
            if (isThis) {
              this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(types$1._this)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }
        while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }
        if (this.eat(types$1.ellipsis)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case types$1.name:
            if (this.isContextual("interface")) {
              return this.flowParseInterfaceType();
            }
            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
          case types$1.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case types$1.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case types$1.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case types$1.relational:
            if (this.state.value === "<") {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types$1.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(types$1.parenR);
              this.expect(types$1.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            }
            break;
          case types$1.parenL:
            this.next();
            if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
              if (this.match(types$1.name) || this.match(types$1._this)) {
                const token = this.lookahead().type;
                isGroupedType = token !== types$1.question && token !== types$1.colon;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
                this.expect(types$1.parenR);
                return type;
              } else {
                this.eat(types$1.comma);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(types$1.parenR);
            this.expect(types$1.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          case types$1.string:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case types$1._true:
          case types$1._false:
            node.value = this.match(types$1._true);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case types$1.plusMin:
            if (this.state.value === "-") {
              this.next();
              if (this.match(types$1.num)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(types$1.bigint)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
            }
            throw this.unexpected();
          case types$1.num:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case types$1.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case types$1._void:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case types$1._null:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case types$1._this:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case types$1.star:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          default:
            if (this.state.type.keyword === "typeof") {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              const label = this.state.type.label;
              this.next();
              return super.createIdentifier(node, label);
            }
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startPos, startLoc);
          const optional = this.eat(types$1.questionDot);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(types$1.bracketL);
          if (!optional && this.match(types$1.bracketR)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(types$1.bracketR);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(types$1.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
          const node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(types$1.bitwiseAND);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(types$1.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(types$1.bitwiseOR);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(types$1.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types$1.name && this.state.value === "_") {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(types$1.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(types$1.plusMin)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
        }
        return super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(types$1.colon)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
          const lookahead = this.lookahead();
          if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatement(context, topLevel);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types$1.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
          return false;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (!this.match(types$1.question))
          return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(types$1.question);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startPos, startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types$1.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(types$1.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse4) {
        let result;
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse4();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse4();
        }
        return result;
      }
      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);
        if (this.eat(types$1.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(types$1.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExport(node) {
        const decl = super.parseExport(node);
        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }
        return decl;
      }
      parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(types$1.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("opaque")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(...arguments))
          return true;
        if (this.isContextual("type") && this.lookahead().type === types$1.star) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const pos = this.state.start;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(pos);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const pos = this.state.start;
        if (this.isContextual("declare")) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(pos, FlowErrors.DeclareClassElement);
          } else if (member.value) {
            this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
        }
        this.finishToken(types$1.name, fullWord);
      }
      getTokenFromCode(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 123 && next === 124) {
          return this.finishOp(types$1.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types$1.relational, 1);
        } else if (this.state.inType && code === 63) {
          if (next === 46) {
            return this.finishOp(types$1.questionDot, 2);
          }
          return this.finishOp(types$1.question, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.pos += 2;
          return this.readIterator();
        } else {
          return super.getTokenFromCode(code);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (node.type === "TypeCastExpression") {
          return super.toAssignable(this.typeCastToParameter(node), isLHS);
        } else {
          return super.toAssignable(node, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaPos, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, trailingCommaPos, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      checkLVal(expr, ...args) {
        if (expr.type !== "TypeCastExpression") {
          return super.checkLVal(expr, ...args);
        }
      }
      parseClassProperty(node) {
        if (this.match(types$1.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(types$1.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.isRelational("<") || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(types$1.colon) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(types$1.colon) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }
        delete method.variance;
        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }
        delete method.variance;
        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual("implements")) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.isRelational("<")) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(types$1.comma));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
          } else if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
          }
        }
      }
      parsePropertyName(node, isPrivateNameAllowed) {
        const variance = this.flowParseVariance();
        const key = super.parsePropertyName(node, isPrivateNameAllowed);
        node.variance = variance;
        return key;
      }
      parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.isRelational("<") && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types$1.parenL))
            this.unexpected();
        }
        super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(types$1.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, FlowErrors.OptionalBindingPattern);
          }
          if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
          }
          param.optional = true;
        }
        if (this.match(types$1.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
        }
        if (this.match(types$1.eq) && this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamNoDefault);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
        }
        return node;
      }
      shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return super.shouldParseDefaultImport(node);
        }
        return isMaybeDefaultImport(this.state);
      }
      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      }
      maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        let kind = null;
        if (this.match(types$1._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }
        if (kind) {
          const lh = this.lookahead();
          if (kind === "type" && lh.type === types$1.star) {
            this.unexpected(lh.start);
          }
          if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
            this.next();
            node.importKind = kind;
          }
        }
        return super.maybeParseDefaultImportSpecifier(node);
      }
      parseImportSpecifier(node) {
        const specifier = this.startNode();
        const firstIdentIsString = this.match(types$1.string);
        const firstIdent = this.parseModuleExportName();
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (firstIdentIsString) {
              throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual("as")) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const nodeIsTypeImport = hasTypeImportKind(node);
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
        }
        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.start, true);
        }
        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.start, true, true);
        }
        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case types$1._this:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, allowModifiers) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(types$1.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types$1.colon)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(types$1.colon) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const curContext = context[context.length - 1];
          if (curContext === types.j_oTag) {
            context.length -= 2;
          } else if (curContext === types.j_expr) {
            context.length -= 1;
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.isRelational("<")) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
              abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression")
              abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(types$1.colon)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(types$1.arrow))
              this.unexpected();
            return typeNode;
          });
          if (result.thrown)
            return null;
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(types$1.colon) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
          }
        }
        return super.checkParams(...arguments);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
      parseSubscripts(base, startPos, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted)
            return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
          if (result.node && !result.error)
            return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      }
      parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types$1.parenL);
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(types$1.parenL);
            node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
            if (subscriptState.optionalChainMember)
              node.optional = false;
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
      }
      parseNewArguments(node) {
        let targs = null;
        if (this.shouldParseTypes() && this.isRelational("<")) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
        super.parseNewArguments(node);
      }
      parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node))
          return;
        return this.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 124 && next === 125) {
          this.finishOp(types$1.braceBarR, 2);
          return;
        }
        super.readToken_pipe_amp(code);
      }
      parseTopLevel(file, program2) {
        const fileNode = super.parseTopLevel(file, program2);
        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, FlowErrors.NestedFlowComment);
          }
          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }
        if (this.state.hasFlowComment) {
          const end = this.input.indexOf("*-/", this.state.pos += 2);
          if (end === -1) {
            throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
          }
          this.state.pos = end + 3;
          return;
        }
        return super.skipBlockComment();
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(pos, {
        enumName,
        memberName
      }) {
        this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
      }
      flowEnumErrorInvalidMemberName(pos, {
        enumName,
        memberName
      }) {
        const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
      }
      flowEnumErrorDuplicateMemberName(pos, {
        enumName,
        memberName
      }) {
        this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
      }
      flowEnumErrorInconsistentMemberValues(pos, {
        enumName
      }) {
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      }
      flowEnumErrorInvalidExplicitType(pos, {
        enumName,
        suppliedType
      }) {
        return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
      }
      flowEnumErrorInvalidMemberInitializer(pos, {
        enumName,
        explicitType,
        memberName
      }) {
        let message = null;
        switch (explicitType) {
          case "boolean":
          case "number":
          case "string":
            message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
            break;
          case "symbol":
            message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
            break;
          default:
            message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }
        return this.raise(pos, message, enumName, memberName, explicitType);
      }
      flowEnumErrorNumberMemberNotInitialized(pos, {
        enumName,
        memberName
      }) {
        this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(pos, {
        enumName
      }) {
        this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
      }
      flowEnumMemberInit() {
        const startPos = this.state.start;
        const endOfInit = () => this.match(types$1.comma) || this.match(types$1.braceR);
        switch (this.state.type) {
          case types$1.num: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                pos: literal.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              pos: startPos
            };
          }
          case types$1.string: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                pos: literal.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              pos: startPos
            };
          }
          case types$1._true:
          case types$1._false: {
            const literal = this.parseBooleanLiteral(this.match(types$1._true));
            if (endOfInit()) {
              return {
                type: "boolean",
                pos: literal.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              pos: startPos
            };
          }
          default:
            return {
              type: "invalid",
              pos: startPos
            };
        }
      }
      flowEnumMemberRaw() {
        const pos = this.state.start;
        const id = this.parseIdentifier(true);
        const init = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {
          type: "none",
          pos
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(types$1.braceR)) {
          if (this.eat(types$1.ellipsis)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName,
              memberName
            });
          }
          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName,
              memberName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(types$1.braceR)) {
            this.expect(types$1.comma);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (this.eatContextual("of")) {
          if (!this.match(types$1.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName,
              suppliedType: null
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName,
              suppliedType: value
            });
          }
          return value;
        }
        return null;
      }
      flowEnumBody(node, {
        enumName,
        nameLoc
      }) {
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(types$1.braceL);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        });
        return this.finishNode(node, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var HEX_NUMBER = /^[\da-fA-F]+$/;
    var DECIMAL_NUMBER = /^\d+$/;
    var JsxErrors = makeErrorTemplates({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    }, ErrorCodes.SyntaxError);
    types.j_oTag = new TokContext("<tag");
    types.j_cTag = new TokContext("</tag");
    types.j_expr = new TokContext("<tag>...</tag>", true);
    types$1.jsxName = new TokenType("jsxName");
    types$1.jsxText = new TokenType("jsxText", {
      beforeExpr: true
    });
    types$1.jsxTagStart = new TokenType("jsxTagStart", {
      startsExpr: true
    });
    types$1.jsxTagEnd = new TokenType("jsxTagEnd");
    types$1.jsxTagStart.updateContext = (context) => {
      context.push(types.j_expr, types.j_oTag);
    };
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types$1.jsxTagStart);
                }
                return super.getTokenFromCode(ch);
              }
              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types$1.jsxText, out);
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types$1.string, out);
      }
      jsxReadEntity() {
        let str = "";
        let count = 0;
        let entity;
        let ch = this.input[this.state.pos];
        const startPos = ++this.state.pos;
        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];
          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);
                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);
                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }
            break;
          }
          str += ch;
        }
        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }
        return entity;
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(types$1.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(types$1.colon))
          return name;
        const node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(types$1.dot)) {
          const newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case types$1.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(node.start, JsxErrors.AttributeIsEmpty);
            }
            return node;
          case types$1.jsxTagStart:
          case types$1.string:
            return this.parseExprAtom();
          default:
            throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node) {
        if (this.match(types$1.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.eat(types$1.braceL)) {
          this.expect(types$1.ellipsis);
          node.argument = this.parseMaybeAssignAllowIn();
          this.expect(types$1.braceR);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        if (this.match(types$1.jsxTagEnd)) {
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(types$1.slash);
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        if (this.match(types$1.jsxTagEnd)) {
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.state.type) {
                case types$1.jsxTagStart:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(types$1.slash)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;
                case types$1.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case types$1.braceL: {
                  const node2 = this.startNode();
                  this.next();
                  if (this.match(types$1.ellipsis)) {
                    children.push(this.jsxParseSpreadChild(node2));
                  } else {
                    children.push(this.jsxParseExpressionContainer(node2));
                  }
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.isRelational("<")) {
          throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(types$1.jsxText)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(types$1.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
          this.finishToken(types$1.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      createLookaheadState(state) {
        const lookaheadState = super.createLookaheadState(state);
        lookaheadState.inPropertyName = state.inPropertyName;
        return lookaheadState;
      }
      getTokenFromCode(code) {
        if (this.state.inPropertyName)
          return super.getTokenFromCode(code);
        const context = this.curContext();
        if (context === types.j_expr) {
          return this.jsxReadToken();
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }
          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types$1.jsxTagEnd);
          }
          if ((code === 34 || code === 39) && context === types.j_oTag) {
            return this.jsxReadString(code);
          }
        }
        if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(types$1.jsxTagStart);
        }
        return super.getTokenFromCode(code);
      }
      updateContext(prevType) {
        super.updateContext(prevType);
        const {
          context,
          type
        } = this.state;
        if (type === types$1.slash && prevType === types$1.jsxTagStart) {
          context.splice(-2, 2, types.j_cTag);
          this.state.exprAllowed = false;
        } else if (type === types$1.jsxTagEnd) {
          const out = context.pop();
          if (out === types.j_oTag && prevType === types$1.slash || out === types.j_cTag) {
            context.pop();
            this.state.exprAllowed = context[context.length - 1] === types.j_expr;
          } else {
            this.state.exprAllowed = true;
          }
        } else if (type.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
          this.state.exprAllowed = false;
        } else {
          this.state.exprAllowed = type.beforeExpr;
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.types = new Set();
        this.enums = new Set();
        this.constEnums = new Set();
        this.classes = new Set();
        this.exportOnlyBindings = new Set();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new TypeScriptScope(flags);
      }
      declareName(name, bindingType, pos) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.add(name);
          return;
        }
        super.declareName(...arguments);
        if (bindingType & BIND_KIND_TYPE) {
          if (!(bindingType & BIND_KIND_VALUE)) {
            this.checkRedeclarationInScope(scope, name, bindingType, pos);
            this.maybeExportDefined(scope, name);
          }
          scope.types.add(name);
        }
        if (bindingType & BIND_FLAGS_TS_ENUM)
          scope.enums.add(name);
        if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
          scope.constEnums.add(name);
        if (bindingType & BIND_FLAGS_CLASS)
          scope.classes.add(name);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (scope.enums.has(name)) {
          if (bindingType & BIND_FLAGS_TS_ENUM) {
            const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
            const wasConst = scope.constEnums.has(name);
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
          if (scope.lexical.has(name)) {
            return !!(bindingType & BIND_KIND_VALUE);
          } else {
            return false;
          }
        }
        if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
          return true;
        }
        return super.isRedeclaredInScope(...arguments);
      }
      checkLocalExport(id) {
        const topLevelScope = this.scopeStack[0];
        const {
          name
        } = id;
        if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
          super.checkLocalExport(id);
        }
      }
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = makeErrorTemplates({
      AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
      AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: "'declare' is not allowed in %0ters.",
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
      DuplicateModifier: "Duplicate modifier: '%0'.",
      EmptyHeritageClauseType: "'%0' list cannot be empty.",
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
      InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
    }, ErrorCodes.SyntaxError);
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    var typescript = (superClass) => class extends superClass {
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return this.match(types$1.name);
      }
      tsTokenCanFollowModifier() {
        return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers) {
        if (!this.match(types$1.name)) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }
        return void 0;
      }
      tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
        const enforceOrder = (pos, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
          }
        };
        const incompatible = (pos, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
          }
        };
        for (; ; ) {
          const startPos = this.state.start;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
          if (!modifier)
            break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
            } else {
              enforceOrder(startPos, modifier, modifier, "override");
              enforceOrder(startPos, modifier, modifier, "static");
              enforceOrder(startPos, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(startPos, TSErrors.DuplicateModifier, modifier);
            } else {
              enforceOrder(startPos, modifier, "static", "readonly");
              enforceOrder(startPos, modifier, "static", "override");
              enforceOrder(startPos, modifier, "override", "readonly");
              enforceOrder(startPos, modifier, "abstract", "override");
              incompatible(startPos, modifier, "declare", "override");
              incompatible(startPos, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(startPos, errorTemplate, modifier);
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(types$1.braceR);
          case "HeritageClauseElement":
            return this.match(types$1.braceL);
          case "TupleElementTypes":
            return this.match(types$1.bracketR);
          case "TypeParametersOrArguments":
            return this.isRelational(">");
        }
        throw new Error("Unreachable");
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        const result = [];
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(types$1.comma)) {
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(types$1.comma);
          }
          return void 0;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types$1.bracketL);
          } else {
            this.expectRelational("<");
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement);
        if (bracket) {
          this.expect(types$1.bracketR);
        } else {
          this.expectRelational(">");
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(types$1._import);
        this.expect(types$1.parenL);
        if (!this.match(types$1.string)) {
          this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
        }
        node.argument = this.parseExprAtom();
        this.expect(types$1.parenR);
        if (this.eat(types$1.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }
        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords) {
        let entity = this.parseIdentifier();
        while (this.eat(types$1.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(false);
        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(types$1._typeof);
        if (this.match(types$1._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(types$1._extends);
        node.default = this.tsEatThenParseType(types$1.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters() {
        if (this.isRelational("<")) {
          return this.tsParseTypeParameters();
        }
      }
      tsParseTypeParameters() {
        const node = this.startNode();
        if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeParameters);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type === types$1._const) {
          this.next();
          return this.tsParseTypeReference();
        }
        return null;
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === types$1.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types$1.parenL);
        signature.parameters = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        return this.parseBindingList(types$1.parenR, 41).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
          }
          return pattern;
        });
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
          this.expect(types$1.semi);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types$1.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types$1.name) && this.match(types$1.colon);
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(types$1.bracketL);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types$1.bracketR);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types$1.question))
          node.optional = true;
        const nodeAny = node;
        if (this.match(types$1.parenL) || this.isRelational("<")) {
          if (readonly) {
            this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
          }
          const method = nodeAny;
          if (method.kind && this.isRelational("<")) {
            this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
          }
          this.tsFillSignature(types$1.colon, method);
          this.tsParseTypeMemberSemicolon();
          if (method.kind === "get") {
            if (method.parameters.length > 0) {
              this.raise(this.state.pos, ErrorMessages.BadGetterArity);
              if (this.isThisParam(method.parameters[0])) {
                this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method.kind === "set") {
            if (method.parameters.length !== 1) {
              this.raise(this.state.pos, ErrorMessages.BadSetterArity);
            } else {
              const firstParameter = method.parameters[0];
              if (this.isThisParam(firstParameter)) {
                this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
              }
              if (firstParameter.type === "RestElement") {
                this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
              }
            }
            if (method.typeAnnotation) {
              this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly)
            property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(types$1.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(types$1._new)) {
          const id = this.startNode();
          this.next();
          if (this.match(types$1.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node, false);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node, false);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(types$1.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(types$1.braceR);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(types$1.plusMin)) {
          return this.isContextual("readonly");
        }
        if (this.isContextual("readonly")) {
          this.next();
        }
        if (!this.match(types$1.bracketL)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(types$1._in);
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(types$1._in);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(types$1.braceL);
        if (this.match(types$1.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }
        this.expect(types$1.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(types$1.bracketR);
        if (this.match(types$1.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types$1.question);
        } else if (this.eat(types$1.question)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types$1.braceR);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        let labeledElements = null;
        node.elementTypes.forEach((elementNode) => {
          var _labeledElements;
          let {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
          }
          seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            type = elementNode.type;
          }
          const isLabeled = type === "TSNamedTupleMember";
          labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
          if (labeledElements !== isLabeled) {
            this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          start: startPos,
          startLoc
        } = this.state;
        const rest = this.eat(types$1.ellipsis);
        let type = this.tsParseType();
        const optional = this.eat(types$1.question);
        const labeled = this.eat(types$1.colon);
        if (labeled) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(types$1.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types$1.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract)
            this.next();
          this.next();
        }
        this.tsFillSignature(types$1.arrow, node);
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.state.type) {
            case types$1.num:
            case types$1.bigint:
            case types$1.string:
            case types$1._true:
            case types$1._false:
              return this.parseExprAtom();
            default:
              throw this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType)
          return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case types$1.name:
          case types$1._void:
          case types$1._null: {
            const type = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (type !== void 0 && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              this.next();
              return this.finishNode(node, type);
            }
            return this.tsParseTypeReference();
          }
          case types$1.string:
          case types$1.num:
          case types$1.bigint:
          case types$1._true:
          case types$1._false:
            return this.tsParseLiteralTypeNode();
          case types$1.plusMin:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
                throw this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case types$1._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case types$1._typeof:
            return this.tsParseTypeQuery();
          case types$1._import:
            return this.tsParseImportType();
          case types$1.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case types$1.bracketL:
            return this.tsParseTupleType();
          case types$1.parenL:
            return this.tsParseParenthesizedType();
          case types$1.backQuote:
            return this.tsParseTemplateLiteralType();
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
          if (this.match(types$1.bracketR)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types$1.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(types$1.bracketR);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator(operator) {
        const node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseTypeOperatorOrHigher() {
        const operator = ["keyof", "unique", "readonly"].find((kw) => this.isContextual(kw));
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
      }
      tsIsStartOfFunctionType() {
        if (this.isRelational("<")) {
          return true;
        }
        return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (this.match(types$1.name) || this.match(types$1._this)) {
          this.next();
          return true;
        }
        if (this.match(types$1.braceL)) {
          let braceStackCounter = 1;
          this.next();
          while (braceStackCounter > 0) {
            if (this.match(types$1.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types$1.braceR)) {
              --braceStackCounter;
            }
            this.next();
          }
          return true;
        }
        if (this.match(types$1.bracketL)) {
          let braceStackCounter = 1;
          this.next();
          while (braceStackCounter > 0) {
            if (this.match(types$1.bracketL)) {
              ++braceStackCounter;
            } else if (this.match(types$1.bracketR)) {
              --braceStackCounter;
            }
            this.next();
          }
          return true;
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
            return true;
          }
          if (this.match(types$1.parenR)) {
            this.next();
            if (this.match(types$1.arrow)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t2 = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(types$1._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t2.typeAnnotation = thisTypePredicate;
            return this.finishNode(t2, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t2);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t2, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t2.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t2, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : void 0;
      }
      tsTryParseTypeAnnotation() {
        return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      tsTryParseType() {
        return this.tsEatThenParseType(types$1.colon);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!this.match(types$1.name) && !this.match(types$1._this)) {
          return false;
        }
        if (containsEsc) {
          this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
        this.tsInType(() => {
          if (eatColon)
            this.expect(types$1.colon);
          t2.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t2, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types$1.question);
        node.trueType = this.tsParseType();
        this.expect(types$1.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual("abstract") && this.lookahead().type === types$1._new;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(types$1._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        const node = this.startNode();
        const _const = this.tsTryNextParseConstantContext();
        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational(">");
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(descriptor) {
        const originalStart = this.state.start;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
        if (!delimitedList.length) {
          this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
        }
        return delimitedList;
      }
      tsParseExpressionWithTypeArguments() {
        const node = this.startNode();
        node.expression = this.tsParseEntityName(false);
        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSExpressionWithTypeArguments");
      }
      tsParseInterfaceDeclaration(node) {
        if (this.match(types$1.name)) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(this.state.start, TSErrors.MissingInterfaceName);
        }
        node.typeParameters = this.tsTryParseTypeParameters();
        if (this.eat(types$1._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsInType(() => {
          this.expect(types$1.eq);
          if (this.isContextual("intrinsic") && this.lookahead().type !== types$1.dot) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
        if (this.eat(types$1.eq)) {
          node.initializer = this.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, isConst) {
        if (isConst)
          node.const = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
        this.expect(types$1.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(types$1.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types$1.braceL);
        this.parseBlockOrModuleBlockBody(node.body = [], void 0, true, types$1.braceR);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
        }
        if (this.eat(types$1.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual("global")) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types$1.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }
        if (this.match(types$1.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
        this.expect(types$1.eq);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual("require");
        this.expect(types$1.parenL);
        if (!this.match(types$1.string)) {
          throw this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(types$1.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node)
          return void 0;
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.state = state;
          return void 0;
        }
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.state.type;
        let kind;
        if (this.isContextual("let")) {
          starttype = types$1._var;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (starttype) {
            case types$1._function:
              nany.declare = true;
              return this.parseFunctionStatement(nany, false, true);
            case types$1._class:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case types$1._const:
              if (this.match(types$1._const) && this.isLookaheadContextual("enum")) {
                this.expect(types$1._const);
                this.expectContextual("enum");
                return this.tsParseEnumDeclaration(nany, true);
              }
            case types$1._var:
              kind = kind || this.state.value;
              return this.parseVarStatement(nany, kind);
            case types$1.name: {
              const value = this.state.value;
              if (value === "global") {
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              } else {
                return this.tsParseDeclaration(nany, value, true);
              }
            }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
              return declaration;
            }
            break;
          }
          case "global":
            if (this.match(types$1.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      }
      tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "enum":
            if (next || this.match(types$1.name)) {
              if (next)
                this.next();
              return this.tsParseEnumDeclaration(node, false);
            }
            break;
          case "interface":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseInterfaceDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(types$1.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (this.match(types$1.name)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak())
            return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        if (!this.isRelational("<")) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters();
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(types$1.arrow);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return this.parseArrowExpression(res, null, true);
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expectRelational("<");
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeArguments);
        }
        this.expectRelational(">");
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        if (this.match(types$1.name)) {
          switch (this.state.value) {
            case "abstract":
            case "declare":
            case "enum":
            case "interface":
            case "module":
            case "namespace":
            case "type":
              return true;
          }
        }
        return false;
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
          return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startPos, TSErrors.UnexpectedParameterModifier);
          }
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startPos, startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility)
            pp.accessibility = accessibility;
          if (readonly)
            pp.readonly = readonly;
          if (override)
            pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(types$1.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);
          if (node.declare) {
            super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            return;
          }
        }
        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
        } else {
          super.registerFunctionStatementId(...arguments);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(...args) {
        const node = super.parseArrayLike(...args);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
          this.state.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(types$1.questionDot) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.isRelational("<")) {
          let missingParenErrorPos;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const typeArguments = this.tsParseTypeArguments();
            if (typeArguments) {
              if (isOptionalCall && !this.match(types$1.parenL)) {
                missingParenErrorPos = this.state.pos;
                this.unexpected();
              }
              if (!noCalls && this.eat(types$1.parenL)) {
                node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
                this.tsCheckForInvalidTypeCasts(node.arguments);
                node.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node.optional = isOptionalCall;
                }
                return this.finishCallExpression(node, state.optionalChainMember);
              } else if (this.match(types$1.backQuote)) {
                const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
            }
            this.unexpected();
          });
          if (missingParenErrorPos) {
            this.unexpected(missingParenErrorPos, types$1.parenL);
          }
          if (result)
            return result;
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, state);
      }
      parseNewArguments(node) {
        if (this.isRelational("<")) {
          const typeParameters = this.tsTryParseAndCatch(() => {
            const args = this.tsParseTypeArguments();
            if (!this.match(types$1.parenL))
              this.unexpected();
            return args;
          });
          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }
        super.parseNewArguments(node);
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;
          const _const = this.tsTryNextParseConstantContext();
          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }
          this.finishNode(node, "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      }
      checkDuplicateExports() {
      }
      parseImport(node) {
        node.importKind = "value";
        if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
          let ahead = this.lookahead();
          if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
            node.importKind = "type";
            this.next();
            ahead = this.lookahead();
          }
          if (this.match(types$1.name) && ahead.type === types$1.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }
        }
        const importNode = super.parseImport(node);
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
        }
        return importNode;
      }
      parseExport(node) {
        if (this.match(types$1._import)) {
          this.next();
          if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.next();
          } else {
            node.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types$1.eq)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual("as")) {
          const decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }
          return super.parseExport(node);
        }
      }
      isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types$1._class;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          this.parseClass(cls, true, true);
          return cls;
        }
        if (this.state.value === "interface") {
          const interfaceNode = this.startNode();
          this.next();
          const result = this.tsParseInterfaceDeclaration(interfaceNode);
          if (result)
            return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseStatementContent(context, topLevel) {
        if (this.state.type === types$1._const) {
          const ahead = this.lookahead();
          if (ahead.type === types$1.name && ahead.value === "enum") {
            const node = this.startNode();
            this.expect(types$1._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(node, true);
          }
        }
        return super.parseStatementContent(context, topLevel);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      parseClassMember(classBody, member, state) {
        const invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
        this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));
        const callParseClassMemberWithIsStatic = () => {
          const isStatic = !!member.static;
          if (isStatic && this.eat(types$1.braceL)) {
            if (this.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
              this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
            }
            this.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
          }
          if (member.accessibility) {
            this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
          }
          if (member.declare) {
            this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
          }
          if (member.override) {
            this.raise(member.start, TSErrors.IndexSignatureHasOverride);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(member.start, TSErrors.OverrideNotInSubClass);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(types$1.question);
        if (optional)
          methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(types$1.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
        }
        if (methodOrProp.declare && this.match(types$1.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
      }
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
          return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(types$1.question)) {
          return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);
        if (this.eat(types$1.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(types$1.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual("declare");
        if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
          throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
        }
        let declaration;
        if (this.match(types$1.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }
        if (!declaration) {
          declaration = super.parseExportDeclaration(node);
        }
        if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
          node.exportKind = "type";
        }
        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types$1.bang)) {
          node.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && this.match(types$1.eq)) {
          this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
        }
        if (node.abstract && this.match(types$1.eq)) {
          const {
            key
          } = node;
          this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(node.start, TSErrors.PrivateElementHasAbstract);
        }
        if (node.accessibility) {
          this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters && isConstructor) {
          this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
        }
        if (method.declare && (method.kind === "get" || method.kind === "set")) {
          this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
        }
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }
        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, ...args) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          prop.typeParameters = typeParameters;
        super.parseObjPropValue(prop, ...args);
      }
      parseFunctionParams(node, allowModifiers) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          node.typeParameters = typeParameters;
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types$1.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(...args) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          if (context[context.length - 1] === types.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types.j_expr) {
            context.length -= 1;
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.isRelational("<")) {
          return super.parseMaybeAssign(...args);
        }
        let typeParameters;
        state = state || this.state.clone();
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters();
          const expr = super.parseMaybeAssign(...args);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted)
          return arrow.node;
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
          if (!typeCast.error)
            return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
          throw typeCast.error;
        throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
      }
      parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors);
        }
      }
      parseArrow(node) {
        if (this.match(types$1.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
            if (this.canInsertSemicolon() || !this.match(types$1.arrow))
              abort();
            return returnType;
          });
          if (result.aborted)
            return;
          if (!result.thrown) {
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(types$1.question)) {
          if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
            this.raise(param.start, TSErrors.PatternIsOptional);
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return super.toAssignable(this.typeCastToParameter(node), isLHS);
          case "TSParameterProperty":
            return super.toAssignable(node, isLHS);
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(node, isLHS);
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;
          default:
            return super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;
          default:
            return super.toAssignable(node, isLHS);
        }
      }
      checkLVal(expr, contextDescription, ...args) {
        var _expr$extra2;
        switch (expr.type) {
          case "TSTypeCastExpression":
            return;
          case "TSParameterProperty":
            this.checkLVal(expr.parameter, "parameter property", ...args);
            return;
          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
              this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
              break;
            }
            this.checkLVal(expr.expression, "parenthesized expression", ...args);
            return;
          case "TSNonNullExpression":
            this.checkLVal(expr.expression, contextDescription, ...args);
            return;
          default:
            super.checkLVal(expr, contextDescription, ...args);
            return;
        }
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case types$1._this:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          const typeArguments = this.tsParseTypeArguments();
          if (this.match(types$1.parenL)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(this.state.start, types$1.parenL);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
          this.next();
        } else {
          super.checkCommaAfterRest(close);
        }
      }
      isClassMethod() {
        return this.isRelational("<") || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(types$1.bang) || this.match(types$1.colon) || super.isClassProperty();
      }
      parseMaybeDefault(...args) {
        const node = super.parseMaybeDefault(...args);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
        }
        return node;
      }
      getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types$1.relational, 1);
        } else {
          return super.getTokenFromCode(code);
        }
      }
      reScan_lt_gt() {
        if (this.match(types$1.relational)) {
          const code = this.input.charCodeAt(this.state.start);
          if (code === 60 || code === 62) {
            this.state.pos -= 1;
            this.readToken_lt_gt(code);
          }
        }
      }
      toAssignableList(exprList) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (!expr)
            continue;
          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;
            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
              }
              break;
          }
        }
        return super.toAssignableList(...arguments);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(types$1.colon)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(types$1.colon) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.isRelational("<")) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
          if (typeArguments)
            node.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      }
      parseClass(node, ...args) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, ...args);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(types$1._class)) {
          node.abstract = true;
          return this.parseClass(node, true, false);
        } else if (this.isContextual("interface")) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
            this.next();
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, types$1._class);
        }
      }
      parseMethod(...args) {
        const method = super.parseMethod(...args);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
    };
    types$1.placeholder = new TokenType("%%", {
      startsExpr: true
    });
    var PlaceHolderErrors = makeErrorTemplates({
      ClassNameIsRequired: "A class name is required."
    }, ErrorCodes.SyntaxError);
    var placeholders = (superClass) => class extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(types$1.placeholder)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = super.parseIdentifier(true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(types$1.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        const isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      }
      getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types$1.placeholder, 2);
        }
        return super.getTokenFromCode(...arguments);
      }
      parseExprAtom() {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
      }
      parseIdentifier() {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
      }
      checkReservedWord(word) {
        if (word !== void 0)
          super.checkReservedWord(...arguments);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
      }
      checkLVal(expr) {
        if (expr.type !== "Placeholder")
          super.checkLVal(...arguments);
      }
      toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }
        return super.toAssignable(...arguments);
      }
      isLet(context) {
        if (super.isLet(context)) {
          return true;
        }
        if (!this.isContextual("let")) {
          return false;
        }
        if (context)
          return false;
        const nextToken = this.lookahead();
        if (nextToken.type === types$1.placeholder) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder")
          return;
        super.verifyBreakContinue(...arguments);
      }
      parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return super.parseExpressionStatement(...arguments);
        }
        if (this.match(types$1.colon)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      }
      parseBlock() {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
      }
      parseFunctionId() {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseExport(...arguments);
        if (!this.isContextual("from") && !this.match(types$1.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node);
      }
      isExportDefaultSpecifier() {
        if (this.match(types$1._default)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(...arguments);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseImport(...arguments);
        node.specifiers = [];
        if (!this.isContextual("from") && !this.match(types$1.comma)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);
        if (this.eat(types$1.comma)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport)
            this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual("from");
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
      }
    };
    var v8intrinsic = (superClass) => class extends superClass {
      parseV8Intrinsic() {
        if (this.match(types$1.modulo)) {
          const v8IntrinsicStart = this.state.start;
          const node = this.startNode();
          this.eat(types$1.modulo);
          if (this.match(types$1.name)) {
            const name = this.parseIdentifierName(this.state.start);
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(types$1.parenL)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStart);
        }
      }
      parseExprAtom() {
        return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
      }
    };
    function hasPlugin(plugins, name) {
      return plugins.some((plugin) => {
        if (Array.isArray(plugin)) {
          return plugin[0] === name;
        } else {
          return plugin === name;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      const plugin = plugins.find((plugin2) => {
        if (Array.isArray(plugin2)) {
          return plugin2[0] === name;
        } else {
          return plugin2 === name;
        }
      });
      if (plugin && Array.isArray(plugin)) {
        return plugin[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["%", "#"];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport == null) {
          throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        } else if (typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") === "hash";
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions")) {
            throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
          }
          const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVerionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true
    };
    function getOptions(opts) {
      const options = {};
      for (const key of Object.keys(defaultOptions)) {
        options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
      }
      return options;
    }
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
            } else if (parenthesized.type !== "MemberExpression") {
              this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
            }
          } else {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
                this.raiseRestNotLast(node.extra.trailingComma);
              }
            }
            break;
          case "ObjectProperty":
            this.toAssignable(node.value, isLHS);
            break;
          case "SpreadElement": {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            const arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
        return node;
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          const error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
          this.raise(prop.key.start, error);
        } else if (prop.type === "SpreadElement" && !isLast) {
          this.raiseRestNotLast(prop.start);
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaPos, isLHS) {
        let end = exprList.length;
        if (end) {
          const last = exprList[end - 1];
          if ((last == null ? void 0 : last.type) === "RestElement") {
            --end;
          } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
            last.type = "RestElement";
            let arg = last.argument;
            this.toAssignable(arg, isLHS);
            arg = unwrapParenthesizedExpression(arg);
            if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
              this.unexpected(arg.start);
            }
            if (trailingCommaPos) {
              this.raiseTrailingCommaAfterRest(trailingCommaPos);
            }
            --end;
          }
        }
        for (let i = 0; i < end; i++) {
          const elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isLHS);
            if (elt.type === "RestElement") {
              this.raiseRestNotLast(elt.start);
            }
          }
        }
        return exprList;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors, refNeedsArrowPos) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case types$1.bracketL: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }
          case types$1.braceL:
            return this.parseObjectLike(types$1.braceR, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.match(types$1.comma)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(types$1.ellipsis)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
            this.checkCommaAfterRest(closeCharCode);
            this.expect(close);
            break;
          } else {
            const decorators = [];
            if (this.match(types$1.at) && this.hasPlugin("decorators")) {
              this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
            }
            while (this.match(types$1.at)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(allowModifiers, decorators));
          }
        }
        return elts;
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param) {
        return param;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        var _startLoc, _startPos, _left;
        startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
        startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(types$1.eq))
          return left;
        const node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {
        switch (expr.type) {
          case "Identifier": {
            const {
              name
            } = expr;
            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
            }
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(expr.start, ErrorMessages.ParamDupe);
              } else {
                checkClashes.add(name);
              }
            }
            if (disallowLetBinding && name === "let") {
              this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
            }
            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.start);
            }
            break;
          }
          case "MemberExpression":
            if (bindingType !== BIND_NONE) {
              this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
            }
            break;
          case "ObjectPattern":
            for (let prop of expr.properties) {
              if (this.isObjectProperty(prop))
                prop = prop.value;
              else if (this.isObjectMethod(prop))
                continue;
              this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
            break;
          case "ArrayPattern":
            for (const elem of expr.elements) {
              if (elem) {
                this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
              }
            }
            break;
          case "AssignmentPattern":
            this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
            break;
          case "ParenthesizedExpression":
            this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
            break;
          default: {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
        }
      }
      checkToRestConversion(node) {
        if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
          this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
        }
      }
      checkCommaAfterRest(close) {
        if (this.match(types$1.comma)) {
          if (this.lookaheadCharCode() === close) {
            this.raiseTrailingCommaAfterRest(this.state.start);
          } else {
            this.raiseRestNotLast(this.state.start);
          }
        }
      }
      raiseRestNotLast(pos) {
        throw this.raise(pos, ErrorMessages.ElementAfterRest);
      }
      raiseTrailingCommaAfterRest(pos) {
        this.raise(pos, ErrorMessages.RestTrailingComma);
      }
    };
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(key.start, ErrorMessages.RecordNoProto);
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProto === -1) {
                refExpressionErrors.doubleProto = key.start;
              }
            } else {
              this.raise(key.start, ErrorMessages.DuplicateProto);
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(types$1.eof)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(types$1.comma)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$pos;
        refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        if (this.isContextual("yield")) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startPos, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        if (this.match(types$1.parenL) || this.match(types$1.name)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.state.type.isAssign) {
          const node = this.startNodeAt(startPos, startLoc);
          const operator = this.state.value;
          node.operator = operator;
          const leftIsHackPipeExpression = left.type === "BinaryExpression" && left.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack";
          if (leftIsHackPipeExpression) {
            throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, operator);
          }
          if (this.match(types$1.eq)) {
            node.left = this.toAssignable(left, true);
            refExpressionErrors.doubleProto = -1;
          } else {
            node.left = left;
          }
          if (refExpressionErrors.shorthandAssign >= node.left.start) {
            refExpressionErrors.shorthandAssign = -1;
          }
          this.checkLVal(left, "assignment expression");
          this.next();
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentExpression");
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (this.eat(types$1.question)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseExprOps(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnary(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startPos, startLoc, -1);
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        let prec = this.state.type.binop;
        if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
          if (prec > minPrec) {
            const op = this.state.type;
            if (op === types$1.pipeline) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartPos);
            }
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === types$1.logicalOR || op === types$1.logicalAND;
            const coalesce = op === types$1.nullishCoalescing;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            this.next();
            if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
              if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
                throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
              throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        switch (op) {
          case types$1.pipeline:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  const bodyExpr = this.parseHackPipeBody(op, prec);
                  this.checkHackPipeBodyEarlyErrors(startPos);
                  return bodyExpr;
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  const childExpr = this.parseHackPipeBody(op, prec);
                  return this.parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
      }
      parseHackPipeBody(op, prec) {
        const bodyIsInGeneratorContext = this.prodParam.hasYield;
        const bodyIsYieldExpression = bodyIsInGeneratorContext && this.isContextual("yield");
        if (bodyIsYieldExpression) {
          throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, this.state.value);
        } else {
          return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      checkExponentialAfterUnary(node) {
        if (this.match(types$1.exponent)) {
          this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual("await");
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startPos, startLoc);
          if (!sawUnary)
            this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(types$1.incDec);
        const node = this.startNode();
        if (this.state.type.prefix) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(types$1._throw)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(types$1._delete);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(node.start, ErrorMessages.StrictDelete);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(node.start, ErrorMessages.DeletePrivateField);
            }
          }
          if (!update) {
            if (!sawUnary)
              this.checkExponentialAfterUnary(node);
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);
            return this.parseAwait(startPos, startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          this.checkLVal(node.argument, "prefix operation");
          return this.finishNode(node, "UpdateExpression");
        }
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false))
          return expr;
        while (this.state.type.postfix && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.checkLVal(expr, "postfix operation");
          this.next();
          expr = this.finishNode(node2, "UpdateExpression");
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startPos, startLoc);
      }
      parseSubscripts(base, startPos, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!noCalls && this.eat(types$1.doubleColon)) {
          return this.parseBind(base, startPos, startLoc, noCalls, state);
        } else if (this.match(types$1.backQuote)) {
          return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
        }
        let optional = false;
        if (this.match(types$1.questionDot)) {
          if (noCalls && this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(types$1.parenL)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
        } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
          return this.parseMember(base, startPos, startLoc, state, optional);
        } else {
          state.stop = true;
          return base;
        }
      }
      parseMember(base, startPos, startLoc, state, optional) {
        const node = this.startNodeAt(startPos, startLoc);
        const computed = this.eat(types$1.bracketL);
        node.object = base;
        node.computed = computed;
        const privateName = !computed && this.match(types$1.privateName) && this.state.value;
        const property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);
        if (privateName !== false) {
          if (node.object.type === "Super") {
            this.raise(startPos, ErrorMessages.SuperPrivateField);
          }
          this.classScope.usePrivateName(privateName, property.start);
        }
        node.property = property;
        if (computed) {
          this.expect(types$1.bracketR);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startPos, startLoc, noCalls, state) {
        const node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        let node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        if (state.maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (state.optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(types$1.parenR);
        } else {
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
        }
        this.finishCallExpression(node, state.optionalChainMember);
        if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
        } else {
          if (state.maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, state) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectPlugin("importAssertions");
              }
            }
          }
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
              }
              if (nodeForExtra) {
                this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(types$1.arrow) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(types$1.arrow);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
        setInnerComments(node, call.innerComments);
        setInnerComments(node, call.callee.trailingComments);
        return node;
      }
      parseNoCallExpr() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        switch (this.state.type) {
          case types$1._super:
            return this.parseSuper();
          case types$1._import:
            node = this.startNode();
            this.next();
            if (this.match(types$1.dot)) {
              return this.parseImportMetaProperty(node);
            }
            if (!this.match(types$1.parenL)) {
              this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
            }
            return this.finishNode(node, "Import");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name: {
            if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
              return this.parseModuleExpression();
            }
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types$1._function)) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), void 0, true);
              } else if (this.match(types$1.name)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (this.match(types$1._do)) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }
            if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }
            return id;
          }
          case types$1._do: {
            return this.parseDo(this.startNode(), false);
          }
          case types$1.slash:
          case types$1.slashAssign: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case types$1.num:
            return this.parseNumericLiteral(this.state.value);
          case types$1.bigint:
            return this.parseBigIntLiteral(this.state.value);
          case types$1.decimal:
            return this.parseDecimalLiteral(this.state.value);
          case types$1.string:
            return this.parseStringLiteral(this.state.value);
          case types$1._null:
            return this.parseNullLiteral();
          case types$1._true:
            return this.parseBooleanLiteral(true);
          case types$1._false:
            return this.parseBooleanLiteral(false);
          case types$1.parenL: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case types$1.bracketBarL:
          case types$1.bracketHashL: {
            return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
          }
          case types$1.bracketL: {
            return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
          }
          case types$1.braceBarL:
          case types$1.braceHashL: {
            return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
          }
          case types$1.braceL: {
            return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
          }
          case types$1._function:
            return this.parseFunctionOrFunctionSent();
          case types$1.at:
            this.parseDecorators();
          case types$1._class:
            node = this.startNode();
            this.takeDecorators(node);
            return this.parseClass(node, false);
          case types$1._new:
            return this.parseNewOrNewTarget();
          case types$1.backQuote:
            return this.parseTemplate(false);
          case types$1.doubleColon: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }
          case types$1.privateName: {
            const {
              value,
              start
            } = this.state;
            node = this.parsePrivateName();
            if (this.match(types$1._in)) {
              this.classScope.usePrivateName(value, start);
            } else {
              this.raise(start, ErrorMessages.PrivateInExpectedIn, value);
            }
            return node;
          }
          case types$1.moduloAssign:
            if (this.getPluginOption("pipelineOperator", "proposal") === "hack" && this.getPluginOption("pipelineOperator", "topicToken") === "%") {
              this.state.value = "%";
              this.state.type = types$1.modulo;
              this.state.pos--;
              this.state.end--;
              this.state.endLoc.column--;
            } else {
              throw this.unexpected();
            }
          case types$1.modulo:
          case types$1.hash: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              node = this.startNode();
              const start = this.state.start;
              const tokenType = this.state.type;
              this.next();
              return this.finishTopicReference(node, start, pipeProposal, tokenType);
            }
          }
          case types$1.relational: {
            if (this.state.value === "<") {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
              }
            }
          }
          default:
            throw this.unexpected();
        }
      }
      finishTopicReference(node, start, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {
          let nodeType;
          if (pipeProposal === "smart") {
            nodeType = "PipelinePrimaryTopicReference";
          } else {
            nodeType = "TopicReference";
          }
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            if (pipeProposal === "smart") {
              this.raise(start, ErrorMessages.PrimaryTopicNotAllowed);
            } else {
              this.raise(start, ErrorMessages.PipeTopicUnbound);
            }
          }
          this.registerTopicReference();
          return this.finishNode(node, nodeType);
        } else {
          throw this.raise(start, ErrorMessages.PipeTopicUnconfiguredToken, tokenType.label);
        }
      }
      testTopicReferenceConfiguration(pipeProposal, start, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            const pluginTopicToken = this.getPluginOption("pipelineOperator", "topicToken");
            return tokenType.label === pluginTopicToken;
          }
          case "smart":
            return tokenType === types$1.hash;
          default:
            throw this.raise(start, ErrorMessages.PipeTopicRequiresHackPipes);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
        }
        this.expect(types$1.arrow);
        this.parseArrowExpression(node, params, true);
        return node;
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(PARAM_AWAIT);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(node.start, ErrorMessages.SuperNotAllowed);
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(node.start, ErrorMessages.UnexpectedSuper);
        }
        if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
          this.raise(node.start, ErrorMessages.UnsupportedSuper);
        }
        return this.finishNode(node, "Super");
      }
      parseMaybePrivateName(isPrivateNameAllowed) {
        const isPrivate = this.match(types$1.privateName);
        if (isPrivate) {
          if (!isPrivateNameAllowed) {
            this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
          }
          return this.parsePrivateName();
        } else {
          return this.parseIdentifier(true);
        }
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(types$1.dot)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        if (meta.name === "function" && propertyName === "sent") {
          if (this.isContextual(propertyName)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
        }
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual("meta")) {
          if (!this.inModule) {
            this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
          }
          this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartPos = this.state.start;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStart;
        let optionalCommaStart;
        while (!this.match(types$1.parenR)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);
            if (this.match(types$1.parenR)) {
              optionalCommaStart = this.state.start;
              break;
            }
          }
          if (this.match(types$1.ellipsis)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStart = this.state.start;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
            this.checkCommaAfterRest(41);
            break;
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndPos = this.state.lastTokEnd;
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(types$1.parenR);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startPos, startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStart);
        }
        if (optionalCommaStart)
          this.unexpected(optionalCommaStart);
        if (spreadStart)
          this.unexpected(spreadStart);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          val.end = innerEndPos;
          val.loc.end = innerEndLoc;
        } else {
          val = exprList[0];
        }
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(val, "parenthesized", true);
          this.addExtra(val, "parenStart", startPos);
          return val;
        }
        const parenExpression = this.startNodeAt(startPos, startLoc);
        parenExpression.expression = val;
        this.finishNode(parenExpression, "ParenthesizedExpression");
        return parenExpression;
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(types$1.arrow)) {
          return node;
        }
      }
      parseParenItem(node, startPos, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(types$1.dot)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
            this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        node.callee = this.parseNoCallExpr();
        if (node.callee.type === "Import") {
          this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
        } else if (this.isOptionalChain(node.callee)) {
          this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
        } else if (this.eat(types$1.questionDot)) {
          this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
        }
        this.parseNewArguments(node);
        return this.finishNode(node, "NewExpression");
      }
      parseNewArguments(node) {
        if (this.eat(types$1.parenL)) {
          const args = this.parseExprList(types$1.parenR);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
      }
      parseTemplateElement(isTagged) {
        const elem = this.startNode();
        if (this.state.value === null) {
          if (!isTagged) {
            this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
          }
        }
        elem.value = {
          raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
          cooked: this.state.value
        };
        this.next();
        elem.tail = this.match(types$1.backQuote);
        return this.finishNode(elem, "TemplateElement");
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement(isTagged);
        node.quasis = [curElt];
        while (!curElt.tail) {
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseTemplateSubstitution());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
            if (this.match(close)) {
              this.addExtra(node, "trailingComma", this.state.lastTokStart);
              break;
            }
          }
          const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);
          if (!isPattern) {
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
          }
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
      }
      parsePropertyDefinition(isPattern, refExpressionErrors) {
        let decorators = [];
        if (this.match(types$1.at)) {
          if (this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
          }
          while (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isGenerator = false;
        let isAsync = false;
        let isAccessor = false;
        let startPos;
        let startLoc;
        if (this.match(types$1.ellipsis)) {
          if (decorators.length)
            this.unexpected();
          if (isPattern) {
            this.next();
            prop.argument = this.parseIdentifier();
            this.checkCommaAfterRest(125);
            return this.finishNode(prop, "RestElement");
          }
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (isPattern || refExpressionErrors) {
          startPos = this.state.start;
          startLoc = this.state.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, false);
        if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(types$1.star);
            this.parsePropertyName(prop, false);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(types$1.star)) {
              isGenerator = true;
              this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
              this.next();
            }
            this.parsePropertyName(prop, false);
          }
        }
        this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        return prop;
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const start = method.start;
        if (params.length !== paramCount) {
          if (method.kind === "get") {
            this.raise(start, ErrorMessages.BadGetterArity);
          } else {
            this.raise(start, ErrorMessages.BadSetterArity);
          }
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(prop);
          return prop;
        }
        if (isAsync || isGenerator || this.match(types$1.parenL)) {
          if (isPattern)
            this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
          } else if (this.match(types$1.eq) && refExpressionErrors) {
            if (refExpressionErrors.shorthandAssign === -1) {
              refExpressionErrors.shorthandAssign = this.state.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        if (!node)
          this.unexpected();
        return node;
      }
      parsePropertyName(prop, isPrivateNameAllowed) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(types$1.bracketR);
        } else {
          const oldInPropertyName = this.state.inPropertyName;
          this.state.inPropertyName = true;
          const type = this.state.type;
          prop.key = type === types$1.num || type === types$1.string || type === types$1.bigint || type === types$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);
          if (type !== types$1.privateName) {
            prop.computed = false;
          }
          this.state.inPropertyName = oldInPropertyName;
        }
        return prop.key;
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = !!isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = !!isGenerator;
        const allowModifiers = isConstructor;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, allowModifiers);
        this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return node;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaPos) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        let flags = functionFlags(isAsync, false);
        if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
          flags |= PARAM_IN;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaPos);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaPos) {
        node.params = this.toAssignableList(params, trailingCommaPos, false);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(types$1.braceL);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              const errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
              this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkLVal(node.id, "function name", BIND_OUTSIDE, void 0, void 0, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.expressionScope.exit();
          this.state.labels = oldLabels;
        }
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (params[i].type !== "Identifier")
            return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = new Set();
        for (const param of node.params) {
          this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(types$1.comma)) {
          if (!allowEmpty) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
          }
          elt = null;
        } else if (this.match(types$1.ellipsis)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
        } else if (this.match(types$1.question)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(node.start, liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(pos, liberal) {
        let name;
        const {
          start,
          type
        } = this.state;
        if (type === types$1.name) {
          name = this.state.value;
        } else if (type.keyword) {
          name = type.keyword;
        } else {
          throw this.unexpected();
        }
        if (liberal) {
          this.state.type = types$1.name;
        } else {
          this.checkReservedWord(name, start, !!type.keyword, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
            return;
          } else if (this.scope.inStaticBlock) {
            this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
            return;
          } else {
            this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
          }
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(startLoc, ErrorMessages.ArgumentsInClass);
            return;
          }
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait)
          return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);
        if (this.eat(types$1.star)) {
          this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(types$1.star);
          switch (this.state.type) {
            case types$1.semi:
            case types$1.eof:
            case types$1.braceR:
            case types$1.parenR:
            case types$1.bracketR:
            case types$1.braceBarR:
            case types$1.colon:
            case types$1.comma:
              if (!delegating)
                break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartPos) {
        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
          if (left.type === "SequenceExpression") {
            this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
          }
        }
      }
      checkHackPipeBodyEarlyErrors(startPos) {
        if (this.match(types$1.arrow)) {
          throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, types$1.arrow.label);
        } else if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(startPos, ErrorMessages.PipeTopicUnused);
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
        const bodyNode = this.startNodeAt(startPos, startLoc);
        if (this.isSimpleReference(childExpr)) {
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          this.checkSmartPipeTopicBodyEarlyErrors(startPos);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startPos) {
        if (this.match(types$1.arrow)) {
          throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
        } else if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        const proposal = this.getPluginOption("pipelineOperator", "proposal");
        if (proposal === "smart") {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = PARAM_IN & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = PARAM_IN & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret2 = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret2;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        this.eat(types$1.braceL);
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        const program2 = this.startNode();
        try {
          node.body = this.parseProgram(program2, types$1.braceR, "module");
        } finally {
          revertScopes();
        }
        this.eat(types$1.braceR);
        return this.finishNode(node, "ModuleExpression");
      }
    };
    var loopLabel = {
      kind: "loop"
    };
    var switchLabel = {
      kind: "switch"
    };
    var FUNC_NO_FLAGS = 0;
    var FUNC_STATEMENT = 1;
    var FUNC_HANGING_STATEMENT = 2;
    var FUNC_NULLABLE_ID = 4;
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens) {
      {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (token.type === types$1.privateName) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = new Position(loc.start.line, loc.start.column + 1);
            tokens.splice(i, 1, new Token({
              type: types$1.hash,
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: types$1.name,
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
          }
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program2) {
        file.program = this.parseProgram(program2);
        file.comments = this.state.comments;
        if (this.options.tokens)
          file.tokens = babel7CompatTokens(this.tokens);
        return this.finishNode(file, "File");
      }
      parseProgram(program2, end = types$1.eof, sourceType = this.options.sourceType) {
        program2.sourceType = sourceType;
        program2.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program2, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [name] of Array.from(this.scope.undefinedExports)) {
            const pos = this.scope.undefinedExports.get(name);
            this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
          }
        }
        return this.finishNode(program2, "Program");
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(types$1.interpreterDirective)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet(context) {
        if (!this.isContextual("let")) {
          return false;
        }
        return this.isLetKeyword(context);
      }
      isLetKeyword(context) {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        if (nextCh === 92 || nextCh === 91) {
          return true;
        }
        if (context)
          return false;
        if (nextCh === 123)
          return true;
        if (isIdentifierStart(nextCh)) {
          keywordRelationalOperator.lastIndex = next;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      parseStatement(context, topLevel) {
        if (this.match(types$1.at)) {
          this.parseDecorators(true);
        }
        return this.parseStatementContent(context, topLevel);
      }
      parseStatementContent(context, topLevel) {
        let starttype = this.state.type;
        const node = this.startNode();
        let kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (this.lookaheadCharCode() === 46)
              break;
            if (context) {
              if (this.state.strict) {
                this.raise(this.state.start, ErrorMessages.StrictFunction);
              } else if (context !== "if" && context !== "label") {
                this.raise(this.state.start, ErrorMessages.SloppyFunction);
              }
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context)
              this.unexpected();
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.state.value;
            if (context && kind !== "var") {
              this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock();
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._import: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case types$1._export: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }
            this.next();
            let result;
            if (starttype === types$1._import) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(node);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
          return this.parseLabeledStatement(node, maybeName, expr, context);
        } else {
          return this.parseExpressionStatement(node, expr);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
        }
      }
      takeDecorators(node) {
        const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (decorators.length) {
          node.decorators = decorators;
          this.resetStartLocationFromNode(node, decorators[0]);
          this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
        }
      }
      canHaveLeadingDecorator() {
        return this.match(types$1._class);
      }
      parseDecorators(allowExport) {
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        while (this.match(types$1.at)) {
          const decorator = this.parseDecorator();
          currentContextDecorators.push(decorator);
        }
        if (this.match(types$1._export)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
        }
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators-legacy", "decorators"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          this.state.decoratorStack.push([]);
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr;
          if (this.eat(types$1.parenL)) {
            expr = this.parseExpression();
            this.expect(types$1.parenR);
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(types$1.dot)) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.object = expr;
              node2.property = this.parseIdentifier(true);
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
          }
          node.expression = this.parseMaybeDecoratorArguments(expr);
          this.state.decoratorStack.pop();
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(types$1.parenL)) {
          const node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, keyword) {
        const isBreak = keyword === "break";
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, keyword);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, keyword) {
        const isBreak = keyword === "break";
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop"))
              break;
            if (node.label && isBreak)
              break;
          }
        }
        if (i === this.state.labels.length) {
          this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(types$1.parenL);
        const val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      }
      parseDoStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
        this.state.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseHeaderExpression();
        this.eat(types$1.semi);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = -1;
        if (this.isAwaitAllowed() && this.eatContextual("await")) {
          awaitAt = this.state.lastTokStart;
        }
        this.scope.enter(SCOPE_OTHER);
        this.expect(types$1.parenL);
        if (this.match(types$1.semi)) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual("let");
        const isLet = startsWithLet && this.isLetKeyword();
        if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
          const init2 = this.startNode();
          const kind = isLet ? "let" : this.state.value;
          this.next();
          this.parseVar(init2, true, kind);
          this.finishNode(init2, "VariableDeclaration");
          if ((this.match(types$1._in) || this.isContextual("of")) && init2.declarations.length === 1) {
            return this.parseForIn(node, init2, awaitAt);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init2);
        }
        const startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual("of");
        if (isForOf) {
          if (startsWithLet) {
            this.raise(init.start, ErrorMessages.ForOfLet);
          } else if (awaitAt === -1 && startsWithUnescapedName && init.type === "Identifier" && init.name === "async") {
            this.raise(init.start, ErrorMessages.ForOfAsync);
          }
        }
        if (isForOf || this.match(types$1._in)) {
          this.toAssignable(init, true);
          const description = isForOf ? "for-of statement" : "for-in statement";
          this.checkLVal(init, description);
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(this.state.start, ErrorMessages.IllegalReturn);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(types$1.braceL);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        let cur;
        for (let sawDefault; !this.match(types$1.braceR); ) {
          if (this.match(types$1._case) || this.match(types$1._default)) {
            const isCase = this.match(types$1._case);
            if (cur)
              this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatement(null));
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur)
          this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        const simple = param.type === "Identifier";
        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(param, "catch clause", BIND_LEXICAL);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(types$1._catch)) {
          const clause = this.startNode();
          this.next();
          if (this.match(types$1.parenL)) {
            this.expect(types$1.parenL);
            clause.param = this.parseCatchClauseParam();
            this.expect(types$1.parenR);
          } else {
            clause.param = null;
            this.scope.enter(SCOPE_OTHER);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, ErrorMessages.NoCatchOrFinally);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(this.state.start, ErrorMessages.StrictWith);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, context) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
          }
        }
        const kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.state.start;
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.state.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.scope.enter(SCOPE_OTHER);
        }
        this.parseBlockBody(node, allowDirectives, false, types$1.braceR, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = this.parseStatement(null, topLevel);
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        if (afterBlockParse) {
          afterBlockParse.call(this, hasStrictModeDirective);
        }
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(types$1.semi) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(types$1.parenR) ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(types$1._in);
        this.next();
        if (isForIn) {
          if (awaitAt > -1)
            this.unexpected(awaitAt);
        } else {
          node.await = awaitAt > -1;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
        } else if (init.type === "AssignmentPattern") {
          this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(types$1.parenR);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind) {
        const declarations = node.declarations = [];
        const isTypescript = this.hasPlugin("typescript");
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          } else {
            if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
              if (!isTypescript) {
                this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
              }
            } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
            }
            decl.init = null;
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma))
            break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, void 0, kind !== "var");
      }
      parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
        const isStatement = statement & FUNC_STATEMENT;
        const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
        const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
        this.initFunction(node, isAsync);
        if (this.match(types$1.star) && isHangingStatement) {
          this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
        }
        node.generator = this.eat(types$1.star);
        if (isStatement) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isStatement) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isStatement && !isHangingStatement) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, allowModifiers) {
        this.expect(types$1.parenL);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id)
          return;
        this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        this.takeDecorators(node);
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
      }
      isClassMethod() {
        return this.match(types$1.parenL);
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(types$1.braceL);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(types$1.braceR)) {
            if (this.eat(types$1.semi)) {
              if (decorators.length > 0) {
                throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
              }
              continue;
            }
            if (this.match(types$1.at)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(member.start, ErrorMessages.DecoratorConstructor);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual("static");
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        if (this.eat(types$1.star)) {
          method.kind = "method";
          const isPrivateName = this.match(types$1.privateName);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = this.match(types$1.name) && !this.state.containsEsc;
        const isPrivate = this.match(types$1.privateName);
        const key = this.parseClassElementName(member);
        const maybeQuestionTokenStart = this.state.start;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(key.start, ErrorMessages.DuplicateConstructor);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(key.start, ErrorMessages.OverrideOnConstructor);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(types$1.star);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStart);
          }
          method.kind = "method";
          const isPrivate2 = this.match(types$1.privateName);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(types$1.star) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = key.name;
          const isPrivate2 = this.match(types$1.privateName);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value,
          start
        } = this.state;
        if ((type === types$1.name || type === types$1.string) && member.static && value === "prototype") {
          this.raise(start, ErrorMessages.StaticPrototype);
        }
        if (type === types$1.privateName && value === "constructor") {
          this.raise(start, ErrorMessages.ConstructorClassPrivateField);
        }
        return this.parsePropertyName(member, true);
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.expectPlugin("classStaticBlock", member.start);
        this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(PARAM);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, types$1.braceR);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
          this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseInitializer(node) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(PARAM);
        node.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
        if (this.match(types$1.name)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.checkLVal(node.id, "class name", bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            this.unexpected(null, ErrorMessages.MissingClassName);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
      }
      parseExport(node) {
        const hasDefault = this.maybeParseExportDefaultSpecifier(node);
        const parseAfterDefault = !hasDefault || this.eat(types$1.comma);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault)
            this.unexpected();
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
          throw this.unexpected(null, types$1.braceL);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          this.checkExport(node, true, false, !!node.source);
          return this.finishNode(node, "ExportNamedDeclaration");
        }
        if (this.eat(types$1._default)) {
          node.declaration = this.parseExportDefaultExpression();
          this.checkExport(node, true, true);
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, types$1.braceL);
      }
      eatExportStar(node) {
        return this.eat(types$1.star);
      }
      maybeParseExportDefaultSpecifier(node) {
        if (this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = this.parseIdentifier(true);
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual("as")) {
          if (!node.specifiers)
            node.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(types$1.braceL)) {
          if (!node.specifiers)
            node.specifiers = [];
          node.specifiers.push(...this.parseExportSpecifiers());
          node.source = null;
          node.declaration = null;
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual("async"))
          return false;
        const next = this.nextTokenStart();
        return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        const isAsync = this.isAsyncFunction();
        if (this.match(types$1._function) || isAsync) {
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
        } else if (this.match(types$1._class)) {
          return this.parseClass(expr, true, true);
        } else if (this.match(types$1.at)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
          }
          this.parseDecorators(false);
          return this.parseClass(expr, true, true);
        } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
          throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
        } else {
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
      }
      parseExportDeclaration(node) {
        return this.parseStatement(null);
      }
      isExportDefaultSpecifier() {
        if (this.match(types$1.name)) {
          const value = this.state.value;
          if (value === "async" && !this.state.containsEsc || value === "let") {
            return false;
          }
          if ((value === "type" || value === "interface") && !this.state.containsEsc) {
            const l = this.lookahead();
            if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(types$1._default)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
          return true;
        }
        if (this.match(types$1._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual("from")) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          }
        } else {
          if (expect) {
            this.unexpected();
          } else {
            node.source = null;
          }
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        if (this.match(types$1.at)) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
            } else {
              return true;
            }
          }
        }
        return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
              }
            }
          } else if (node.specifiers && node.specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportedName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
                } else {
                  this.checkReservedWord(local.name, local.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
              const id = node.declaration.id;
              if (!id)
                throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (node.declaration.type === "VariableDeclaration") {
              for (const declaration of node.declaration.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (currentContextDecorators.length) {
          throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, name) {
        if (this.exportedIdentifiers.has(name)) {
          this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
        }
        this.exportedIdentifiers.add(name);
      }
      parseExportSpecifiers() {
        const nodes = [];
        let first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
            if (this.eat(types$1.braceR))
              break;
          }
          const node = this.startNode();
          const isString = this.match(types$1.string);
          const local = this.parseModuleExportName();
          node.local = local;
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
          } else if (isString) {
            node.exported = cloneStringLiteral(local);
          } else {
            node.exported = cloneIdentifier(local);
          }
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      }
      parseModuleExportName() {
        if (this.match(types$1.string)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = result.value.match(loneSurrogate);
          if (surrogate) {
            this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      parseImport(node) {
        node.specifiers = [];
        if (!this.match(types$1.string)) {
          const hasDefault = this.maybeParseDefaultImportSpecifier(node);
          const parseNext = !hasDefault || this.eat(types$1.comma);
          const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
          if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
          this.expectContextual("from");
        }
        node.source = this.parseImportSource();
        const assertions = this.maybeParseImportAssertions();
        if (assertions) {
          node.assertions = assertions;
        } else {
          const attributes = this.maybeParseModuleAttributes();
          if (attributes) {
            node.attributes = attributes;
          }
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(types$1.string))
          this.unexpected();
        return this.parseExprAtom();
      }
      shouldParseDefaultImport(node) {
        return this.match(types$1.name);
      }
      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      }
      parseAssertEntries() {
        const attrs = [];
        const attrNames = new Set();
        do {
          if (this.match(types$1.braceR)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
          }
          attrNames.add(keyName);
          if (this.match(types$1.string)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(types$1.colon);
          if (!this.match(types$1.string)) {
            throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
          }
          node.value = this.parseStringLiteral(this.state.value);
          this.finishNode(node, "ImportAttribute");
          attrs.push(node);
        } while (this.eat(types$1.comma));
        return attrs;
      }
      maybeParseModuleAttributes() {
        if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("moduleAttributes");
          this.next();
        } else {
          if (this.hasPlugin("moduleAttributes"))
            return [];
          return null;
        }
        const attrs = [];
        const attributes = new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
          }
          if (attributes.has(node.key.name)) {
            this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
          }
          attributes.add(node.key.name);
          this.expect(types$1.colon);
          if (!this.match(types$1.string)) {
            throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
          }
          node.value = this.parseStringLiteral(this.state.value);
          this.finishNode(node, "ImportAttribute");
          attrs.push(node);
        } while (this.eat(types$1.comma));
        return attrs;
      }
      maybeParseImportAssertions() {
        if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("importAssertions");
          this.next();
        } else {
          if (this.hasPlugin("importAssertions"))
            return [];
          return null;
        }
        this.eat(types$1.braceL);
        const attrs = this.parseAssertEntries();
        this.eat(types$1.braceR);
        return attrs;
      }
      maybeParseDefaultImportSpecifier(node) {
        if (this.shouldParseDefaultImport(node)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(types$1.star)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual("as");
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(types$1.colon)) {
              throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
            }
            this.expect(types$1.comma);
            if (this.eat(types$1.braceR))
              break;
          }
          this.parseImportSpecifier(node);
        }
      }
      parseImportSpecifier(node) {
        const specifier = this.startNode();
        const importedIsString = this.match(types$1.string);
        specifier.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
          }
          this.checkReservedWord(imported.name, specifier.start, true, true);
          specifier.local = cloneIdentifier(imported);
        }
        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program2 = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program2);
        file.errors = this.state.errors;
        return file;
      }
    };
    function pluginsMap(plugins) {
      const pluginMap = new Map();
      for (const plugin of plugins) {
        const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
        if (!pluginMap.has(name))
          pluginMap.set(name, options || {});
      }
      return pluginMap;
    }
    function parse3(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function getParser(options, input) {
      let cls = Parser;
      if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
      const key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    exports2.parse = parse3;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = types$1;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/estree-walker-npm-2.0.2-dfab42f65c-6151e6f982.zip/node_modules/estree-walker/dist/umd/estree-walker.js
var require_estree_walker = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/estree-walker-npm-2.0.2-dfab42f65c-6151e6f982.zip/node_modules/estree-walker/dist/umd/estree-walker.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.estreeWalker = {}));
    })(exports2, function(exports3) {
      "use strict";
      class WalkerBase {
        constructor() {
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.context = {
            skip: () => this.should_skip = true,
            remove: () => this.should_remove = true,
            replace: (node) => this.replacement = node
          };
        }
        replace(parent, prop, index, node) {
          if (parent) {
            if (index !== null) {
              parent[prop][index] = node;
            } else {
              parent[prop] = node;
            }
          }
        }
        remove(parent, prop, index) {
          if (parent) {
            if (index !== null) {
              parent[prop].splice(index, 1);
            } else {
              delete parent[prop];
            }
          }
        }
      }
      class SyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      class AsyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        async visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              await this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!await this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                await this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              await this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      function walk2(ast, { enter, leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
      }
      async function asyncWalk(ast, { enter, leave }) {
        const instance = new AsyncWalker(enter, leave);
        return await instance.visit(ast, null);
      }
      exports3.asyncWalk = asyncWalk;
      exports3.walk = walk2;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-core-npm-3.2.4-c45a69b873-a78e318f17.zip/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js
var require_compiler_core_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-core-npm-3.2.4-c45a69b873-a78e318f17.zip/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var shared = require_shared();
    var sourceMap = require_source_map();
    var parser = require_lib();
    var estreeWalker = require_estree_walker();
    function defaultOnError(error) {
      throw error;
    }
    function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
    }
    function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
    }
    var errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null cahracter.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [26]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [27]: `v-if/v-else-if is missing expression.`,
      [28]: `v-if/else branches must use unique keys.`,
      [29]: `v-else/v-else-if has no adjacent v-if.`,
      [30]: `v-for is missing expression.`,
      [31]: `v-for has invalid expression.`,
      [32]: `<template v-for> key should be placed on the <template> tag.`,
      [33]: `v-bind is missing expression.`,
      [34]: `v-on is missing expression.`,
      [35]: `Unexpected custom directive on <slot> outlet.`,
      [36]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [37]: `Duplicate slot names found. `,
      [38]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [39]: `v-slot can only be used on components or <template> tags.`,
      [40]: `v-model is missing expression.`,
      [41]: `v-model value must be a valid JavaScript member expression.`,
      [42]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [43]: `Error parsing JavaScript expression: `,
      [44]: `<KeepAlive> expects exactly one child component.`,
      [45]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [46]: `ES module mode is not supported in this build of compiler.`,
      [47]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [48]: `"scopeId" option is only supported in module mode.`,
      [49]: ``
    };
    var FRAGMENT = Symbol(`Fragment`);
    var TELEPORT = Symbol(`Teleport`);
    var SUSPENSE = Symbol(`Suspense`);
    var KEEP_ALIVE = Symbol(`KeepAlive`);
    var BASE_TRANSITION = Symbol(`BaseTransition`);
    var OPEN_BLOCK = Symbol(`openBlock`);
    var CREATE_BLOCK = Symbol(`createBlock`);
    var CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
    var CREATE_VNODE = Symbol(`createVNode`);
    var CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
    var CREATE_COMMENT = Symbol(`createCommentVNode`);
    var CREATE_TEXT = Symbol(`createTextVNode`);
    var CREATE_STATIC = Symbol(`createStaticVNode`);
    var RESOLVE_COMPONENT = Symbol(`resolveComponent`);
    var RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
    var RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
    var RESOLVE_FILTER = Symbol(`resolveFilter`);
    var WITH_DIRECTIVES = Symbol(`withDirectives`);
    var RENDER_LIST = Symbol(`renderList`);
    var RENDER_SLOT = Symbol(`renderSlot`);
    var CREATE_SLOTS = Symbol(`createSlots`);
    var TO_DISPLAY_STRING = Symbol(`toDisplayString`);
    var MERGE_PROPS = Symbol(`mergeProps`);
    var NORMALIZE_CLASS = Symbol(`normalizeClass`);
    var NORMALIZE_STYLE = Symbol(`normalizeStyle`);
    var NORMALIZE_PROPS = Symbol(`normalizeProps`);
    var GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
    var TO_HANDLERS = Symbol(`toHandlers`);
    var CAMELIZE = Symbol(`camelize`);
    var CAPITALIZE = Symbol(`capitalize`);
    var TO_HANDLER_KEY = Symbol(`toHandlerKey`);
    var SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
    var PUSH_SCOPE_ID = Symbol(`pushScopeId`);
    var POP_SCOPE_ID = Symbol(`popScopeId`);
    var WITH_SCOPE_ID = Symbol(`withScopeId`);
    var WITH_CTX = Symbol(`withCtx`);
    var UNREF = Symbol(`unref`);
    var IS_REF = Symbol(`isRef`);
    var WITH_MEMO = Symbol(`withMemo`);
    var IS_MEMO_SAME = Symbol(`isMemoSame`);
    var helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_SCOPE_ID]: `withScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach((s) => {
        helperNameMap[s] = helpers[s];
      });
    }
    var locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    function createRoot(children, loc = locStub) {
      return {
        type: 0,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc
      };
    }
    function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
      if (context) {
        if (isBlock) {
          context.helper(OPEN_BLOCK);
          context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
        } else {
          context.helper(getVNodeHelper(context.inSSR, isComponent2));
        }
        if (directives) {
          context.helper(WITH_DIRECTIVES);
        }
      }
      return {
        type: 13,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2,
        loc
      };
    }
    function createArrayExpression(elements, loc = locStub) {
      return {
        type: 17,
        loc,
        elements
      };
    }
    function createObjectExpression(properties, loc = locStub) {
      return {
        type: 15,
        loc,
        properties
      };
    }
    function createObjectProperty(key, value) {
      return {
        type: 16,
        loc: locStub,
        key: shared.isString(key) ? createSimpleExpression(key, true) : key,
        value
      };
    }
    function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
      return {
        type: 4,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 : constType
      };
    }
    function createInterpolation(content, loc) {
      return {
        type: 5,
        loc,
        content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
      };
    }
    function createCompoundExpression(children, loc = locStub) {
      return {
        type: 8,
        loc,
        children
      };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
      return {
        type: 14,
        loc,
        callee,
        arguments: args
      };
    }
    function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
      return {
        type: 18,
        params,
        returns,
        newline,
        isSlot,
        loc
      };
    }
    function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
        type: 19,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
      };
    }
    function createCacheExpression(index, value, isVNode = false) {
      return {
        type: 20,
        index,
        value,
        isVNode,
        loc: locStub
      };
    }
    function createBlockStatement(body) {
      return {
        type: 21,
        body,
        loc: locStub
      };
    }
    function createTemplateLiteral(elements) {
      return {
        type: 22,
        elements,
        loc: locStub
      };
    }
    function createIfStatement(test, consequent, alternate) {
      return {
        type: 23,
        test,
        consequent,
        alternate,
        loc: locStub
      };
    }
    function createAssignmentExpression(left, right) {
      return {
        type: 24,
        left,
        right,
        loc: locStub
      };
    }
    function createSequenceExpression(expressions) {
      return {
        type: 25,
        expressions,
        loc: locStub
      };
    }
    function createReturnStatement(returns) {
      return {
        type: 26,
        returns,
        loc: locStub
      };
    }
    var isStaticExp = (p) => p.type === 4 && p.isStatic;
    var isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);
    function isCoreComponent(tag) {
      if (isBuiltInType(tag, "Teleport")) {
        return TELEPORT;
      } else if (isBuiltInType(tag, "Suspense")) {
        return SUSPENSE;
      } else if (isBuiltInType(tag, "KeepAlive")) {
        return KEEP_ALIVE;
      } else if (isBuiltInType(tag, "BaseTransition")) {
        return BASE_TRANSITION;
      }
    }
    var nonIdentifierRE = /^\d|[^\$\w]/;
    var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    var isMemberExpression = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    function getInnerRange(loc, offset, length) {
      const source = loc.source.substr(offset, length);
      const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
      };
      if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
    }
    function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(shared.extend({}, pos), source, numberOfCharacters);
    }
    function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10) {
          linesCount++;
          lastNewLinePos = i;
        }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
      return pos;
    }
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
      }
    }
    function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {
          return p;
        }
      }
    }
    function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (dynamicOnly)
            continue;
          if (p.name === name && (p.value || allowEmpty)) {
            return p;
          }
        } else if (p.name === "bind" && (p.exp || allowEmpty) && isBindKey(p.arg, name)) {
          return p;
        }
      }
    }
    function isBindKey(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
    }
    function hasDynamicKeyVBind(node) {
      return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
    }
    function isText(node) {
      return node.type === 5 || node.type === 2;
    }
    function isVSlot(p) {
      return p.type === 7 && p.name === "slot";
    }
    function isTemplateNode(node) {
      return node.type === 1 && node.tagType === 3;
    }
    function isSlotOutlet(node) {
      return node.type === 1 && node.tagType === 2;
    }
    function getVNodeHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
    }
    function getVNodeBlockHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
    }
    var propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    function getUnnormalizedProps(props, callPath = []) {
      if (props && !shared.isString(props) && props.type === 14) {
        const callee = props.callee;
        if (!shared.isString(callee) && propsHelperSet.has(callee)) {
          return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
      }
      return [props, callPath];
    }
    function injectProp(node, prop, context) {
      let propsWithInjection;
      const originalProps = node.type === 13 ? node.props : node.arguments[2];
      let props = originalProps;
      let callPath = [];
      let parentCall;
      if (props && !shared.isString(props) && props.type === 14) {
        const ret2 = getUnnormalizedProps(props);
        props = ret2[0];
        callPath = ret2[1];
        parentCall = callPath[callPath.length - 1];
      }
      if (props == null || shared.isString(props)) {
        propsWithInjection = createObjectExpression([prop]);
      } else if (props.type === 14) {
        const first = props.arguments[0];
        if (!shared.isString(first) && first.type === 15) {
          first.properties.unshift(prop);
        } else {
          if (props.callee === TO_HANDLERS) {
            propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
            ]);
          } else {
            props.arguments.unshift(createObjectExpression([prop]));
          }
        }
        !propsWithInjection && (propsWithInjection = props);
      } else if (props.type === 15) {
        let alreadyExists = false;
        if (prop.key.type === 4) {
          const propKeyName = prop.key.content;
          alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
        }
        if (!alreadyExists) {
          props.properties.unshift(prop);
        }
        propsWithInjection = props;
      } else {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
          parentCall = callPath[callPath.length - 2];
        }
      }
      if (node.type === 13) {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.props = propsWithInjection;
        }
      } else {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.arguments[2] = propsWithInjection;
        }
      }
    }
    function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, "_")}`;
    }
    function hasScopeRef(node, ids) {
      if (!node || Object.keys(ids).length === 0) {
        return false;
      }
      switch (node.type) {
        case 1:
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
              return true;
            }
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 11:
          if (hasScopeRef(node.source, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 9:
          return node.branches.some((b) => hasScopeRef(b, ids));
        case 10:
          if (hasScopeRef(node.condition, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 4:
          return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
        case 8:
          return node.children.some((c) => shared.isObject(c) && hasScopeRef(c, ids));
        case 5:
        case 12:
          return hasScopeRef(node.content, ids);
        case 2:
        case 3:
          return false;
        default:
          return false;
      }
    }
    function getMemoedVNodeCall(node) {
      if (node.type === 14 && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
      } else {
        return node;
      }
    }
    function makeBlock(node, { helper, removeHelper, inSSR }) {
      if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
      }
    }
    var deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3.vuejs.org/guide/migration/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
      },
      ["COMPILER_V_FOR_REF"]: {
        message: `Ref usage on v-for no longer creates array ref values in Vue 3. Consider using function refs or refactor to avoid ref usage altogether.`,
        link: `https://v3.vuejs.org/guide/migration/array-refs.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3.vuejs.org/guide/migration/filters.html`
      }
    };
    function getCompatValue(key, context) {
      const config = context.options ? context.options.compatConfig : context.compatConfig;
      const value = config && config[key];
      if (key === "MODE") {
        return value || 3;
      } else {
        return value;
      }
    }
    function isCompatEnabled(key, context) {
      const mode = getCompatValue("MODE", context);
      const value = getCompatValue(key, context);
      return mode === 3 ? value === true : value !== false;
    }
    function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      if (enabled) {
        warnDeprecation(key, context, loc, ...args);
      }
      return enabled;
    }
    function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === "suppress-warning") {
        return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
        err.loc = loc;
      context.onWarn(err);
    }
    var decodeRE = /&(gt|lt|amp|apos|quot);/g;
    var decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    var defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: shared.NO,
      isPreTag: shared.NO,
      isCustomElement: shared.NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0, []), getSelection(context, start));
    }
    function createParserContext(content, rawOptions) {
      const options = shared.extend({}, defaultParserOptions);
      let key;
      for (key in rawOptions) {
        options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
      }
      return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
      };
    }
    function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = void 0;
        if (mode === 0 || mode === 1) {
          if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
            node = parseInterpolation(context, mode);
          } else if (mode === 0 && s[0] === "<") {
            if (s.length === 1) {
              emitError(context, 5, 1);
            } else if (s[1] === "!") {
              if (startsWith(s, "<!--")) {
                node = parseComment(context);
              } else if (startsWith(s, "<!DOCTYPE")) {
                node = parseBogusComment(context);
              } else if (startsWith(s, "<![CDATA[")) {
                if (ns !== 0) {
                  node = parseCDATA(context, ancestors);
                } else {
                  emitError(context, 1);
                  node = parseBogusComment(context);
                }
              } else {
                emitError(context, 11);
                node = parseBogusComment(context);
              }
            } else if (s[1] === "/") {
              if (s.length === 2) {
                emitError(context, 5, 2);
              } else if (s[2] === ">") {
                emitError(context, 14, 2);
                advanceBy(context, 3);
                continue;
              } else if (/[a-z]/i.test(s[2])) {
                emitError(context, 23);
                parseTag(context, 1, parent);
                continue;
              } else {
                emitError(context, 12, 2);
                node = parseBogusComment(context);
              }
            } else if (/[a-z]/i.test(s[1])) {
              node = parseElement(context, ancestors);
              if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
                warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
                node = node.children;
              }
            } else if (s[1] === "?") {
              emitError(context, 21, 1);
              node = parseBogusComment(context);
            } else {
              emitError(context, 12, 1);
            }
          }
        }
        if (!node) {
          node = parseText(context, mode);
        }
        if (shared.isArray(node)) {
          for (let i = 0; i < node.length; i++) {
            pushNode(nodes, node[i]);
          }
        } else {
          pushNode(nodes, node);
        }
      }
      let removedWhitespace = false;
      if (mode !== 2 && mode !== 1) {
        const shouldCondense = context.options.whitespace !== "preserve";
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!context.inPre && node.type === 2) {
            if (!/[^\t\r\n\f ]/.test(node.content)) {
              const prev = nodes[i - 1];
              const next = nodes[i + 1];
              if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
                removedWhitespace = true;
                nodes[i] = null;
              } else {
                node.content = " ";
              }
            } else if (shouldCondense) {
              node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
            }
          } else if (node.type === 3 && !context.options.comments) {
            removedWhitespace = true;
            nodes[i] = null;
          }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
          const first = nodes[0];
          if (first && first.type === 2) {
            first.content = first.content.replace(/^\r?\n/, "");
          }
        }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function pushNode(nodes, node) {
      if (node.type === 2) {
        const prev = last(nodes);
        if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
          prev.content += node.content;
          prev.loc.end = node.loc.end;
          prev.loc.source += node.loc.source;
          return;
        }
      }
      nodes.push(node);
    }
    function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3, ancestors);
      if (context.source.length === 0) {
        emitError(context, 6);
      } else {
        advanceBy(context, 3);
      }
      return nodes;
    }
    function parseComment(context) {
      const start = getCursor(context);
      let content;
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7);
      } else {
        if (match.index <= 3) {
          emitError(context, 0);
        }
        if (match[1]) {
          emitError(context, 10);
        }
        content = context.source.slice(4, match.index);
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
          advanceBy(context, nestedIndex - prevIndex + 1);
          if (nestedIndex + 4 < s.length) {
            emitError(context, 16);
          }
          prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
        type: 3,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === "?" ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf(">");
      if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
      } else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
      }
      return {
        type: 3,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseElement(context, ancestors) {
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        if (isPreBoundary) {
          context.inPre = false;
        }
        if (isVPreBoundary) {
          context.inVPre = false;
        }
        return element;
      }
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      {
        const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
        if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
          const loc = getSelection(context, element.loc.end);
          inlineTemplateProp.value = {
            type: 2,
            content: loc.source,
            loc
          };
        }
      }
      element.children = children;
      if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1, parent);
      } else {
        emitError(context, 24, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
          const first = children[0];
          if (first && startsWith(first.loc.source, "<!--")) {
            emitError(context, 8);
          }
        }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
        context.inPre = false;
      }
      if (isVPreBoundary) {
        context.inVPre = false;
      }
      return element;
    }
    var isSpecialTemplateDirective = /* @__PURE__ */ shared.makeMap(`if,else,else-if,for,slot`);
    function parseTag(context, type, parent) {
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      const cursor = getCursor(context);
      const currentSource = context.source;
      if (context.options.isPreTag(tag)) {
        context.inPre = true;
      }
      let props = parseAttributes(context, type);
      if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
        context.inVPre = true;
        shared.extend(context, cursor);
        context.source = currentSource;
        props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
      }
      let isSelfClosing = false;
      if (context.source.length === 0) {
        emitError(context, 9);
      } else {
        isSelfClosing = startsWith(context.source, "/>");
        if (type === 1 && isSelfClosing) {
          emitError(context, 4);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
      }
      if (type === 1) {
        return;
      }
      if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 7) {
            if (p.name === "if") {
              hasIf = true;
            } else if (p.name === "for") {
              hasFor = true;
            }
          }
          if (hasIf && hasFor) {
            warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
          }
        }
      }
      let tagType = 0;
      if (!context.inVPre) {
        if (tag === "slot") {
          tagType = 2;
        } else if (tag === "template") {
          if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            tagType = 3;
          }
        } else if (isComponent(tag, props, context)) {
          tagType = 1;
        }
      }
      return {
        type: 1,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: void 0
      };
    }
    function isComponent(tag, props, context) {
      const options = context.options;
      if (options.isCustomElement(tag)) {
        return false;
      }
      if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
        return true;
      }
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6) {
          if (p.name === "is" && p.value) {
            if (p.value.content.startsWith("vue:")) {
              return true;
            } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
              return true;
            }
          }
        } else {
          if (p.name === "is") {
            return true;
          } else if (p.name === "bind" && isBindKey(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
            return true;
          }
        }
      }
    }
    function parseAttributes(context, type) {
      const props = [];
      const attributeNames = new Set();
      while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
        if (startsWith(context.source, "/")) {
          emitError(context, 22);
          advanceBy(context, 1);
          advanceSpaces(context);
          continue;
        }
        if (type === 1) {
          emitError(context, 3);
        }
        const attr = parseAttribute(context, attributeNames);
        if (type === 0) {
          props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
          emitError(context, 15);
        }
        advanceSpaces(context);
      }
      return props;
    }
    function parseAttribute(context, nameSet) {
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
        emitError(context, 2);
      }
      nameSet.add(name);
      if (name[0] === "=") {
        emitError(context, 19);
      }
      {
        const pattern = /["'<]/g;
        let m;
        while (m = pattern.exec(name)) {
          emitError(context, 17, m.index);
        }
      }
      advanceBy(context, name.length);
      let value = void 0;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
          emitError(context, 13);
        }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-|:|\.|@|#)/.test(name)) {
        const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, ".");
        let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
        let arg;
        if (match2[2]) {
          const isSlot = dirName === "slot";
          const startOffset = name.lastIndexOf(match2[2]);
          const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
          let content = match2[2];
          let isStatic = true;
          if (content.startsWith("[")) {
            isStatic = false;
            if (!content.endsWith("]")) {
              emitError(context, 26);
            }
            content = content.substr(1, content.length - 2);
          } else if (isSlot) {
            content += match2[3] || "";
          }
          arg = {
            type: 4,
            content,
            isStatic,
            constType: isStatic ? 3 : 0,
            loc: loc2
          };
        }
        if (value && value.isQuoted) {
          const valueLoc = value.loc;
          valueLoc.start.offset++;
          valueLoc.start.column++;
          valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
          valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match2[3] ? match2[3].substr(1).split(".") : [];
        if (isPropShorthand)
          modifiers.push("prop");
        if (dirName === "bind" && arg) {
          if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
            dirName = "model";
            modifiers.splice(modifiers.indexOf("sync"), 1);
          }
          if (modifiers.includes("prop")) {
            checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
          }
        }
        return {
          type: 7,
          name: dirName,
          exp: value && {
            type: 4,
            content: value.content,
            isStatic: false,
            constType: 0,
            loc: value.loc
          },
          arg,
          modifiers,
          loc
        };
      }
      return {
        type: 6,
        name,
        value: value && {
          type: 2,
          content: value.content,
          loc: value.loc
        },
        loc
      };
    }
    function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
          content = parseTextData(context, context.source.length, 4);
        } else {
          content = parseTextData(context, endIndex, 4);
          advanceBy(context, 1);
        }
      } else {
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
          return void 0;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while (m = unexpectedChars.exec(match[0])) {
          emitError(context, 18, m.index);
        }
        content = parseTextData(context, match[0].length, 4);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
    }
    function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
        emitError(context, 25);
        return void 0;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
        type: 5,
        content: {
          type: 4,
          isStatic: false,
          constType: 0,
          content,
          loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
      };
    }
    function parseText(context, mode) {
      const endTokens = ["<", context.options.delimiters[0]];
      if (mode === 3) {
        endTokens.push("]]>");
      }
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
          endIndex = index;
        }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
        type: 2,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 || mode === 3 || rawText.indexOf("&") === -1) {
        return rawText;
      } else {
        return context.options.decodeEntities(rawText, mode === 4);
      }
    }
    function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
    }
    function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
      };
    }
    function last(xs) {
      return xs[xs.length - 1];
    }
    function startsWith(source, searchString) {
      return source.startsWith(searchString);
    }
    function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
    }
    function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
        advanceBy(context, match[0].length);
      }
    }
    function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
    }
    function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
        loc.offset += offset;
        loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ""
      }));
    }
    function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
        case 0:
          if (startsWith(s, "</")) {
            for (let i = ancestors.length - 1; i >= 0; --i) {
              if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                return true;
              }
            }
          }
          break;
        case 1:
        case 2: {
          const parent = last(ancestors);
          if (parent && startsWithEndTagOpen(s, parent.tag)) {
            return true;
          }
          break;
        }
        case 3:
          if (startsWith(s, "]]>")) {
            return true;
          }
          break;
      }
      return !s;
    }
    function startsWithEndTagOpen(source, tag) {
      return startsWith(source, "</") && source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
    }
    function hoistStatic(root, context) {
      walk2(root, context, isSingleElementRoot(root, root.children[0]));
    }
    function isSingleElementRoot(root, child) {
      const { children } = root;
      return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
    }
    function walk2(node, context, doNotHoistNode = false) {
      let canStringify = true;
      const { children } = node;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.type === 1 && child.tagType === 0) {
          const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
          if (constantType > 0) {
            if (constantType < 3) {
              canStringify = false;
            }
            if (constantType >= 2) {
              child.codegenNode.patchFlag = -1 + ` /* HOISTED */`;
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
              continue;
            }
          } else {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              const flag = getPatchFlag(codegenNode);
              if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                const props = getNodeProps(child);
                if (props) {
                  codegenNode.props = context.hoist(props);
                }
              }
              if (codegenNode.dynamicProps) {
                codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
              }
            }
          }
        } else if (child.type === 12) {
          const contentType = getConstantType(child.content, context);
          if (contentType > 0) {
            if (contentType < 3) {
              canStringify = false;
            }
            if (contentType >= 2) {
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
            }
          }
        }
        if (child.type === 1) {
          const isComponent2 = child.tagType === 1;
          if (isComponent2) {
            context.scopes.vSlot++;
          }
          walk2(child, context);
          if (isComponent2) {
            context.scopes.vSlot--;
          }
        } else if (child.type === 11) {
          walk2(child, context, child.children.length === 1);
        } else if (child.type === 9) {
          for (let i2 = 0; i2 < child.branches.length; i2++) {
            walk2(child.branches[i2], context, child.branches[i2].children.length === 1);
          }
        }
      }
      if (canStringify && hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
      }
      if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
      }
    }
    function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
        case 1:
          if (node.tagType !== 0) {
            return 0;
          }
          const cached = constantCache.get(node);
          if (cached !== void 0) {
            return cached;
          }
          const codegenNode = node.codegenNode;
          if (codegenNode.type !== 13) {
            return 0;
          }
          const flag = getPatchFlag(codegenNode);
          if (!flag) {
            let returnType2 = 3;
            const generatedPropsType = getGeneratedPropsConstantType(node, context);
            if (generatedPropsType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (generatedPropsType < returnType2) {
              returnType2 = generatedPropsType;
            }
            for (let i = 0; i < node.children.length; i++) {
              const childType = getConstantType(node.children[i], context);
              if (childType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (childType < returnType2) {
                returnType2 = childType;
              }
            }
            if (returnType2 > 1) {
              for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 && p.name === "bind" && p.exp) {
                  const expType = getConstantType(p.exp, context);
                  if (expType === 0) {
                    constantCache.set(node, 0);
                    return 0;
                  }
                  if (expType < returnType2) {
                    returnType2 = expType;
                  }
                }
              }
            }
            if (codegenNode.isBlock) {
              context.removeHelper(OPEN_BLOCK);
              context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
              codegenNode.isBlock = false;
              context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
            }
            constantCache.set(node, returnType2);
            return returnType2;
          } else {
            constantCache.set(node, 0);
            return 0;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return getConstantType(node.content, context);
        case 4:
          return node.constType;
        case 8:
          let returnType = 3;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (shared.isString(child) || shared.isSymbol(child)) {
              continue;
            }
            const childType = getConstantType(child, context);
            if (childType === 0) {
              return 0;
            } else if (childType < returnType) {
              returnType = childType;
            }
          }
          return returnType;
        default:
          return 0;
      }
    }
    var allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    function getConstantTypeOfHelperCall(value, context) {
      if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4) {
          return getConstantType(arg, context);
        } else if (arg.type === 14) {
          return getConstantTypeOfHelperCall(arg, context);
        }
      }
      return 0;
    }
    function getGeneratedPropsConstantType(node, context) {
      let returnType = 3;
      const props = getNodeProps(node);
      if (props && props.type === 15) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          const keyType = getConstantType(key, context);
          if (keyType === 0) {
            return keyType;
          }
          if (keyType < returnType) {
            returnType = keyType;
          }
          let valueType;
          if (value.type === 4) {
            valueType = getConstantType(value, context);
          } else if (value.type === 14) {
            valueType = getConstantTypeOfHelperCall(value, context);
          } else {
            valueType = 0;
          }
          if (valueType === 0) {
            return valueType;
          }
          if (valueType < returnType) {
            returnType = valueType;
          }
        }
      }
      return returnType;
    }
    function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13) {
        return codegenNode.props;
      }
    }
    function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : void 0;
    }
    function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared.NOOP, isCustomElement = shared.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = shared.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
      const context = {
        selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic: hoistStatic2,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
          vFor: 0,
          vSlot: 0,
          vPre: 0,
          vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        helper(name) {
          const count = context.helpers.get(name) || 0;
          context.helpers.set(name, count + 1);
          return name;
        },
        removeHelper(name) {
          const count = context.helpers.get(name);
          if (count) {
            const currentCount = count - 1;
            if (!currentCount) {
              context.helpers.delete(name);
            } else {
              context.helpers.set(name, currentCount);
            }
          }
        },
        helperString(name) {
          return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
          {
            if (!context.currentNode) {
              throw new Error(`Node being replaced is already removed.`);
            }
            if (!context.parent) {
              throw new Error(`Cannot replace root node.`);
            }
          }
          context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
          if (!context.parent) {
            throw new Error(`Cannot remove root node.`);
          }
          const list = context.parent.children;
          const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
          if (removalIndex < 0) {
            throw new Error(`node being removed is not a child of current parent`);
          }
          if (!node || node === context.currentNode) {
            context.currentNode = null;
            context.onNodeRemoved();
          } else {
            if (context.childIndex > removalIndex) {
              context.childIndex--;
              context.onNodeRemoved();
            }
          }
          context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => {
        },
        addIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              addId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(addId);
            } else if (exp.type === 4) {
              addId(exp.content);
            }
          }
        },
        removeIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              removeId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(removeId);
            } else if (exp.type === 4) {
              removeId(exp.content);
            }
          }
        },
        hoist(exp) {
          if (shared.isString(exp))
            exp = createSimpleExpression(exp);
          context.hoists.push(exp);
          const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
          identifier.hoisted = exp;
          return identifier;
        },
        cache(exp, isVNode = false) {
          return createCacheExpression(context.cached++, exp, isVNode);
        }
      };
      {
        context.filters = new Set();
      }
      function addId(id) {
        const { identifiers } = context;
        if (identifiers[id] === void 0) {
          identifiers[id] = 0;
        }
        identifiers[id]++;
      }
      function removeId(id) {
        context.identifiers[id]--;
      }
      return context;
    }
    function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
        hoistStatic(root, context);
      }
      if (!options.ssr) {
        createRootCodegen(root, context);
      }
      root.helpers = [...context.helpers.keys()];
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
      {
        root.filters = [...context.filters];
      }
    }
    function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
        const child = children[0];
        if (isSingleElementRoot(root, child) && child.codegenNode) {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            makeBlock(codegenNode, context);
          }
          root.codegenNode = codegenNode;
        } else {
          root.codegenNode = child;
        }
      } else if (children.length > 1) {
        let patchFlag = 64;
        let patchFlagText = shared.PatchFlagNames[64];
        if (children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + ` /* ${patchFlagText} */`, void 0, void 0, true, void 0, false);
      } else
        ;
    }
    function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
        i--;
      };
      for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if (shared.isString(child))
          continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
      }
    }
    function traverseNode(node, context) {
      context.currentNode = node;
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
        const onExit = nodeTransforms[i2](node, context);
        if (onExit) {
          if (shared.isArray(onExit)) {
            exitFns.push(...onExit);
          } else {
            exitFns.push(onExit);
          }
        }
        if (!context.currentNode) {
          return;
        } else {
          node = context.currentNode;
        }
      }
      switch (node.type) {
        case 3:
          if (!context.ssr) {
            context.helper(CREATE_COMMENT);
          }
          break;
        case 5:
          if (!context.ssr) {
            context.helper(TO_DISPLAY_STRING);
          }
          break;
        case 9:
          for (let i2 = 0; i2 < node.branches.length; i2++) {
            traverseNode(node.branches[i2], context);
          }
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          traverseChildren(node, context);
          break;
      }
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
        exitFns[i]();
      }
    }
    function createStructuralDirectiveTransform(name, fn) {
      const matches = shared.isString(name) ? (n) => n === name : (n) => name.test(n);
      return (node, context) => {
        if (node.type === 1) {
          const { props } = node;
          if (node.tagType === 3 && props.some(isVSlot)) {
            return;
          }
          const exitFns = [];
          for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            if (prop.type === 7 && matches(prop.name)) {
              props.splice(i, 1);
              i--;
              const onExit = fn(node, prop, context);
              if (onExit)
                exitFns.push(onExit);
            }
          }
          return exitFns;
        }
      };
    }
    var PURE_ANNOTATION = `/*#__PURE__*/`;
    function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap: sourceMap$1 = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false, isTS = false, inSSR = false }) {
      const context = {
        mode,
        prefixIdentifiers,
        sourceMap: sourceMap$1,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: void 0,
        helper(key) {
          return `_${helperNameMap[key]}`;
        },
        push(code, node) {
          context.code += code;
          if (context.map) {
            if (node) {
              let name;
              if (node.type === 4 && !node.isStatic) {
                const content = node.content.replace(/^_ctx\./, "");
                if (content !== node.content && isSimpleIdentifier(content)) {
                  name = content;
                }
              }
              addMapping(node.loc.start, name);
            }
            advancePositionWithMutation(context, code);
            if (node && node.loc !== locStub) {
              addMapping(node.loc.end);
            }
          }
        },
        indent() {
          newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
          if (withoutNewLine) {
            --context.indentLevel;
          } else {
            newline(--context.indentLevel);
          }
        },
        newline() {
          newline(context.indentLevel);
        }
      };
      function newline(n) {
        context.push("\n" + `  `.repeat(n));
      }
      function addMapping(loc, name) {
        context.map.addMapping({
          name,
          source: context.filename,
          original: {
            line: loc.line,
            column: loc.column - 1
          },
          generated: {
            line: context.line,
            column: context.column - 1
          }
        });
      }
      if (sourceMap$1) {
        context.map = new sourceMap.SourceMapGenerator();
        context.map.setSourceContent(filename, context.source);
      }
      return context;
    }
    function generate2(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
        options.onContextCreated(context);
      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== "module";
      const genScopeId = scopeId != null && mode === "module";
      const isSetupInlined = !!options.inline;
      const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
      if (mode === "module") {
        genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
      } else {
        genFunctionPreamble(ast, preambleContext);
      }
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      if (options.bindingMetadata && !options.inline) {
        args.push("$props", "$setup", "$data", "$options");
      }
      const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
      if (isSetupInlined) {
        push(`(${signature}) => {`);
      } else {
        push(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        if (hasHelpers) {
          push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
          push(`
`);
          newline();
        }
      }
      if (ast.components.length) {
        genAssets(ast.components, "component", context);
        if (ast.directives.length || ast.temps > 0) {
          newline();
        }
      }
      if (ast.directives.length) {
        genAssets(ast.directives, "directive", context);
        if (ast.temps > 0) {
          newline();
        }
      }
      if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, "filter", context);
        newline();
      }
      if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
          push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
        push(`
`);
        newline();
      }
      if (!ssr) {
        push(`return `);
      }
      if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
      } else {
        push(`null`);
      }
      if (useWithBlock) {
        deindent();
        push(`}`);
      }
      deindent();
      push(`}`);
      return {
        ast,
        code: context.code,
        preamble: isSetupInlined ? preambleContext.code : ``,
        map: context.map ? context.map.toJSON() : void 0
      };
    }
    function genFunctionPreamble(ast, context) {
      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;
      const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
      const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
      if (ast.helpers.length > 0) {
        if (prefixIdentifiers) {
          push(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`);
        } else {
          push(`const _Vue = ${VueBinding}
`);
          if (ast.hoists.length) {
            const staticHelpers = [
              CREATE_VNODE,
              CREATE_ELEMENT_VNODE,
              CREATE_COMMENT,
              CREATE_TEXT,
              CREATE_STATIC
            ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
            push(`const { ${staticHelpers} } = _Vue
`);
          }
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("@vue/server-renderer")
`);
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
    }
    function genModulePreamble(ast, context, genScopeId, inline) {
      const { push, newline, optimizeImports, runtimeModuleName } = context;
      if (genScopeId) {
        ast.helpers.push(WITH_SCOPE_ID);
        if (ast.hoists.length) {
          ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID);
        }
      }
      if (ast.helpers.length) {
        if (optimizeImports) {
          push(`import { ${ast.helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
          push(`
// Binding optimization for webpack code-split
const ${ast.helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`);
        } else {
          push(`import { ${ast.helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(`import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "@vue/server-renderer"
`);
      }
      if (ast.imports.length) {
        genImports(ast.imports, context);
        newline();
      }
      genHoists(ast.hoists, context);
      newline();
      if (!inline) {
        push(`export `);
      }
    }
    function genAssets(assets, type, { helper, push, newline, isTS }) {
      const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
      for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        const maybeSelfReference = id.endsWith("__self");
        if (maybeSelfReference) {
          id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
          newline();
        }
      }
    }
    function genHoists(hoists, context) {
      if (!hoists.length) {
        return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      const genScopeId = scopeId != null && mode !== "function";
      newline();
      if (genScopeId) {
        push(`${helper(PUSH_SCOPE_ID)}("${scopeId}")`);
        newline();
      }
      hoists.forEach((exp, i) => {
        if (exp) {
          push(`const _hoisted_${i + 1} = `);
          genNode(exp, context);
          newline();
        }
      });
      if (genScopeId) {
        push(`${helper(POP_SCOPE_ID)}()`);
        newline();
      }
      context.pure = false;
    }
    function genImports(importsOptions, context) {
      if (!importsOptions.length) {
        return;
      }
      importsOptions.forEach((imports) => {
        context.push(`import `);
        genNode(imports.exp, context);
        context.push(` from '${imports.path}'`);
        context.newline();
      });
    }
    function isText$1(n) {
      return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
    }
    function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 || nodes.some((n) => shared.isArray(n) || !isText$1(n));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
    }
    function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (shared.isString(node)) {
          push(node);
        } else if (shared.isArray(node)) {
          genNodeListAsArray(node, context);
        } else {
          genNode(node, context);
        }
        if (i < nodes.length - 1) {
          if (multilines) {
            comma && push(",");
            newline();
          } else {
            comma && push(", ");
          }
        }
      }
    }
    function genNode(node, context) {
      if (shared.isString(node)) {
        context.push(node);
        return;
      }
      if (shared.isSymbol(node)) {
        context.push(context.helper(node));
        return;
      }
      switch (node.type) {
        case 1:
        case 9:
        case 11:
          assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
          genNode(node.codegenNode, context);
          break;
        case 2:
          genText(node, context);
          break;
        case 4:
          genExpression(node, context);
          break;
        case 5:
          genInterpolation(node, context);
          break;
        case 12:
          genNode(node.codegenNode, context);
          break;
        case 8:
          genCompoundExpression(node, context);
          break;
        case 3:
          genComment(node, context);
          break;
        case 13:
          genVNodeCall(node, context);
          break;
        case 14:
          genCallExpression(node, context);
          break;
        case 15:
          genObjectExpression(node, context);
          break;
        case 17:
          genArrayExpression(node, context);
          break;
        case 18:
          genFunctionExpression(node, context);
          break;
        case 19:
          genConditionalExpression(node, context);
          break;
        case 20:
          genCacheExpression(node, context);
          break;
        case 21:
          genNodeList(node.body, context, true, false);
          break;
        case 22:
          genTemplateLiteral(node, context);
          break;
        case 23:
          genIfStatement(node, context);
          break;
        case 24:
          genAssignmentExpression(node, context);
          break;
        case 25:
          genSequenceExpression(node, context);
          break;
        case 26:
          genReturnStatement(node, context);
          break;
        case 10:
          break;
        default: {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
      }
    }
    function genText(node, context) {
      context.push(JSON.stringify(node.content), node);
    }
    function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(isStatic ? JSON.stringify(content) : content, node);
    }
    function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
        push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
    }
    function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (shared.isString(child)) {
          context.push(child);
        } else {
          genNode(child, context);
        }
      }
    }
    function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
      } else if (node.isStatic) {
        const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
        push(text, node);
      } else {
        push(`[${node.content}]`, node);
      }
    }
    function genComment(node, context) {
      const { push, helper, pure } = context;
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
    }
    function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
      if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
        push(PURE_ANNOTATION);
      }
      const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
      push(helper(callHelper) + `(`, node);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
      push(`)`);
      if (isBlock) {
        push(`)`);
      }
      if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
      }
    }
    function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
        if (args[i] != null)
          break;
      }
      return args.slice(0, i + 1).map((arg) => arg || `null`);
    }
    function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(callee + `(`, node);
      genNodeList(node.arguments, context);
      push(`)`);
    }
    function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
        push(`{}`, node);
        return;
      }
      const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        genNode(value, context);
        if (i < properties.length - 1) {
          push(`,`);
          newline();
        }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
    }
    function genFunctionExpression(node, context) {
      const { push, indent, deindent } = context;
      const { params, returns, body, newline, isSlot } = node;
      if (isSlot) {
        push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, node);
      if (shared.isArray(params)) {
        genNodeList(params, context);
      } else if (params) {
        genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
        push(`{`);
        indent();
      }
      if (returns) {
        if (newline) {
          push(`return `);
        }
        if (shared.isArray(returns)) {
          genNodeListAsArray(returns, context);
        } else {
          genNode(returns, context);
        }
      } else if (body) {
        genNode(body, context);
      }
      if (newline || body) {
        deindent();
        push(`}`);
      }
      if (isSlot) {
        if (node.isNonScopedSlot) {
          push(`, undefined, true`);
        }
        push(`)`);
      }
    }
    function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
      } else {
        push(`(`);
        genNode(test, context);
        push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19;
      if (!isNested) {
        context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
        context.indentLevel--;
      }
      needNewline && deindent(true);
    }
    function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
      }
      push(`)`);
    }
    function genTemplateLiteral(node, context) {
      const { push, indent, deindent } = context;
      push("`");
      const l = node.elements.length;
      const multilines = l > 3;
      for (let i = 0; i < l; i++) {
        const e = node.elements[i];
        if (shared.isString(e)) {
          push(e.replace(/(`|\$|\\)/g, "\\$1"));
        } else {
          push("${");
          if (multilines)
            indent();
          genNode(e, context);
          if (multilines)
            deindent();
          push("}");
        }
      }
      push("`");
    }
    function genIfStatement(node, context) {
      const { push, indent, deindent } = context;
      const { test, consequent, alternate } = node;
      push(`if (`);
      genNode(test, context);
      push(`) {`);
      indent();
      genNode(consequent, context);
      deindent();
      push(`}`);
      if (alternate) {
        push(` else `);
        if (alternate.type === 23) {
          genIfStatement(alternate, context);
        } else {
          push(`{`);
          indent();
          genNode(alternate, context);
          deindent();
          push(`}`);
        }
      }
    }
    function genAssignmentExpression(node, context) {
      genNode(node.left, context);
      context.push(` = `);
      genNode(node.right, context);
    }
    function genSequenceExpression(node, context) {
      context.push(`(`);
      genNodeList(node.expressions, context);
      context.push(`)`);
    }
    function genReturnStatement({ returns }, context) {
      context.push(`return `);
      if (shared.isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    }
    var isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap("true,false,null,this");
    var transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    function processExpression(node, context, asParams = false, asRawStatements = false) {
      if (!context.prefixIdentifiers || !node.content.trim()) {
        return node;
      }
      const { inline, bindingMetadata } = context;
      const rewriteIdentifier = (raw, parent, id) => {
        const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
        if (inline) {
          const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
          const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
          const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
          if (type === "setup-const") {
            return raw;
          } else if (type === "setup-ref") {
            return `${raw}.value`;
          } else if (type === "setup-maybe-ref") {
            return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context.helperString(UNREF)}(${raw})`;
          } else if (type === "setup-let") {
            if (isAssignmentLVal) {
              const { right: rVal, operator } = parent;
              const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
              const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context));
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
            } else if (isUpdateArg) {
              id.start = parent.start;
              id.end = parent.end;
              const { prefix: isPrefix, operator } = parent;
              const prefix = isPrefix ? operator : ``;
              const postfix = isPrefix ? `` : operator;
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
            } else if (isDestructureAssignment) {
              return raw;
            } else {
              return `${context.helperString(UNREF)}(${raw})`;
            }
          } else if (type === "props") {
            return `__props.${raw}`;
          }
        } else {
          if (type && type.startsWith("setup")) {
            return `$setup.${raw}`;
          } else if (type) {
            return `$${type}.${raw}`;
          }
        }
        return `_ctx.${raw}`;
      };
      const rawExp = node.content;
      const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf(".") > 0;
      if (isSimpleIdentifier(rawExp)) {
        const isScopeVarReference = context.identifiers[rawExp];
        const isAllowedGlobal = shared.isGloballyWhitelisted(rawExp);
        const isLiteral = isLiteralWhitelisted(rawExp);
        if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
          if (bindingMetadata[node.content] === "setup-const") {
            node.constType = 1;
          }
          node.content = rewriteIdentifier(rawExp);
        } else if (!isScopeVarReference) {
          if (isLiteral) {
            node.constType = 3;
          } else {
            node.constType = 2;
          }
        }
        return node;
      }
      let ast;
      const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
      try {
        ast = parser.parse(source, {
          plugins: [...context.expressionPlugins, ...shared.babelParserDefaultPlugins]
        }).program;
      } catch (e) {
        context.onError(createCompilerError(43, node.loc, void 0, e.message));
        return node;
      }
      const ids = [];
      const knownIds = Object.create(context.identifiers);
      const isDuplicate = (node2) => ids.some((id) => id.start === node2.start);
      const parentStack = [];
      estreeWalker.walk(ast, {
        enter(node2, parent) {
          parent && parentStack.push(parent);
          if (node2.type === "Identifier") {
            if (!isDuplicate(node2)) {
              if (node2.name.startsWith("_filter_")) {
                return;
              }
              const needPrefix = shouldPrefix(node2, parent, parentStack);
              if (!knownIds[node2.name] && needPrefix) {
                if (isStaticProperty(parent) && parent.shorthand) {
                  node2.prefix = `${node2.name}: `;
                }
                node2.name = rewriteIdentifier(node2.name, parent, node2);
                ids.push(node2);
              } else if (!isStaticPropertyKey(node2, parent)) {
                if (!(needPrefix && knownIds[node2.name]) && !bailConstant) {
                  node2.isConstant = true;
                }
                ids.push(node2);
              }
            }
          } else if (isFunction(node2)) {
            node2.params.forEach((p) => estreeWalker.walk(p, {
              enter(child, parent2) {
                if (child.type === "Identifier" && !isStaticPropertyKey(child, parent2) && !(parent2 && parent2.type === "AssignmentPattern" && parent2.right === child)) {
                  const { name } = child;
                  if (node2.scopeIds && node2.scopeIds.has(name)) {
                    return;
                  }
                  if (name in knownIds) {
                    knownIds[name]++;
                  } else {
                    knownIds[name] = 1;
                  }
                  (node2.scopeIds || (node2.scopeIds = new Set())).add(name);
                }
              }
            }));
          }
        },
        leave(node2, parent) {
          parent && parentStack.pop();
          if (node2 !== ast.body[0].expression && node2.scopeIds) {
            node2.scopeIds.forEach((id) => {
              knownIds[id]--;
              if (knownIds[id] === 0) {
                delete knownIds[id];
              }
            });
          }
        }
      });
      const children = [];
      ids.sort((a, b) => a.start - b.start);
      ids.forEach((id, i) => {
        const start = id.start - 1;
        const end = id.end - 1;
        const last2 = ids[i - 1];
        const leadingText = rawExp.slice(last2 ? last2.end - 1 : 0, start);
        if (leadingText.length || id.prefix) {
          children.push(leadingText + (id.prefix || ``));
        }
        const source2 = rawExp.slice(start, end);
        children.push(createSimpleExpression(id.name, false, {
          source: source2,
          start: advancePositionWithClone(node.loc.start, source2, start),
          end: advancePositionWithClone(node.loc.start, source2, end)
        }, id.isConstant ? 3 : 0));
        if (i === ids.length - 1 && end < rawExp.length) {
          children.push(rawExp.slice(end));
        }
      });
      let ret2;
      if (children.length) {
        ret2 = createCompoundExpression(children, node.loc);
      } else {
        ret2 = node;
        ret2.constType = bailConstant ? 0 : 3;
      }
      ret2.identifiers = Object.keys(knownIds);
      return ret2;
    }
    var isFunction = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    function shouldPrefix(id, parent, parentStack) {
      if ((parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
        return false;
      }
      if (isFunction(parent)) {
        if (parent.id === id) {
          return false;
        }
        if (parent.params.includes(id)) {
          return false;
        }
      }
      if (isStaticPropertyKey(id, parent)) {
        return false;
      }
      if (parent.type === "ArrayPattern" && !isInDestructureAssignment(parent, parentStack)) {
        return false;
      }
      if ((parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && parent.property === id && !parent.computed) {
        return false;
      }
      if (id.name === "arguments") {
        return false;
      }
      if (shared.isGloballyWhitelisted(id.name)) {
        return false;
      }
      if (id.name === "require") {
        return false;
      }
      return true;
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i = parentStack.length;
        while (i--) {
          const p = parentStack[i];
          if (p.type === "AssignmentExpression") {
            return true;
          } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function stringifyExpression(exp) {
      if (shared.isString(exp)) {
        return exp;
      } else if (exp.type === 4) {
        return exp.content;
      } else {
        return exp.children.map(stringifyExpression).join("");
      }
    }
    var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
          }
        };
      });
    });
    function processIf(node, dir, context, processCodegen) {
      if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(27, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (context.prefixIdentifiers && dir.exp) {
        dir.exp = processExpression(dir.exp, context);
      }
      if (dir.name === "if") {
        const branch = createIfBranch(node, dir);
        const ifNode = {
          type: 9,
          loc: node.loc,
          branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
          return processCodegen(ifNode, branch, true);
        }
      } else {
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 3) {
            context.removeNode(sibling);
            comments.unshift(sibling);
            continue;
          }
          if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
            context.removeNode(sibling);
            continue;
          }
          if (sibling && sibling.type === 9) {
            context.removeNode();
            const branch = createIfBranch(node, dir);
            if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
              branch.children = [...comments, ...branch.children];
            }
            {
              const key = branch.userKey;
              if (key) {
                sibling.branches.forEach(({ userKey }) => {
                  if (isSameKey(userKey, key)) {
                    context.onError(createCompilerError(28, branch.userKey.loc));
                  }
                });
              }
            }
            sibling.branches.push(branch);
            const onExit = processCodegen && processCodegen(sibling, branch, false);
            traverseNode(branch, context);
            if (onExit)
              onExit();
            context.currentNode = null;
          } else {
            context.onError(createCompilerError(29, node.loc));
          }
          break;
        }
      }
    }
    function createIfBranch(node, dir) {
      return {
        type: 10,
        loc: node.loc,
        condition: dir.name === "else" ? void 0 : dir.exp,
        children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
        userKey: findProp(node, `key`)
      };
    }
    function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
          '"v-if"',
          "true"
        ]));
      } else {
        return createChildrenCodegenNode(branch, keyIndex, context);
      }
    }
    function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
      if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11) {
          const vnodeCall = firstChild.codegenNode;
          injectProp(vnodeCall, keyProperty, context);
          return vnodeCall;
        } else {
          let patchFlag = 64;
          let patchFlagText = shared.PatchFlagNames[64];
          if (children.filter((c) => c.type !== 3).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
          }
          return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ` /* ${patchFlagText} */`, void 0, void 0, true, false, false, branch.loc);
        }
      } else {
        const ret2 = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret2);
        if (vnodeCall.type === 13) {
          makeBlock(vnodeCall, context);
        }
        injectProp(vnodeCall, keyProperty, context);
        return ret2;
      }
    }
    function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
        return false;
      }
      if (a.type === 6) {
        if (a.value.content !== b.value.content) {
          return false;
        }
      } else {
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
          return false;
        }
        if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
          return false;
        }
      }
      return true;
    }
    function getParentCondition(node) {
      while (true) {
        if (node.type === 19) {
          if (node.alternate.type === 19) {
            node = node.alternate;
          } else {
            return node;
          }
        } else if (node.type === 20) {
          node = node.value;
        }
      }
    }
    var transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        if (context.prefixIdentifiers && keyProperty) {
          keyProperty.value = processExpression(keyProperty.value, context);
        }
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ` /* ${shared.PatchFlagNames[fragmentFlag]} */`, void 0, void 0, true, !isStableFragment, false, node.loc);
        return () => {
          let childBlock;
          const isTemplate = isTemplateNode(node);
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(createCompilerError(32, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + ` /* ${shared.PatchFlagNames[64]} */`, void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
        context.onError(createCompilerError(30, dir.loc));
        return;
      }
      const parseResult = parseForExpression(dir.exp, context);
      if (!parseResult) {
        context.onError(createCompilerError(31, dir.loc));
        return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
        type: 11,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      scopes.vFor++;
      if (context.prefixIdentifiers) {
        value && addIdentifiers(value);
        key && addIdentifiers(key);
        index && addIdentifiers(index);
      }
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
        scopes.vFor--;
        if (context.prefixIdentifiers) {
          value && removeIdentifiers(value);
          key && removeIdentifiers(key);
          index && removeIdentifiers(index);
        }
        if (onExit)
          onExit();
      };
    }
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    function parseForExpression(input, context) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
        return;
      const [, LHS, RHS] = inMatch;
      const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: void 0,
        key: void 0,
        index: void 0
      };
      if (context.prefixIdentifiers) {
        result.source = processExpression(result.source, context);
      }
      let valueContent = LHS.trim().replace(stripParensRE, "").trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, "").trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
          keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
          result.key = createAliasExpression(loc, keyContent, keyOffset);
          if (context.prefixIdentifiers) {
            result.key = processExpression(result.key, context, true);
          }
        }
        if (iteratorMatch[2]) {
          const indexContent = iteratorMatch[2].trim();
          if (indexContent) {
            result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
            if (context.prefixIdentifiers) {
              result.index = processExpression(result.index, context, true);
            }
          }
        }
      }
      if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (context.prefixIdentifiers) {
          result.value = processExpression(result.value, context, true);
        }
      }
      return result;
    }
    function createAliasExpression(range, content, offset) {
      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
    }
    function createForLoopParams({ value, key, index }, memoArgs = []) {
      return createParamsList([value, key, index, ...memoArgs]);
    }
    function createParamsList(args) {
      let i = args.length;
      while (i--) {
        if (args[i])
          break;
      }
      return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
    }
    var defaultFallback = createSimpleExpression(`undefined`, false);
    var trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          const slotProps = vSlot.exp;
          if (context.prefixIdentifiers) {
            slotProps && context.addIdentifiers(slotProps);
          }
          context.scopes.vSlot++;
          return () => {
            if (context.prefixIdentifiers) {
              slotProps && context.removeIdentifiers(slotProps);
            }
            context.scopes.vSlot--;
          };
        }
      }
    };
    var trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(vFor.exp, context);
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      if (!context.ssr && context.prefixIdentifiers) {
        hasDynamicSlots = hasScopeRef(node, context.identifiers);
      }
      const onComponentSlot = findDir(node, "slot", true);
      if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
          hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
      }
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = new Set();
      for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
          if (slotElement.type !== 3) {
            implicitDefaultChildren.push(slotElement);
          }
          continue;
        }
        if (onComponentSlot) {
          context.onError(createCompilerError(36, slotDir.loc));
          break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        let staticSlotName;
        if (isStaticExp(slotName)) {
          staticSlotName = slotName ? slotName.content : `default`;
        } else {
          hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        let vIf;
        let vElse;
        let vFor;
        if (vIf = findDir(slotElement, "if")) {
          hasDynamicSlots = true;
          dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
          let j = i;
          let prev;
          while (j--) {
            prev = children[j];
            if (prev.type !== 3) {
              break;
            }
          }
          if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
            children.splice(i, 1);
            i--;
            let conditional = dynamicSlots[dynamicSlots.length - 1];
            while (conditional.alternate.type === 19) {
              conditional = conditional.alternate;
            }
            conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
          } else {
            context.onError(createCompilerError(29, vElse.loc));
          }
        } else if (vFor = findDir(slotElement, "for")) {
          hasDynamicSlots = true;
          const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
          if (parseResult) {
            dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
            ]));
          } else {
            context.onError(createCompilerError(31, vFor.loc));
          }
        } else {
          if (staticSlotName) {
            if (seenSlotNames.has(staticSlotName)) {
              context.onError(createCompilerError(37, dirLoc));
              continue;
            }
            seenSlotNames.add(staticSlotName);
            if (staticSlotName === "default") {
              hasNamedDefaultSlot = true;
            }
          }
          slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
      }
      if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children2) => {
          const fn = buildSlotFn(props, children2, loc);
          if (context.compatConfig) {
            fn.isNonScopedSlot = true;
          }
          return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
          slotsProperties.push(buildDefaultSlotProperty(void 0, children));
        } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
          if (hasNamedDefaultSlot) {
            context.onError(createCompilerError(38, implicitDefaultChildren[0].loc));
          } else {
            slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
          }
        }
      }
      const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ` /* ${shared.slotFlagsText[slotFlag]} */`, false))), loc);
      if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
          slots,
          createArrayExpression(dynamicSlots)
        ]);
      }
      return {
        slots,
        hasDynamicSlots
      };
    }
    function buildDynamicSlot(name, fn) {
      return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
      ]);
    }
    function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
          case 1:
            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
              return true;
            }
            break;
          case 9:
            if (hasForwardedSlots(child.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(child.children))
              return true;
            break;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(node) {
      if (node.type !== 2 && node.type !== 12)
        return true;
      return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
    }
    var directiveImportMap = new WeakMap();
    var transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject" || findProp(node, "key", true));
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(createCompilerError(44, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${shared.PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(shared.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => shared.PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
      };
    };
    function resolveComponentType(node, context, ssr = false) {
      let { tag } = node;
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node, "is");
      if (isProp) {
        if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
          const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
          if (exp) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp
            ]);
          }
        } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
          tag = isProp.value.content.slice(4);
        }
      }
      const isDir = !isExplicitDynamic && findDir(node, "is");
      if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          isDir.exp
        ]);
      }
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
        if (!ssr)
          context.helper(builtIn);
        return builtIn;
      }
      {
        const fromSetup = resolveSetupReference(tag, context);
        if (fromSetup) {
          return fromSetup;
        }
        const dotIndex = tag.indexOf(".");
        if (dotIndex > 0) {
          const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
          if (ns) {
            return ns + tag.slice(dotIndex);
          }
        }
      }
      if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {
        context.helper(RESOLVE_COMPONENT);
        context.components.add(tag + `__self`);
        return toValidAssetId(tag, `component`);
      }
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
    }
    function resolveSetupReference(name, context) {
      const bindings = context.bindingMetadata;
      if (!bindings || bindings.__isScriptSetup === false) {
        return;
      }
      const camelName = shared.camelize(name);
      const PascalName = shared.capitalize(camelName);
      const checkType = (type) => {
        if (bindings[name] === type) {
          return name;
        }
        if (bindings[camelName] === type) {
          return camelName;
        }
        if (bindings[PascalName] === type) {
          return PascalName;
        }
      };
      const fromConst = checkType("setup-const");
      if (fromConst) {
        return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
      }
      const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
      if (fromMaybeRef) {
        return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
      }
    }
    function buildProps(node, context, props = node.props, ssr = false) {
      const { tag, loc: elementLoc } = node;
      const isComponent2 = node.tagType === 1;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
          const name = key.content;
          const isEventHandler = shared.isOn(name);
          if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !shared.isReservedProp(name)) {
            hasHydrationEventBinding = true;
          }
          if (isEventHandler && shared.isReservedProp(name)) {
            hasVnodeHook = true;
          }
          if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
            return;
          }
          if (name === "ref") {
            hasRef = true;
          } else if (name === "class") {
            hasClassBinding = true;
          } else if (name === "style") {
            hasStyleBinding = true;
          } else if (name !== "key" && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
          if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
        } else {
          hasDynamicKeys = true;
        }
      };
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 6) {
          const { loc, name, value } = prop;
          let isStatic = true;
          if (name === "ref") {
            hasRef = true;
            if (context.inline) {
              isStatic = false;
            }
          }
          if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
            continue;
          }
          properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
        } else {
          const { name, arg, exp, loc } = prop;
          const isVBind = name === "bind";
          const isVOn = name === "on";
          if (name === "slot") {
            if (!isComponent2) {
              context.onError(createCompilerError(39, loc));
            }
            continue;
          }
          if (name === "once" || name === "memo") {
            continue;
          }
          if (name === "is" || isVBind && isBindKey(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
            continue;
          }
          if (isVOn && ssr) {
            continue;
          }
          if (!arg && (isVBind || isVOn)) {
            hasDynamicKeys = true;
            if (exp) {
              if (properties.length) {
                mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                properties = [];
              }
              if (isVBind) {
                {
                  {
                    const hasOverridableKeys = mergeArgs.some((arg2) => {
                      if (arg2.type === 15) {
                        return arg2.properties.some(({ key }) => {
                          if (key.type !== 4 || !key.isStatic) {
                            return true;
                          }
                          return key.content !== "class" && key.content !== "style" && !shared.isOn(key.content);
                        });
                      } else {
                        return true;
                      }
                    });
                    if (hasOverridableKeys) {
                      checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                    }
                  }
                  if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                    mergeArgs.unshift(exp);
                    continue;
                  }
                }
                mergeArgs.push(exp);
              } else {
                mergeArgs.push({
                  type: 14,
                  loc,
                  callee: context.helper(TO_HANDLERS),
                  arguments: [exp]
                });
              }
            } else {
              context.onError(createCompilerError(isVBind ? 33 : 34, loc));
            }
            continue;
          }
          const directiveTransform = context.directiveTransforms[name];
          if (directiveTransform) {
            const { props: props2, needRuntime } = directiveTransform(prop, node, context);
            !ssr && props2.forEach(analyzePatchFlag);
            properties.push(...props2);
            if (needRuntime) {
              runtimeDirectives.push(prop);
              if (shared.isSymbol(needRuntime)) {
                directiveImportMap.set(prop, needRuntime);
              }
            }
          } else {
            runtimeDirectives.push(prop);
          }
        }
        if (prop.type === 6 && prop.name === "ref" && context.scopes.vFor > 0 && checkCompatEnabled("COMPILER_V_FOR_REF", context, prop.loc)) {
          properties.push(createObjectProperty(createSimpleExpression("refInFor", true), createSimpleExpression("true", false)));
        }
      }
      let propsExpression = void 0;
      if (mergeArgs.length) {
        if (properties.length) {
          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
          propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        } else {
          propsExpression = mergeArgs[0];
        }
      } else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      if (hasDynamicKeys) {
        patchFlag |= 16;
      } else {
        if (hasClassBinding && !isComponent2) {
          patchFlag |= 2;
        }
        if (hasStyleBinding && !isComponent2) {
          patchFlag |= 4;
        }
        if (dynamicPropNames.length) {
          patchFlag |= 8;
        }
        if (hasHydrationEventBinding) {
          patchFlag |= 32;
        }
      }
      if ((patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512;
      }
      if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
          case 15:
            let classKeyIndex = -1;
            let styleKeyIndex = -1;
            let hasDynamicKey = false;
            for (let i = 0; i < propsExpression.properties.length; i++) {
              const key = propsExpression.properties[i].key;
              if (isStaticExp(key)) {
                if (key.content === "class") {
                  classKeyIndex = i;
                } else if (key.content === "style") {
                  styleKeyIndex = i;
                }
              } else if (!key.isHandlerKey) {
                hasDynamicKey = true;
              }
            }
            const classProp = propsExpression.properties[classKeyIndex];
            const styleProp = propsExpression.properties[styleKeyIndex];
            if (!hasDynamicKey) {
              if (classProp && !isStaticExp(classProp.value)) {
                classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
              }
              if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
                styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
              }
            } else {
              propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
            }
            break;
          case 14:
            break;
          default:
            propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]);
            break;
        }
      }
      return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames
      };
    }
    function dedupeProperties(properties) {
      const knownProps = new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        if (prop.key.type === 8 || !prop.key.isStatic) {
          deduped.push(prop);
          continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
          if (name === "style" || name === "class" || name.startsWith("on")) {
            mergeAsArray(existing, prop);
          }
        } else {
          knownProps.set(name, prop);
          deduped.push(prop);
        }
      }
      return deduped;
    }
    function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17) {
        existing.value.elements.push(incoming.value);
      } else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
    }
    function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
        dirArgs.push(context.helperString(runtime));
      } else {
        const fromSetup = resolveSetupReference("v-" + dir.name, context);
        if (fromSetup) {
          dirArgs.push(fromSetup);
        } else {
          context.helper(RESOLVE_DIRECTIVE);
          context.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
      }
      const { loc } = dir;
      if (dir.exp)
        dirArgs.push(dir.exp);
      if (dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
    }
    function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
          propsNamesString += ", ";
      }
      return propsNamesString + `]`;
    }
    function isComponentTag(tag) {
      return tag[0].toLowerCase() + tag.slice(1) === "component";
    }
    Object.freeze({});
    Object.freeze([]);
    var cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName
        ];
        if (slotProps) {
          slotArgs.push(slotProps);
        }
        if (children.length) {
          if (!slotProps) {
            slotArgs.push(`{}`);
          }
          slotArgs.push(createFunctionExpression([], children, false, false, loc));
        }
        if (context.scopeId && !context.slotted) {
          if (!slotProps) {
            slotArgs.push(`{}`);
          }
          if (!children.length) {
            slotArgs.push(`undefined`);
          }
          slotArgs.push(`true`);
        }
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = void 0;
      const nonNameProps = [];
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (p.value) {
            if (p.name === "name") {
              slotName = JSON.stringify(p.value.content);
            } else {
              p.name = camelize(p.name);
              nonNameProps.push(p);
            }
          }
        } else {
          if (p.name === "bind" && isBindKey(p.arg, "name")) {
            if (p.exp)
              slotName = p.exp;
          } else {
            if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
              p.arg.content = camelize(p.arg.content);
            }
            nonNameProps.push(p);
          }
        }
      }
      if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps);
        slotProps = props;
        if (directives.length) {
          context.onError(createCompilerError(35, directives[0].loc));
        }
      }
      return {
        slotName,
        slotProps
      };
    }
    var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
    var transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(34, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          const rawName = arg.content;
          eventName = createSimpleExpression(shared.toHandlerKey(shared.camelize(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (context.prefixIdentifiers) {
          isInlineStatement && context.addIdentifiers(`$event`);
          exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
          isInlineStatement && context.removeIdentifiers(`$event`);
          shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
          if (shouldCache && isMemberExp) {
            if (exp.type === 4) {
              exp.content = `${exp.content} && ${exp.content}(...args)`;
            } else {
              exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
            }
          }
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret2 = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret2 = augmentor(ret2);
      }
      if (shouldCache) {
        ret2.props[0].value = context.cache(ret2.props[0].value);
      }
      ret2.props.forEach((p) => p.key.isHandlerKey = true);
      return ret2;
    };
    var transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = shared.camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(33, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    var injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    var transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + ` /* ${shared.PatchFlagNames[1]} */`);
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    var seen = new WeakSet();
    var transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(cur.codegenNode, true);
          }
        };
      }
    };
    var transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(40, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      const maybeRef = context.inline && bindingType && bindingType !== "setup-const";
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(createCompilerError(41, exp.loc));
        return createTransformProps();
      }
      if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      if (maybeRef) {
        if (bindingType === "setup-ref") {
          assignmentExp = createCompoundExpression([
            `${eventArg} => (`,
            createSimpleExpression(rawExp, false, exp.loc),
            `.value = $event)`
          ]);
        } else {
          const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
          assignmentExp = createCompoundExpression([
            `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? `,
            createSimpleExpression(rawExp, false, exp.loc),
            `.value = $event : ${altAssignment})`
          ]);
        }
      } else {
        assignmentExp = createCompoundExpression([
          `${eventArg} => (`,
          exp,
          ` = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
        props[1].value = context.cache(props[1].value);
      }
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    function createTransformProps(props = []) {
      return { props };
    }
    var validDivisionCharRE = /[\w).+\-_$\]]/;
    var transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    function rewriteFilter(node, context) {
      if (node.type === 4) {
        parseFilter(node, context);
      } else {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (typeof child !== "object")
            continue;
          if (child.type === 4) {
            parseFilter(child, context);
          } else if (child.type === 8) {
            rewriteFilter(node, context);
          } else if (child.type === 5) {
            rewriteFilter(child.content, context);
          }
        }
      }
    }
    function parseFilter(node, context) {
      const exp = node.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c, prev, i, expression, filters = [];
      for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
          if (c === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c === 47 && prev !== 92)
            inRegex = false;
        } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i + 1;
            expression = exp.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c === 47) {
            let j = i - 1;
            let p;
            for (; j >= 0; j--) {
              p = exp.charAt(j);
              if (p !== " ")
                break;
            }
            if (!p || !validDivisionCharRE.test(p)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
      }
      if (filters.length) {
        warnDeprecation("COMPILER_FILTER", context, node.loc);
        for (i = 0; i < filters.length; i++) {
          expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
      }
    }
    function wrapFilter(exp, filter, context) {
      context.helper(RESOLVE_FILTER);
      const i = filter.indexOf("(");
      if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, "filter")}(${exp})`;
      } else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var seen$1 = new WeakSet();
    var transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    function getBaseTransformPreset(prefixIdentifiers) {
      return [
        [
          transformOnce,
          transformIf,
          transformMemo,
          transformFor,
          ...[transformFilter],
          ...prefixIdentifiers ? [
            trackVForSlotScopes,
            transformExpression
          ] : [],
          transformSlotOutlet,
          transformElement,
          trackSlotScopes,
          transformText
        ],
        {
          on: transformOn,
          bind: transformBind,
          model: transformModel
        }
      ];
    }
    function baseCompile(template2, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === "module";
      const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
      if (!prefixIdentifiers && options.cacheHandlers) {
        onError(createCompilerError(47));
      }
      if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(48));
      }
      const ast = shared.isString(template2) ? baseParse(template2, options) : template2;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
      transform(ast, shared.extend({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: shared.extend({}, directiveTransforms, options.directiveTransforms || {})
      }));
      return generate2(ast, shared.extend({}, options, {
        prefixIdentifiers
      }));
    }
    var noopDirectiveTransform = () => ({ props: [] });
    exports2.generateCodeFrame = shared.generateCodeFrame;
    exports2.BASE_TRANSITION = BASE_TRANSITION;
    exports2.CAMELIZE = CAMELIZE;
    exports2.CAPITALIZE = CAPITALIZE;
    exports2.CREATE_BLOCK = CREATE_BLOCK;
    exports2.CREATE_COMMENT = CREATE_COMMENT;
    exports2.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
    exports2.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
    exports2.CREATE_SLOTS = CREATE_SLOTS;
    exports2.CREATE_STATIC = CREATE_STATIC;
    exports2.CREATE_TEXT = CREATE_TEXT;
    exports2.CREATE_VNODE = CREATE_VNODE;
    exports2.FRAGMENT = FRAGMENT;
    exports2.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
    exports2.IS_MEMO_SAME = IS_MEMO_SAME;
    exports2.IS_REF = IS_REF;
    exports2.KEEP_ALIVE = KEEP_ALIVE;
    exports2.MERGE_PROPS = MERGE_PROPS;
    exports2.NORMALIZE_CLASS = NORMALIZE_CLASS;
    exports2.NORMALIZE_PROPS = NORMALIZE_PROPS;
    exports2.NORMALIZE_STYLE = NORMALIZE_STYLE;
    exports2.OPEN_BLOCK = OPEN_BLOCK;
    exports2.POP_SCOPE_ID = POP_SCOPE_ID;
    exports2.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
    exports2.RENDER_LIST = RENDER_LIST;
    exports2.RENDER_SLOT = RENDER_SLOT;
    exports2.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
    exports2.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
    exports2.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
    exports2.RESOLVE_FILTER = RESOLVE_FILTER;
    exports2.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
    exports2.SUSPENSE = SUSPENSE;
    exports2.TELEPORT = TELEPORT;
    exports2.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
    exports2.TO_HANDLERS = TO_HANDLERS;
    exports2.TO_HANDLER_KEY = TO_HANDLER_KEY;
    exports2.UNREF = UNREF;
    exports2.WITH_CTX = WITH_CTX;
    exports2.WITH_DIRECTIVES = WITH_DIRECTIVES;
    exports2.WITH_MEMO = WITH_MEMO;
    exports2.WITH_SCOPE_ID = WITH_SCOPE_ID;
    exports2.advancePositionWithClone = advancePositionWithClone;
    exports2.advancePositionWithMutation = advancePositionWithMutation;
    exports2.assert = assert;
    exports2.baseCompile = baseCompile;
    exports2.baseParse = baseParse;
    exports2.buildProps = buildProps;
    exports2.buildSlots = buildSlots;
    exports2.checkCompatEnabled = checkCompatEnabled;
    exports2.createArrayExpression = createArrayExpression;
    exports2.createAssignmentExpression = createAssignmentExpression;
    exports2.createBlockStatement = createBlockStatement;
    exports2.createCacheExpression = createCacheExpression;
    exports2.createCallExpression = createCallExpression;
    exports2.createCompilerError = createCompilerError;
    exports2.createCompoundExpression = createCompoundExpression;
    exports2.createConditionalExpression = createConditionalExpression;
    exports2.createForLoopParams = createForLoopParams;
    exports2.createFunctionExpression = createFunctionExpression;
    exports2.createIfStatement = createIfStatement;
    exports2.createInterpolation = createInterpolation;
    exports2.createObjectExpression = createObjectExpression;
    exports2.createObjectProperty = createObjectProperty;
    exports2.createReturnStatement = createReturnStatement;
    exports2.createRoot = createRoot;
    exports2.createSequenceExpression = createSequenceExpression;
    exports2.createSimpleExpression = createSimpleExpression;
    exports2.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
    exports2.createTemplateLiteral = createTemplateLiteral;
    exports2.createTransformContext = createTransformContext;
    exports2.createVNodeCall = createVNodeCall;
    exports2.findDir = findDir;
    exports2.findProp = findProp;
    exports2.generate = generate2;
    exports2.getBaseTransformPreset = getBaseTransformPreset;
    exports2.getInnerRange = getInnerRange;
    exports2.getMemoedVNodeCall = getMemoedVNodeCall;
    exports2.getVNodeBlockHelper = getVNodeBlockHelper;
    exports2.getVNodeHelper = getVNodeHelper;
    exports2.hasDynamicKeyVBind = hasDynamicKeyVBind;
    exports2.hasScopeRef = hasScopeRef;
    exports2.helperNameMap = helperNameMap;
    exports2.injectProp = injectProp;
    exports2.isBindKey = isBindKey;
    exports2.isBuiltInType = isBuiltInType;
    exports2.isCoreComponent = isCoreComponent;
    exports2.isMemberExpression = isMemberExpression;
    exports2.isSimpleIdentifier = isSimpleIdentifier;
    exports2.isSlotOutlet = isSlotOutlet;
    exports2.isStaticExp = isStaticExp;
    exports2.isTemplateNode = isTemplateNode;
    exports2.isText = isText;
    exports2.isVSlot = isVSlot;
    exports2.locStub = locStub;
    exports2.makeBlock = makeBlock;
    exports2.noopDirectiveTransform = noopDirectiveTransform;
    exports2.processExpression = processExpression;
    exports2.processFor = processFor;
    exports2.processIf = processIf;
    exports2.processSlotOutlet = processSlotOutlet;
    exports2.registerRuntimeHelpers = registerRuntimeHelpers;
    exports2.resolveComponentType = resolveComponentType;
    exports2.toValidAssetId = toValidAssetId;
    exports2.trackSlotScopes = trackSlotScopes;
    exports2.trackVForSlotScopes = trackVForSlotScopes;
    exports2.transform = transform;
    exports2.transformBind = transformBind;
    exports2.transformElement = transformElement;
    exports2.transformExpression = transformExpression;
    exports2.transformModel = transformModel;
    exports2.transformOn = transformOn;
    exports2.traverseNode = traverseNode;
    exports2.warnDeprecation = warnDeprecation;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-core-npm-3.2.4-c45a69b873-a78e318f17.zip/node_modules/@vue/compiler-core/index.js
var require_compiler_core = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-core-npm-3.2.4-c45a69b873-a78e318f17.zip/node_modules/@vue/compiler-core/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_compiler_core_cjs();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-dom-npm-3.2.4-0229722813-c73fc217bd.zip/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js
var require_compiler_dom_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-dom-npm-3.2.4-0229722813-c73fc217bd.zip/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var compilerCore = require_compiler_core();
    var shared = require_shared();
    var V_MODEL_RADIO = Symbol(`vModelRadio`);
    var V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
    var V_MODEL_TEXT = Symbol(`vModelText`);
    var V_MODEL_SELECT = Symbol(`vModelSelect`);
    var V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
    var V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
    var V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
    var V_SHOW = Symbol(`vShow`);
    var TRANSITION = Symbol(`Transition`);
    var TRANSITION_GROUP = Symbol(`TransitionGroup`);
    compilerCore.registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    var namedCharacterReferences = {
      GT: ">",
      gt: ">",
      LT: "<",
      lt: "<",
      "ac;": "\u223E",
      "af;": "\u2061",
      AMP: "&",
      amp: "&",
      "ap;": "\u2248",
      "DD;": "\u2145",
      "dd;": "\u2146",
      deg: "\xB0",
      "ee;": "\u2147",
      "eg;": "\u2A9A",
      "el;": "\u2A99",
      ETH: "\xD0",
      eth: "\xF0",
      "gE;": "\u2267",
      "ge;": "\u2265",
      "Gg;": "\u22D9",
      "gg;": "\u226B",
      "gl;": "\u2277",
      "GT;": ">",
      "Gt;": "\u226B",
      "gt;": ">",
      "ic;": "\u2063",
      "ii;": "\u2148",
      "Im;": "\u2111",
      "in;": "\u2208",
      "it;": "\u2062",
      "lE;": "\u2266",
      "le;": "\u2264",
      "lg;": "\u2276",
      "Ll;": "\u22D8",
      "ll;": "\u226A",
      "LT;": "<",
      "Lt;": "\u226A",
      "lt;": "<",
      "mp;": "\u2213",
      "Mu;": "\u039C",
      "mu;": "\u03BC",
      "ne;": "\u2260",
      "ni;": "\u220B",
      not: "\xAC",
      "Nu;": "\u039D",
      "nu;": "\u03BD",
      "Or;": "\u2A54",
      "or;": "\u2228",
      "oS;": "\u24C8",
      "Pi;": "\u03A0",
      "pi;": "\u03C0",
      "pm;": "\xB1",
      "Pr;": "\u2ABB",
      "pr;": "\u227A",
      "Re;": "\u211C",
      REG: "\xAE",
      reg: "\xAE",
      "rx;": "\u211E",
      "Sc;": "\u2ABC",
      "sc;": "\u227B",
      shy: "\xAD",
      uml: "\xA8",
      "wp;": "\u2118",
      "wr;": "\u2240",
      "Xi;": "\u039E",
      "xi;": "\u03BE",
      yen: "\xA5",
      "acd;": "\u223F",
      "acE;": "\u223E\u0333",
      "Acy;": "\u0410",
      "acy;": "\u0430",
      "Afr;": "\u{1D504}",
      "afr;": "\u{1D51E}",
      "AMP;": "&",
      "amp;": "&",
      "And;": "\u2A53",
      "and;": "\u2227",
      "ang;": "\u2220",
      "apE;": "\u2A70",
      "ape;": "\u224A",
      "ast;": "*",
      Auml: "\xC4",
      auml: "\xE4",
      "Bcy;": "\u0411",
      "bcy;": "\u0431",
      "Bfr;": "\u{1D505}",
      "bfr;": "\u{1D51F}",
      "bne;": "=\u20E5",
      "bot;": "\u22A5",
      "Cap;": "\u22D2",
      "cap;": "\u2229",
      cent: "\xA2",
      "Cfr;": "\u212D",
      "cfr;": "\u{1D520}",
      "Chi;": "\u03A7",
      "chi;": "\u03C7",
      "cir;": "\u25CB",
      COPY: "\xA9",
      copy: "\xA9",
      "Cup;": "\u22D3",
      "cup;": "\u222A",
      "Dcy;": "\u0414",
      "dcy;": "\u0434",
      "deg;": "\xB0",
      "Del;": "\u2207",
      "Dfr;": "\u{1D507}",
      "dfr;": "\u{1D521}",
      "die;": "\xA8",
      "div;": "\xF7",
      "Dot;": "\xA8",
      "dot;": "\u02D9",
      "Ecy;": "\u042D",
      "ecy;": "\u044D",
      "Efr;": "\u{1D508}",
      "efr;": "\u{1D522}",
      "egs;": "\u2A96",
      "ell;": "\u2113",
      "els;": "\u2A95",
      "ENG;": "\u014A",
      "eng;": "\u014B",
      "Eta;": "\u0397",
      "eta;": "\u03B7",
      "ETH;": "\xD0",
      "eth;": "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      "Fcy;": "\u0424",
      "fcy;": "\u0444",
      "Ffr;": "\u{1D509}",
      "ffr;": "\u{1D523}",
      "gap;": "\u2A86",
      "Gcy;": "\u0413",
      "gcy;": "\u0433",
      "gEl;": "\u2A8C",
      "gel;": "\u22DB",
      "geq;": "\u2265",
      "ges;": "\u2A7E",
      "Gfr;": "\u{1D50A}",
      "gfr;": "\u{1D524}",
      "ggg;": "\u22D9",
      "gla;": "\u2AA5",
      "glE;": "\u2A92",
      "glj;": "\u2AA4",
      "gnE;": "\u2269",
      "gne;": "\u2A88",
      "Hat;": "^",
      "Hfr;": "\u210C",
      "hfr;": "\u{1D525}",
      "Icy;": "\u0418",
      "icy;": "\u0438",
      "iff;": "\u21D4",
      "Ifr;": "\u2111",
      "ifr;": "\u{1D526}",
      "Int;": "\u222C",
      "int;": "\u222B",
      Iuml: "\xCF",
      iuml: "\xEF",
      "Jcy;": "\u0419",
      "jcy;": "\u0439",
      "Jfr;": "\u{1D50D}",
      "jfr;": "\u{1D527}",
      "Kcy;": "\u041A",
      "kcy;": "\u043A",
      "Kfr;": "\u{1D50E}",
      "kfr;": "\u{1D528}",
      "lap;": "\u2A85",
      "lat;": "\u2AAB",
      "Lcy;": "\u041B",
      "lcy;": "\u043B",
      "lEg;": "\u2A8B",
      "leg;": "\u22DA",
      "leq;": "\u2264",
      "les;": "\u2A7D",
      "Lfr;": "\u{1D50F}",
      "lfr;": "\u{1D529}",
      "lgE;": "\u2A91",
      "lnE;": "\u2268",
      "lne;": "\u2A87",
      "loz;": "\u25CA",
      "lrm;": "\u200E",
      "Lsh;": "\u21B0",
      "lsh;": "\u21B0",
      macr: "\xAF",
      "Map;": "\u2905",
      "map;": "\u21A6",
      "Mcy;": "\u041C",
      "mcy;": "\u043C",
      "Mfr;": "\u{1D510}",
      "mfr;": "\u{1D52A}",
      "mho;": "\u2127",
      "mid;": "\u2223",
      "nap;": "\u2249",
      nbsp: "\xA0",
      "Ncy;": "\u041D",
      "ncy;": "\u043D",
      "Nfr;": "\u{1D511}",
      "nfr;": "\u{1D52B}",
      "ngE;": "\u2267\u0338",
      "nge;": "\u2271",
      "nGg;": "\u22D9\u0338",
      "nGt;": "\u226B\u20D2",
      "ngt;": "\u226F",
      "nis;": "\u22FC",
      "niv;": "\u220B",
      "nlE;": "\u2266\u0338",
      "nle;": "\u2270",
      "nLl;": "\u22D8\u0338",
      "nLt;": "\u226A\u20D2",
      "nlt;": "\u226E",
      "Not;": "\u2AEC",
      "not;": "\xAC",
      "npr;": "\u2280",
      "nsc;": "\u2281",
      "num;": "#",
      "Ocy;": "\u041E",
      "ocy;": "\u043E",
      "Ofr;": "\u{1D512}",
      "ofr;": "\u{1D52C}",
      "ogt;": "\u29C1",
      "ohm;": "\u03A9",
      "olt;": "\u29C0",
      "ord;": "\u2A5D",
      ordf: "\xAA",
      ordm: "\xBA",
      "orv;": "\u2A5B",
      Ouml: "\xD6",
      ouml: "\xF6",
      "par;": "\u2225",
      para: "\xB6",
      "Pcy;": "\u041F",
      "pcy;": "\u043F",
      "Pfr;": "\u{1D513}",
      "pfr;": "\u{1D52D}",
      "Phi;": "\u03A6",
      "phi;": "\u03C6",
      "piv;": "\u03D6",
      "prE;": "\u2AB3",
      "pre;": "\u2AAF",
      "Psi;": "\u03A8",
      "psi;": "\u03C8",
      "Qfr;": "\u{1D514}",
      "qfr;": "\u{1D52E}",
      QUOT: '"',
      quot: '"',
      "Rcy;": "\u0420",
      "rcy;": "\u0440",
      "REG;": "\xAE",
      "reg;": "\xAE",
      "Rfr;": "\u211C",
      "rfr;": "\u{1D52F}",
      "Rho;": "\u03A1",
      "rho;": "\u03C1",
      "rlm;": "\u200F",
      "Rsh;": "\u21B1",
      "rsh;": "\u21B1",
      "scE;": "\u2AB4",
      "sce;": "\u2AB0",
      "Scy;": "\u0421",
      "scy;": "\u0441",
      sect: "\xA7",
      "Sfr;": "\u{1D516}",
      "sfr;": "\u{1D530}",
      "shy;": "\xAD",
      "sim;": "\u223C",
      "smt;": "\u2AAA",
      "sol;": "/",
      "squ;": "\u25A1",
      "Sub;": "\u22D0",
      "sub;": "\u2282",
      "Sum;": "\u2211",
      "sum;": "\u2211",
      "Sup;": "\u22D1",
      "sup;": "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      "Tab;": "	",
      "Tau;": "\u03A4",
      "tau;": "\u03C4",
      "Tcy;": "\u0422",
      "tcy;": "\u0442",
      "Tfr;": "\u{1D517}",
      "tfr;": "\u{1D531}",
      "top;": "\u22A4",
      "Ucy;": "\u0423",
      "ucy;": "\u0443",
      "Ufr;": "\u{1D518}",
      "ufr;": "\u{1D532}",
      "uml;": "\xA8",
      Uuml: "\xDC",
      uuml: "\xFC",
      "Vcy;": "\u0412",
      "vcy;": "\u0432",
      "Vee;": "\u22C1",
      "vee;": "\u2228",
      "Vfr;": "\u{1D519}",
      "vfr;": "\u{1D533}",
      "Wfr;": "\u{1D51A}",
      "wfr;": "\u{1D534}",
      "Xfr;": "\u{1D51B}",
      "xfr;": "\u{1D535}",
      "Ycy;": "\u042B",
      "ycy;": "\u044B",
      "yen;": "\xA5",
      "Yfr;": "\u{1D51C}",
      "yfr;": "\u{1D536}",
      yuml: "\xFF",
      "Zcy;": "\u0417",
      "zcy;": "\u0437",
      "Zfr;": "\u2128",
      "zfr;": "\u{1D537}",
      "zwj;": "\u200D",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      AElig: "\xC6",
      aelig: "\xE6",
      "andd;": "\u2A5C",
      "andv;": "\u2A5A",
      "ange;": "\u29A4",
      "Aopf;": "\u{1D538}",
      "aopf;": "\u{1D552}",
      "apid;": "\u224B",
      "apos;": "'",
      Aring: "\xC5",
      aring: "\xE5",
      "Ascr;": "\u{1D49C}",
      "ascr;": "\u{1D4B6}",
      "Auml;": "\xC4",
      "auml;": "\xE4",
      "Barv;": "\u2AE7",
      "bbrk;": "\u23B5",
      "Beta;": "\u0392",
      "beta;": "\u03B2",
      "beth;": "\u2136",
      "bNot;": "\u2AED",
      "bnot;": "\u2310",
      "Bopf;": "\u{1D539}",
      "bopf;": "\u{1D553}",
      "boxH;": "\u2550",
      "boxh;": "\u2500",
      "boxV;": "\u2551",
      "boxv;": "\u2502",
      "Bscr;": "\u212C",
      "bscr;": "\u{1D4B7}",
      "bsim;": "\u223D",
      "bsol;": "\\",
      "bull;": "\u2022",
      "bump;": "\u224E",
      "caps;": "\u2229\uFE00",
      "Cdot;": "\u010A",
      "cdot;": "\u010B",
      cedil: "\xB8",
      "cent;": "\xA2",
      "CHcy;": "\u0427",
      "chcy;": "\u0447",
      "circ;": "\u02C6",
      "cirE;": "\u29C3",
      "cire;": "\u2257",
      "comp;": "\u2201",
      "cong;": "\u2245",
      "Copf;": "\u2102",
      "copf;": "\u{1D554}",
      "COPY;": "\xA9",
      "copy;": "\xA9",
      "Cscr;": "\u{1D49E}",
      "cscr;": "\u{1D4B8}",
      "csub;": "\u2ACF",
      "csup;": "\u2AD0",
      "cups;": "\u222A\uFE00",
      "Darr;": "\u21A1",
      "dArr;": "\u21D3",
      "darr;": "\u2193",
      "dash;": "\u2010",
      "dHar;": "\u2965",
      "diam;": "\u22C4",
      "DJcy;": "\u0402",
      "djcy;": "\u0452",
      "Dopf;": "\u{1D53B}",
      "dopf;": "\u{1D555}",
      "Dscr;": "\u{1D49F}",
      "dscr;": "\u{1D4B9}",
      "DScy;": "\u0405",
      "dscy;": "\u0455",
      "dsol;": "\u29F6",
      "dtri;": "\u25BF",
      "DZcy;": "\u040F",
      "dzcy;": "\u045F",
      "ecir;": "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      "Edot;": "\u0116",
      "eDot;": "\u2251",
      "edot;": "\u0117",
      "emsp;": "\u2003",
      "ensp;": "\u2002",
      "Eopf;": "\u{1D53C}",
      "eopf;": "\u{1D556}",
      "epar;": "\u22D5",
      "epsi;": "\u03B5",
      "Escr;": "\u2130",
      "escr;": "\u212F",
      "Esim;": "\u2A73",
      "esim;": "\u2242",
      "Euml;": "\xCB",
      "euml;": "\xEB",
      "euro;": "\u20AC",
      "excl;": "!",
      "flat;": "\u266D",
      "fnof;": "\u0192",
      "Fopf;": "\u{1D53D}",
      "fopf;": "\u{1D557}",
      "fork;": "\u22D4",
      "Fscr;": "\u2131",
      "fscr;": "\u{1D4BB}",
      "Gdot;": "\u0120",
      "gdot;": "\u0121",
      "geqq;": "\u2267",
      "gesl;": "\u22DB\uFE00",
      "GJcy;": "\u0403",
      "gjcy;": "\u0453",
      "gnap;": "\u2A8A",
      "gneq;": "\u2A88",
      "Gopf;": "\u{1D53E}",
      "gopf;": "\u{1D558}",
      "Gscr;": "\u{1D4A2}",
      "gscr;": "\u210A",
      "gsim;": "\u2273",
      "gtcc;": "\u2AA7",
      "gvnE;": "\u2269\uFE00",
      "half;": "\xBD",
      "hArr;": "\u21D4",
      "harr;": "\u2194",
      "hbar;": "\u210F",
      "Hopf;": "\u210D",
      "hopf;": "\u{1D559}",
      "Hscr;": "\u210B",
      "hscr;": "\u{1D4BD}",
      Icirc: "\xCE",
      icirc: "\xEE",
      "Idot;": "\u0130",
      "IEcy;": "\u0415",
      "iecy;": "\u0435",
      iexcl: "\xA1",
      "imof;": "\u22B7",
      "IOcy;": "\u0401",
      "iocy;": "\u0451",
      "Iopf;": "\u{1D540}",
      "iopf;": "\u{1D55A}",
      "Iota;": "\u0399",
      "iota;": "\u03B9",
      "Iscr;": "\u2110",
      "iscr;": "\u{1D4BE}",
      "isin;": "\u2208",
      "Iuml;": "\xCF",
      "iuml;": "\xEF",
      "Jopf;": "\u{1D541}",
      "jopf;": "\u{1D55B}",
      "Jscr;": "\u{1D4A5}",
      "jscr;": "\u{1D4BF}",
      "KHcy;": "\u0425",
      "khcy;": "\u0445",
      "KJcy;": "\u040C",
      "kjcy;": "\u045C",
      "Kopf;": "\u{1D542}",
      "kopf;": "\u{1D55C}",
      "Kscr;": "\u{1D4A6}",
      "kscr;": "\u{1D4C0}",
      "Lang;": "\u27EA",
      "lang;": "\u27E8",
      laquo: "\xAB",
      "Larr;": "\u219E",
      "lArr;": "\u21D0",
      "larr;": "\u2190",
      "late;": "\u2AAD",
      "lcub;": "{",
      "ldca;": "\u2936",
      "ldsh;": "\u21B2",
      "leqq;": "\u2266",
      "lesg;": "\u22DA\uFE00",
      "lHar;": "\u2962",
      "LJcy;": "\u0409",
      "ljcy;": "\u0459",
      "lnap;": "\u2A89",
      "lneq;": "\u2A87",
      "Lopf;": "\u{1D543}",
      "lopf;": "\u{1D55D}",
      "lozf;": "\u29EB",
      "lpar;": "(",
      "Lscr;": "\u2112",
      "lscr;": "\u{1D4C1}",
      "lsim;": "\u2272",
      "lsqb;": "[",
      "ltcc;": "\u2AA6",
      "ltri;": "\u25C3",
      "lvnE;": "\u2268\uFE00",
      "macr;": "\xAF",
      "male;": "\u2642",
      "malt;": "\u2720",
      micro: "\xB5",
      "mlcp;": "\u2ADB",
      "mldr;": "\u2026",
      "Mopf;": "\u{1D544}",
      "mopf;": "\u{1D55E}",
      "Mscr;": "\u2133",
      "mscr;": "\u{1D4C2}",
      "nang;": "\u2220\u20D2",
      "napE;": "\u2A70\u0338",
      "nbsp;": "\xA0",
      "ncap;": "\u2A43",
      "ncup;": "\u2A42",
      "ngeq;": "\u2271",
      "nges;": "\u2A7E\u0338",
      "ngtr;": "\u226F",
      "nGtv;": "\u226B\u0338",
      "nisd;": "\u22FA",
      "NJcy;": "\u040A",
      "njcy;": "\u045A",
      "nldr;": "\u2025",
      "nleq;": "\u2270",
      "nles;": "\u2A7D\u0338",
      "nLtv;": "\u226A\u0338",
      "nmid;": "\u2224",
      "Nopf;": "\u2115",
      "nopf;": "\u{1D55F}",
      "npar;": "\u2226",
      "npre;": "\u2AAF\u0338",
      "nsce;": "\u2AB0\u0338",
      "Nscr;": "\u{1D4A9}",
      "nscr;": "\u{1D4C3}",
      "nsim;": "\u2241",
      "nsub;": "\u2284",
      "nsup;": "\u2285",
      "ntgl;": "\u2279",
      "ntlg;": "\u2278",
      "nvap;": "\u224D\u20D2",
      "nvge;": "\u2265\u20D2",
      "nvgt;": ">\u20D2",
      "nvle;": "\u2264\u20D2",
      "nvlt;": "<\u20D2",
      "oast;": "\u229B",
      "ocir;": "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      "odiv;": "\u2A38",
      "odot;": "\u2299",
      "ogon;": "\u02DB",
      "oint;": "\u222E",
      "omid;": "\u29B6",
      "Oopf;": "\u{1D546}",
      "oopf;": "\u{1D560}",
      "opar;": "\u29B7",
      "ordf;": "\xAA",
      "ordm;": "\xBA",
      "oror;": "\u2A56",
      "Oscr;": "\u{1D4AA}",
      "oscr;": "\u2134",
      "osol;": "\u2298",
      "Ouml;": "\xD6",
      "ouml;": "\xF6",
      "para;": "\xB6",
      "part;": "\u2202",
      "perp;": "\u22A5",
      "phiv;": "\u03D5",
      "plus;": "+",
      "Popf;": "\u2119",
      "popf;": "\u{1D561}",
      pound: "\xA3",
      "prap;": "\u2AB7",
      "prec;": "\u227A",
      "prnE;": "\u2AB5",
      "prod;": "\u220F",
      "prop;": "\u221D",
      "Pscr;": "\u{1D4AB}",
      "pscr;": "\u{1D4C5}",
      "qint;": "\u2A0C",
      "Qopf;": "\u211A",
      "qopf;": "\u{1D562}",
      "Qscr;": "\u{1D4AC}",
      "qscr;": "\u{1D4C6}",
      "QUOT;": '"',
      "quot;": '"',
      "race;": "\u223D\u0331",
      "Rang;": "\u27EB",
      "rang;": "\u27E9",
      raquo: "\xBB",
      "Rarr;": "\u21A0",
      "rArr;": "\u21D2",
      "rarr;": "\u2192",
      "rcub;": "}",
      "rdca;": "\u2937",
      "rdsh;": "\u21B3",
      "real;": "\u211C",
      "rect;": "\u25AD",
      "rHar;": "\u2964",
      "rhov;": "\u03F1",
      "ring;": "\u02DA",
      "Ropf;": "\u211D",
      "ropf;": "\u{1D563}",
      "rpar;": ")",
      "Rscr;": "\u211B",
      "rscr;": "\u{1D4C7}",
      "rsqb;": "]",
      "rtri;": "\u25B9",
      "scap;": "\u2AB8",
      "scnE;": "\u2AB6",
      "sdot;": "\u22C5",
      "sect;": "\xA7",
      "semi;": ";",
      "sext;": "\u2736",
      "SHcy;": "\u0428",
      "shcy;": "\u0448",
      "sime;": "\u2243",
      "simg;": "\u2A9E",
      "siml;": "\u2A9D",
      "smid;": "\u2223",
      "smte;": "\u2AAC",
      "solb;": "\u29C4",
      "Sopf;": "\u{1D54A}",
      "sopf;": "\u{1D564}",
      "spar;": "\u2225",
      "Sqrt;": "\u221A",
      "squf;": "\u25AA",
      "Sscr;": "\u{1D4AE}",
      "sscr;": "\u{1D4C8}",
      "Star;": "\u22C6",
      "star;": "\u2606",
      "subE;": "\u2AC5",
      "sube;": "\u2286",
      "succ;": "\u227B",
      "sung;": "\u266A",
      "sup1;": "\xB9",
      "sup2;": "\xB2",
      "sup3;": "\xB3",
      "supE;": "\u2AC6",
      "supe;": "\u2287",
      szlig: "\xDF",
      "tbrk;": "\u23B4",
      "tdot;": "\u20DB",
      THORN: "\xDE",
      thorn: "\xFE",
      times: "\xD7",
      "tint;": "\u222D",
      "toea;": "\u2928",
      "Topf;": "\u{1D54B}",
      "topf;": "\u{1D565}",
      "tosa;": "\u2929",
      "trie;": "\u225C",
      "Tscr;": "\u{1D4AF}",
      "tscr;": "\u{1D4C9}",
      "TScy;": "\u0426",
      "tscy;": "\u0446",
      "Uarr;": "\u219F",
      "uArr;": "\u21D1",
      "uarr;": "\u2191",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      "uHar;": "\u2963",
      "Uopf;": "\u{1D54C}",
      "uopf;": "\u{1D566}",
      "Upsi;": "\u03D2",
      "upsi;": "\u03C5",
      "Uscr;": "\u{1D4B0}",
      "uscr;": "\u{1D4CA}",
      "utri;": "\u25B5",
      "Uuml;": "\xDC",
      "uuml;": "\xFC",
      "vArr;": "\u21D5",
      "varr;": "\u2195",
      "Vbar;": "\u2AEB",
      "vBar;": "\u2AE8",
      "Vert;": "\u2016",
      "vert;": "|",
      "Vopf;": "\u{1D54D}",
      "vopf;": "\u{1D567}",
      "Vscr;": "\u{1D4B1}",
      "vscr;": "\u{1D4CB}",
      "Wopf;": "\u{1D54E}",
      "wopf;": "\u{1D568}",
      "Wscr;": "\u{1D4B2}",
      "wscr;": "\u{1D4CC}",
      "xcap;": "\u22C2",
      "xcup;": "\u22C3",
      "xmap;": "\u27FC",
      "xnis;": "\u22FB",
      "Xopf;": "\u{1D54F}",
      "xopf;": "\u{1D569}",
      "Xscr;": "\u{1D4B3}",
      "xscr;": "\u{1D4CD}",
      "xvee;": "\u22C1",
      "YAcy;": "\u042F",
      "yacy;": "\u044F",
      "YIcy;": "\u0407",
      "yicy;": "\u0457",
      "Yopf;": "\u{1D550}",
      "yopf;": "\u{1D56A}",
      "Yscr;": "\u{1D4B4}",
      "yscr;": "\u{1D4CE}",
      "YUcy;": "\u042E",
      "yucy;": "\u044E",
      "Yuml;": "\u0178",
      "yuml;": "\xFF",
      "Zdot;": "\u017B",
      "zdot;": "\u017C",
      "Zeta;": "\u0396",
      "zeta;": "\u03B6",
      "ZHcy;": "\u0416",
      "zhcy;": "\u0436",
      "Zopf;": "\u2124",
      "zopf;": "\u{1D56B}",
      "Zscr;": "\u{1D4B5}",
      "zscr;": "\u{1D4CF}",
      "zwnj;": "\u200C",
      Aacute: "\xC1",
      aacute: "\xE1",
      "Acirc;": "\xC2",
      "acirc;": "\xE2",
      "acute;": "\xB4",
      "AElig;": "\xC6",
      "aelig;": "\xE6",
      Agrave: "\xC0",
      agrave: "\xE0",
      "aleph;": "\u2135",
      "Alpha;": "\u0391",
      "alpha;": "\u03B1",
      "Amacr;": "\u0100",
      "amacr;": "\u0101",
      "amalg;": "\u2A3F",
      "angle;": "\u2220",
      "angrt;": "\u221F",
      "angst;": "\xC5",
      "Aogon;": "\u0104",
      "aogon;": "\u0105",
      "Aring;": "\xC5",
      "aring;": "\xE5",
      "asymp;": "\u2248",
      Atilde: "\xC3",
      atilde: "\xE3",
      "awint;": "\u2A11",
      "bcong;": "\u224C",
      "bdquo;": "\u201E",
      "bepsi;": "\u03F6",
      "blank;": "\u2423",
      "blk12;": "\u2592",
      "blk14;": "\u2591",
      "blk34;": "\u2593",
      "block;": "\u2588",
      "boxDL;": "\u2557",
      "boxDl;": "\u2556",
      "boxdL;": "\u2555",
      "boxdl;": "\u2510",
      "boxDR;": "\u2554",
      "boxDr;": "\u2553",
      "boxdR;": "\u2552",
      "boxdr;": "\u250C",
      "boxHD;": "\u2566",
      "boxHd;": "\u2564",
      "boxhD;": "\u2565",
      "boxhd;": "\u252C",
      "boxHU;": "\u2569",
      "boxHu;": "\u2567",
      "boxhU;": "\u2568",
      "boxhu;": "\u2534",
      "boxUL;": "\u255D",
      "boxUl;": "\u255C",
      "boxuL;": "\u255B",
      "boxul;": "\u2518",
      "boxUR;": "\u255A",
      "boxUr;": "\u2559",
      "boxuR;": "\u2558",
      "boxur;": "\u2514",
      "boxVH;": "\u256C",
      "boxVh;": "\u256B",
      "boxvH;": "\u256A",
      "boxvh;": "\u253C",
      "boxVL;": "\u2563",
      "boxVl;": "\u2562",
      "boxvL;": "\u2561",
      "boxvl;": "\u2524",
      "boxVR;": "\u2560",
      "boxVr;": "\u255F",
      "boxvR;": "\u255E",
      "boxvr;": "\u251C",
      "Breve;": "\u02D8",
      "breve;": "\u02D8",
      brvbar: "\xA6",
      "bsemi;": "\u204F",
      "bsime;": "\u22CD",
      "bsolb;": "\u29C5",
      "bumpE;": "\u2AAE",
      "bumpe;": "\u224F",
      "caret;": "\u2041",
      "caron;": "\u02C7",
      "ccaps;": "\u2A4D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      "Ccirc;": "\u0108",
      "ccirc;": "\u0109",
      "ccups;": "\u2A4C",
      "cedil;": "\xB8",
      "check;": "\u2713",
      "clubs;": "\u2663",
      "Colon;": "\u2237",
      "colon;": ":",
      "comma;": ",",
      "crarr;": "\u21B5",
      "Cross;": "\u2A2F",
      "cross;": "\u2717",
      "csube;": "\u2AD1",
      "csupe;": "\u2AD2",
      "ctdot;": "\u22EF",
      "cuepr;": "\u22DE",
      "cuesc;": "\u22DF",
      "cupor;": "\u2A45",
      curren: "\xA4",
      "cuvee;": "\u22CE",
      "cuwed;": "\u22CF",
      "cwint;": "\u2231",
      "Dashv;": "\u2AE4",
      "dashv;": "\u22A3",
      "dblac;": "\u02DD",
      "ddarr;": "\u21CA",
      "Delta;": "\u0394",
      "delta;": "\u03B4",
      "dharl;": "\u21C3",
      "dharr;": "\u21C2",
      "diams;": "\u2666",
      "disin;": "\u22F2",
      divide: "\xF7",
      "doteq;": "\u2250",
      "dtdot;": "\u22F1",
      "dtrif;": "\u25BE",
      "duarr;": "\u21F5",
      "duhar;": "\u296F",
      Eacute: "\xC9",
      eacute: "\xE9",
      "Ecirc;": "\xCA",
      "ecirc;": "\xEA",
      "eDDot;": "\u2A77",
      "efDot;": "\u2252",
      Egrave: "\xC8",
      egrave: "\xE8",
      "Emacr;": "\u0112",
      "emacr;": "\u0113",
      "empty;": "\u2205",
      "Eogon;": "\u0118",
      "eogon;": "\u0119",
      "eplus;": "\u2A71",
      "epsiv;": "\u03F5",
      "eqsim;": "\u2242",
      "Equal;": "\u2A75",
      "equiv;": "\u2261",
      "erarr;": "\u2971",
      "erDot;": "\u2253",
      "esdot;": "\u2250",
      "exist;": "\u2203",
      "fflig;": "\uFB00",
      "filig;": "\uFB01",
      "fjlig;": "fj",
      "fllig;": "\uFB02",
      "fltns;": "\u25B1",
      "forkv;": "\u2AD9",
      frac12: "\xBD",
      frac14: "\xBC",
      frac34: "\xBE",
      "frasl;": "\u2044",
      "frown;": "\u2322",
      "Gamma;": "\u0393",
      "gamma;": "\u03B3",
      "Gcirc;": "\u011C",
      "gcirc;": "\u011D",
      "gescc;": "\u2AA9",
      "gimel;": "\u2137",
      "gneqq;": "\u2269",
      "gnsim;": "\u22E7",
      "grave;": "`",
      "gsime;": "\u2A8E",
      "gsiml;": "\u2A90",
      "gtcir;": "\u2A7A",
      "gtdot;": "\u22D7",
      "Hacek;": "\u02C7",
      "harrw;": "\u21AD",
      "Hcirc;": "\u0124",
      "hcirc;": "\u0125",
      "hoarr;": "\u21FF",
      Iacute: "\xCD",
      iacute: "\xED",
      "Icirc;": "\xCE",
      "icirc;": "\xEE",
      "iexcl;": "\xA1",
      Igrave: "\xCC",
      igrave: "\xEC",
      "iiint;": "\u222D",
      "iiota;": "\u2129",
      "IJlig;": "\u0132",
      "ijlig;": "\u0133",
      "Imacr;": "\u012A",
      "imacr;": "\u012B",
      "image;": "\u2111",
      "imath;": "\u0131",
      "imped;": "\u01B5",
      "infin;": "\u221E",
      "Iogon;": "\u012E",
      "iogon;": "\u012F",
      "iprod;": "\u2A3C",
      iquest: "\xBF",
      "isinE;": "\u22F9",
      "isins;": "\u22F4",
      "isinv;": "\u2208",
      "Iukcy;": "\u0406",
      "iukcy;": "\u0456",
      "Jcirc;": "\u0134",
      "jcirc;": "\u0135",
      "jmath;": "\u0237",
      "Jukcy;": "\u0404",
      "jukcy;": "\u0454",
      "Kappa;": "\u039A",
      "kappa;": "\u03BA",
      "lAarr;": "\u21DA",
      "langd;": "\u2991",
      "laquo;": "\xAB",
      "larrb;": "\u21E4",
      "lates;": "\u2AAD\uFE00",
      "lBarr;": "\u290E",
      "lbarr;": "\u290C",
      "lbbrk;": "\u2772",
      "lbrke;": "\u298B",
      "lceil;": "\u2308",
      "ldquo;": "\u201C",
      "lescc;": "\u2AA8",
      "lhard;": "\u21BD",
      "lharu;": "\u21BC",
      "lhblk;": "\u2584",
      "llarr;": "\u21C7",
      "lltri;": "\u25FA",
      "lneqq;": "\u2268",
      "lnsim;": "\u22E6",
      "loang;": "\u27EC",
      "loarr;": "\u21FD",
      "lobrk;": "\u27E6",
      "lopar;": "\u2985",
      "lrarr;": "\u21C6",
      "lrhar;": "\u21CB",
      "lrtri;": "\u22BF",
      "lsime;": "\u2A8D",
      "lsimg;": "\u2A8F",
      "lsquo;": "\u2018",
      "ltcir;": "\u2A79",
      "ltdot;": "\u22D6",
      "ltrie;": "\u22B4",
      "ltrif;": "\u25C2",
      "mdash;": "\u2014",
      "mDDot;": "\u223A",
      "micro;": "\xB5",
      middot: "\xB7",
      "minus;": "\u2212",
      "mumap;": "\u22B8",
      "nabla;": "\u2207",
      "napid;": "\u224B\u0338",
      "napos;": "\u0149",
      "natur;": "\u266E",
      "nbump;": "\u224E\u0338",
      "ncong;": "\u2247",
      "ndash;": "\u2013",
      "neArr;": "\u21D7",
      "nearr;": "\u2197",
      "nedot;": "\u2250\u0338",
      "nesim;": "\u2242\u0338",
      "ngeqq;": "\u2267\u0338",
      "ngsim;": "\u2275",
      "nhArr;": "\u21CE",
      "nharr;": "\u21AE",
      "nhpar;": "\u2AF2",
      "nlArr;": "\u21CD",
      "nlarr;": "\u219A",
      "nleqq;": "\u2266\u0338",
      "nless;": "\u226E",
      "nlsim;": "\u2274",
      "nltri;": "\u22EA",
      "notin;": "\u2209",
      "notni;": "\u220C",
      "npart;": "\u2202\u0338",
      "nprec;": "\u2280",
      "nrArr;": "\u21CF",
      "nrarr;": "\u219B",
      "nrtri;": "\u22EB",
      "nsime;": "\u2244",
      "nsmid;": "\u2224",
      "nspar;": "\u2226",
      "nsubE;": "\u2AC5\u0338",
      "nsube;": "\u2288",
      "nsucc;": "\u2281",
      "nsupE;": "\u2AC6\u0338",
      "nsupe;": "\u2289",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      "numsp;": "\u2007",
      "nvsim;": "\u223C\u20D2",
      "nwArr;": "\u21D6",
      "nwarr;": "\u2196",
      Oacute: "\xD3",
      oacute: "\xF3",
      "Ocirc;": "\xD4",
      "ocirc;": "\xF4",
      "odash;": "\u229D",
      "OElig;": "\u0152",
      "oelig;": "\u0153",
      "ofcir;": "\u29BF",
      Ograve: "\xD2",
      ograve: "\xF2",
      "ohbar;": "\u29B5",
      "olarr;": "\u21BA",
      "olcir;": "\u29BE",
      "oline;": "\u203E",
      "Omacr;": "\u014C",
      "omacr;": "\u014D",
      "Omega;": "\u03A9",
      "omega;": "\u03C9",
      "operp;": "\u29B9",
      "oplus;": "\u2295",
      "orarr;": "\u21BB",
      "order;": "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      Otilde: "\xD5",
      otilde: "\xF5",
      "ovbar;": "\u233D",
      "parsl;": "\u2AFD",
      "phone;": "\u260E",
      "plusb;": "\u229E",
      "pluse;": "\u2A72",
      plusmn: "\xB1",
      "pound;": "\xA3",
      "prcue;": "\u227C",
      "Prime;": "\u2033",
      "prime;": "\u2032",
      "prnap;": "\u2AB9",
      "prsim;": "\u227E",
      "quest;": "?",
      "rAarr;": "\u21DB",
      "radic;": "\u221A",
      "rangd;": "\u2992",
      "range;": "\u29A5",
      "raquo;": "\xBB",
      "rarrb;": "\u21E5",
      "rarrc;": "\u2933",
      "rarrw;": "\u219D",
      "ratio;": "\u2236",
      "RBarr;": "\u2910",
      "rBarr;": "\u290F",
      "rbarr;": "\u290D",
      "rbbrk;": "\u2773",
      "rbrke;": "\u298C",
      "rceil;": "\u2309",
      "rdquo;": "\u201D",
      "reals;": "\u211D",
      "rhard;": "\u21C1",
      "rharu;": "\u21C0",
      "rlarr;": "\u21C4",
      "rlhar;": "\u21CC",
      "rnmid;": "\u2AEE",
      "roang;": "\u27ED",
      "roarr;": "\u21FE",
      "robrk;": "\u27E7",
      "ropar;": "\u2986",
      "rrarr;": "\u21C9",
      "rsquo;": "\u2019",
      "rtrie;": "\u22B5",
      "rtrif;": "\u25B8",
      "sbquo;": "\u201A",
      "sccue;": "\u227D",
      "Scirc;": "\u015C",
      "scirc;": "\u015D",
      "scnap;": "\u2ABA",
      "scsim;": "\u227F",
      "sdotb;": "\u22A1",
      "sdote;": "\u2A66",
      "seArr;": "\u21D8",
      "searr;": "\u2198",
      "setmn;": "\u2216",
      "sharp;": "\u266F",
      "Sigma;": "\u03A3",
      "sigma;": "\u03C3",
      "simeq;": "\u2243",
      "simgE;": "\u2AA0",
      "simlE;": "\u2A9F",
      "simne;": "\u2246",
      "slarr;": "\u2190",
      "smile;": "\u2323",
      "smtes;": "\u2AAC\uFE00",
      "sqcap;": "\u2293",
      "sqcup;": "\u2294",
      "sqsub;": "\u228F",
      "sqsup;": "\u2290",
      "srarr;": "\u2192",
      "starf;": "\u2605",
      "strns;": "\xAF",
      "subnE;": "\u2ACB",
      "subne;": "\u228A",
      "supnE;": "\u2ACC",
      "supne;": "\u228B",
      "swArr;": "\u21D9",
      "swarr;": "\u2199",
      "szlig;": "\xDF",
      "Theta;": "\u0398",
      "theta;": "\u03B8",
      "thkap;": "\u2248",
      "THORN;": "\xDE",
      "thorn;": "\xFE",
      "Tilde;": "\u223C",
      "tilde;": "\u02DC",
      "times;": "\xD7",
      "TRADE;": "\u2122",
      "trade;": "\u2122",
      "trisb;": "\u29CD",
      "TSHcy;": "\u040B",
      "tshcy;": "\u045B",
      "twixt;": "\u226C",
      Uacute: "\xDA",
      uacute: "\xFA",
      "Ubrcy;": "\u040E",
      "ubrcy;": "\u045E",
      "Ucirc;": "\xDB",
      "ucirc;": "\xFB",
      "udarr;": "\u21C5",
      "udhar;": "\u296E",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      "uharl;": "\u21BF",
      "uharr;": "\u21BE",
      "uhblk;": "\u2580",
      "ultri;": "\u25F8",
      "Umacr;": "\u016A",
      "umacr;": "\u016B",
      "Union;": "\u22C3",
      "Uogon;": "\u0172",
      "uogon;": "\u0173",
      "uplus;": "\u228E",
      "upsih;": "\u03D2",
      "UpTee;": "\u22A5",
      "Uring;": "\u016E",
      "uring;": "\u016F",
      "urtri;": "\u25F9",
      "utdot;": "\u22F0",
      "utrif;": "\u25B4",
      "uuarr;": "\u21C8",
      "varpi;": "\u03D6",
      "vBarv;": "\u2AE9",
      "VDash;": "\u22AB",
      "Vdash;": "\u22A9",
      "vDash;": "\u22A8",
      "vdash;": "\u22A2",
      "veeeq;": "\u225A",
      "vltri;": "\u22B2",
      "vnsub;": "\u2282\u20D2",
      "vnsup;": "\u2283\u20D2",
      "vprop;": "\u221D",
      "vrtri;": "\u22B3",
      "Wcirc;": "\u0174",
      "wcirc;": "\u0175",
      "Wedge;": "\u22C0",
      "wedge;": "\u2227",
      "xcirc;": "\u25EF",
      "xdtri;": "\u25BD",
      "xhArr;": "\u27FA",
      "xharr;": "\u27F7",
      "xlArr;": "\u27F8",
      "xlarr;": "\u27F5",
      "xodot;": "\u2A00",
      "xrArr;": "\u27F9",
      "xrarr;": "\u27F6",
      "xutri;": "\u25B3",
      Yacute: "\xDD",
      yacute: "\xFD",
      "Ycirc;": "\u0176",
      "ycirc;": "\u0177",
      "Aacute;": "\xC1",
      "aacute;": "\xE1",
      "Abreve;": "\u0102",
      "abreve;": "\u0103",
      "Agrave;": "\xC0",
      "agrave;": "\xE0",
      "andand;": "\u2A55",
      "angmsd;": "\u2221",
      "angsph;": "\u2222",
      "apacir;": "\u2A6F",
      "approx;": "\u2248",
      "Assign;": "\u2254",
      "Atilde;": "\xC3",
      "atilde;": "\xE3",
      "barvee;": "\u22BD",
      "Barwed;": "\u2306",
      "barwed;": "\u2305",
      "becaus;": "\u2235",
      "bernou;": "\u212C",
      "bigcap;": "\u22C2",
      "bigcup;": "\u22C3",
      "bigvee;": "\u22C1",
      "bkarow;": "\u290D",
      "bottom;": "\u22A5",
      "bowtie;": "\u22C8",
      "boxbox;": "\u29C9",
      "bprime;": "\u2035",
      "brvbar;": "\xA6",
      "bullet;": "\u2022",
      "Bumpeq;": "\u224E",
      "bumpeq;": "\u224F",
      "Cacute;": "\u0106",
      "cacute;": "\u0107",
      "capand;": "\u2A44",
      "capcap;": "\u2A4B",
      "capcup;": "\u2A47",
      "capdot;": "\u2A40",
      "Ccaron;": "\u010C",
      "ccaron;": "\u010D",
      "Ccedil;": "\xC7",
      "ccedil;": "\xE7",
      "circeq;": "\u2257",
      "cirmid;": "\u2AEF",
      "Colone;": "\u2A74",
      "colone;": "\u2254",
      "commat;": "@",
      "compfn;": "\u2218",
      "Conint;": "\u222F",
      "conint;": "\u222E",
      "coprod;": "\u2210",
      "copysr;": "\u2117",
      "cularr;": "\u21B6",
      "CupCap;": "\u224D",
      "cupcap;": "\u2A46",
      "cupcup;": "\u2A4A",
      "cupdot;": "\u228D",
      "curarr;": "\u21B7",
      "curren;": "\xA4",
      "cylcty;": "\u232D",
      "Dagger;": "\u2021",
      "dagger;": "\u2020",
      "daleth;": "\u2138",
      "Dcaron;": "\u010E",
      "dcaron;": "\u010F",
      "dfisht;": "\u297F",
      "divide;": "\xF7",
      "divonx;": "\u22C7",
      "dlcorn;": "\u231E",
      "dlcrop;": "\u230D",
      "dollar;": "$",
      "DotDot;": "\u20DC",
      "drcorn;": "\u231F",
      "drcrop;": "\u230C",
      "Dstrok;": "\u0110",
      "dstrok;": "\u0111",
      "Eacute;": "\xC9",
      "eacute;": "\xE9",
      "easter;": "\u2A6E",
      "Ecaron;": "\u011A",
      "ecaron;": "\u011B",
      "ecolon;": "\u2255",
      "Egrave;": "\xC8",
      "egrave;": "\xE8",
      "egsdot;": "\u2A98",
      "elsdot;": "\u2A97",
      "emptyv;": "\u2205",
      "emsp13;": "\u2004",
      "emsp14;": "\u2005",
      "eparsl;": "\u29E3",
      "eqcirc;": "\u2256",
      "equals;": "=",
      "equest;": "\u225F",
      "Exists;": "\u2203",
      "female;": "\u2640",
      "ffilig;": "\uFB03",
      "ffllig;": "\uFB04",
      "ForAll;": "\u2200",
      "forall;": "\u2200",
      "frac12;": "\xBD",
      "frac13;": "\u2153",
      "frac14;": "\xBC",
      "frac15;": "\u2155",
      "frac16;": "\u2159",
      "frac18;": "\u215B",
      "frac23;": "\u2154",
      "frac25;": "\u2156",
      "frac34;": "\xBE",
      "frac35;": "\u2157",
      "frac38;": "\u215C",
      "frac45;": "\u2158",
      "frac56;": "\u215A",
      "frac58;": "\u215D",
      "frac78;": "\u215E",
      "gacute;": "\u01F5",
      "Gammad;": "\u03DC",
      "gammad;": "\u03DD",
      "Gbreve;": "\u011E",
      "gbreve;": "\u011F",
      "Gcedil;": "\u0122",
      "gesdot;": "\u2A80",
      "gesles;": "\u2A94",
      "gtlPar;": "\u2995",
      "gtrarr;": "\u2978",
      "gtrdot;": "\u22D7",
      "gtrsim;": "\u2273",
      "hairsp;": "\u200A",
      "hamilt;": "\u210B",
      "HARDcy;": "\u042A",
      "hardcy;": "\u044A",
      "hearts;": "\u2665",
      "hellip;": "\u2026",
      "hercon;": "\u22B9",
      "homtht;": "\u223B",
      "horbar;": "\u2015",
      "hslash;": "\u210F",
      "Hstrok;": "\u0126",
      "hstrok;": "\u0127",
      "hybull;": "\u2043",
      "hyphen;": "\u2010",
      "Iacute;": "\xCD",
      "iacute;": "\xED",
      "Igrave;": "\xCC",
      "igrave;": "\xEC",
      "iiiint;": "\u2A0C",
      "iinfin;": "\u29DC",
      "incare;": "\u2105",
      "inodot;": "\u0131",
      "intcal;": "\u22BA",
      "iquest;": "\xBF",
      "isinsv;": "\u22F3",
      "Itilde;": "\u0128",
      "itilde;": "\u0129",
      "Jsercy;": "\u0408",
      "jsercy;": "\u0458",
      "kappav;": "\u03F0",
      "Kcedil;": "\u0136",
      "kcedil;": "\u0137",
      "kgreen;": "\u0138",
      "Lacute;": "\u0139",
      "lacute;": "\u013A",
      "lagran;": "\u2112",
      "Lambda;": "\u039B",
      "lambda;": "\u03BB",
      "langle;": "\u27E8",
      "larrfs;": "\u291D",
      "larrhk;": "\u21A9",
      "larrlp;": "\u21AB",
      "larrpl;": "\u2939",
      "larrtl;": "\u21A2",
      "lAtail;": "\u291B",
      "latail;": "\u2919",
      "lbrace;": "{",
      "lbrack;": "[",
      "Lcaron;": "\u013D",
      "lcaron;": "\u013E",
      "Lcedil;": "\u013B",
      "lcedil;": "\u013C",
      "ldquor;": "\u201E",
      "lesdot;": "\u2A7F",
      "lesges;": "\u2A93",
      "lfisht;": "\u297C",
      "lfloor;": "\u230A",
      "lharul;": "\u296A",
      "llhard;": "\u296B",
      "Lmidot;": "\u013F",
      "lmidot;": "\u0140",
      "lmoust;": "\u23B0",
      "loplus;": "\u2A2D",
      "lowast;": "\u2217",
      "lowbar;": "_",
      "lparlt;": "\u2993",
      "lrhard;": "\u296D",
      "lsaquo;": "\u2039",
      "lsquor;": "\u201A",
      "Lstrok;": "\u0141",
      "lstrok;": "\u0142",
      "lthree;": "\u22CB",
      "ltimes;": "\u22C9",
      "ltlarr;": "\u2976",
      "ltrPar;": "\u2996",
      "mapsto;": "\u21A6",
      "marker;": "\u25AE",
      "mcomma;": "\u2A29",
      "midast;": "*",
      "midcir;": "\u2AF0",
      "middot;": "\xB7",
      "minusb;": "\u229F",
      "minusd;": "\u2238",
      "mnplus;": "\u2213",
      "models;": "\u22A7",
      "mstpos;": "\u223E",
      "Nacute;": "\u0143",
      "nacute;": "\u0144",
      "nbumpe;": "\u224F\u0338",
      "Ncaron;": "\u0147",
      "ncaron;": "\u0148",
      "Ncedil;": "\u0145",
      "ncedil;": "\u0146",
      "nearhk;": "\u2924",
      "nequiv;": "\u2262",
      "nesear;": "\u2928",
      "nexist;": "\u2204",
      "nltrie;": "\u22EC",
      "notinE;": "\u22F9\u0338",
      "nparsl;": "\u2AFD\u20E5",
      "nprcue;": "\u22E0",
      "nrarrc;": "\u2933\u0338",
      "nrarrw;": "\u219D\u0338",
      "nrtrie;": "\u22ED",
      "nsccue;": "\u22E1",
      "nsimeq;": "\u2244",
      "Ntilde;": "\xD1",
      "ntilde;": "\xF1",
      "numero;": "\u2116",
      "nVDash;": "\u22AF",
      "nVdash;": "\u22AE",
      "nvDash;": "\u22AD",
      "nvdash;": "\u22AC",
      "nvHarr;": "\u2904",
      "nvlArr;": "\u2902",
      "nvrArr;": "\u2903",
      "nwarhk;": "\u2923",
      "nwnear;": "\u2927",
      "Oacute;": "\xD3",
      "oacute;": "\xF3",
      "Odblac;": "\u0150",
      "odblac;": "\u0151",
      "odsold;": "\u29BC",
      "Ograve;": "\xD2",
      "ograve;": "\xF2",
      "ominus;": "\u2296",
      "origof;": "\u22B6",
      "Oslash;": "\xD8",
      "oslash;": "\xF8",
      "Otilde;": "\xD5",
      "otilde;": "\xF5",
      "Otimes;": "\u2A37",
      "otimes;": "\u2297",
      "parsim;": "\u2AF3",
      "percnt;": "%",
      "period;": ".",
      "permil;": "\u2030",
      "phmmat;": "\u2133",
      "planck;": "\u210F",
      "plankv;": "\u210F",
      "plusdo;": "\u2214",
      "plusdu;": "\u2A25",
      "plusmn;": "\xB1",
      "preceq;": "\u2AAF",
      "primes;": "\u2119",
      "prnsim;": "\u22E8",
      "propto;": "\u221D",
      "prurel;": "\u22B0",
      "puncsp;": "\u2008",
      "qprime;": "\u2057",
      "Racute;": "\u0154",
      "racute;": "\u0155",
      "rangle;": "\u27E9",
      "rarrap;": "\u2975",
      "rarrfs;": "\u291E",
      "rarrhk;": "\u21AA",
      "rarrlp;": "\u21AC",
      "rarrpl;": "\u2945",
      "Rarrtl;": "\u2916",
      "rarrtl;": "\u21A3",
      "rAtail;": "\u291C",
      "ratail;": "\u291A",
      "rbrace;": "}",
      "rbrack;": "]",
      "Rcaron;": "\u0158",
      "rcaron;": "\u0159",
      "Rcedil;": "\u0156",
      "rcedil;": "\u0157",
      "rdquor;": "\u201D",
      "rfisht;": "\u297D",
      "rfloor;": "\u230B",
      "rharul;": "\u296C",
      "rmoust;": "\u23B1",
      "roplus;": "\u2A2E",
      "rpargt;": "\u2994",
      "rsaquo;": "\u203A",
      "rsquor;": "\u2019",
      "rthree;": "\u22CC",
      "rtimes;": "\u22CA",
      "Sacute;": "\u015A",
      "sacute;": "\u015B",
      "Scaron;": "\u0160",
      "scaron;": "\u0161",
      "Scedil;": "\u015E",
      "scedil;": "\u015F",
      "scnsim;": "\u22E9",
      "searhk;": "\u2925",
      "seswar;": "\u2929",
      "sfrown;": "\u2322",
      "SHCHcy;": "\u0429",
      "shchcy;": "\u0449",
      "sigmaf;": "\u03C2",
      "sigmav;": "\u03C2",
      "simdot;": "\u2A6A",
      "smashp;": "\u2A33",
      "SOFTcy;": "\u042C",
      "softcy;": "\u044C",
      "solbar;": "\u233F",
      "spades;": "\u2660",
      "sqcaps;": "\u2293\uFE00",
      "sqcups;": "\u2294\uFE00",
      "sqsube;": "\u2291",
      "sqsupe;": "\u2292",
      "Square;": "\u25A1",
      "square;": "\u25A1",
      "squarf;": "\u25AA",
      "ssetmn;": "\u2216",
      "ssmile;": "\u2323",
      "sstarf;": "\u22C6",
      "subdot;": "\u2ABD",
      "Subset;": "\u22D0",
      "subset;": "\u2282",
      "subsim;": "\u2AC7",
      "subsub;": "\u2AD5",
      "subsup;": "\u2AD3",
      "succeq;": "\u2AB0",
      "supdot;": "\u2ABE",
      "Supset;": "\u22D1",
      "supset;": "\u2283",
      "supsim;": "\u2AC8",
      "supsub;": "\u2AD4",
      "supsup;": "\u2AD6",
      "swarhk;": "\u2926",
      "swnwar;": "\u292A",
      "target;": "\u2316",
      "Tcaron;": "\u0164",
      "tcaron;": "\u0165",
      "Tcedil;": "\u0162",
      "tcedil;": "\u0163",
      "telrec;": "\u2315",
      "there4;": "\u2234",
      "thetav;": "\u03D1",
      "thinsp;": "\u2009",
      "thksim;": "\u223C",
      "timesb;": "\u22A0",
      "timesd;": "\u2A30",
      "topbot;": "\u2336",
      "topcir;": "\u2AF1",
      "tprime;": "\u2034",
      "tridot;": "\u25EC",
      "Tstrok;": "\u0166",
      "tstrok;": "\u0167",
      "Uacute;": "\xDA",
      "uacute;": "\xFA",
      "Ubreve;": "\u016C",
      "ubreve;": "\u016D",
      "Udblac;": "\u0170",
      "udblac;": "\u0171",
      "ufisht;": "\u297E",
      "Ugrave;": "\xD9",
      "ugrave;": "\xF9",
      "ulcorn;": "\u231C",
      "ulcrop;": "\u230F",
      "urcorn;": "\u231D",
      "urcrop;": "\u230E",
      "Utilde;": "\u0168",
      "utilde;": "\u0169",
      "vangrt;": "\u299C",
      "varphi;": "\u03D5",
      "varrho;": "\u03F1",
      "Vdashl;": "\u2AE6",
      "veebar;": "\u22BB",
      "vellip;": "\u22EE",
      "Verbar;": "\u2016",
      "verbar;": "|",
      "vsubnE;": "\u2ACB\uFE00",
      "vsubne;": "\u228A\uFE00",
      "vsupnE;": "\u2ACC\uFE00",
      "vsupne;": "\u228B\uFE00",
      "Vvdash;": "\u22AA",
      "wedbar;": "\u2A5F",
      "wedgeq;": "\u2259",
      "weierp;": "\u2118",
      "wreath;": "\u2240",
      "xoplus;": "\u2A01",
      "xotime;": "\u2A02",
      "xsqcup;": "\u2A06",
      "xuplus;": "\u2A04",
      "xwedge;": "\u22C0",
      "Yacute;": "\xDD",
      "yacute;": "\xFD",
      "Zacute;": "\u0179",
      "zacute;": "\u017A",
      "Zcaron;": "\u017D",
      "zcaron;": "\u017E",
      "zeetrf;": "\u2128",
      "alefsym;": "\u2135",
      "angrtvb;": "\u22BE",
      "angzarr;": "\u237C",
      "asympeq;": "\u224D",
      "backsim;": "\u223D",
      "Because;": "\u2235",
      "because;": "\u2235",
      "bemptyv;": "\u29B0",
      "between;": "\u226C",
      "bigcirc;": "\u25EF",
      "bigodot;": "\u2A00",
      "bigstar;": "\u2605",
      "bnequiv;": "\u2261\u20E5",
      "boxplus;": "\u229E",
      "Cayleys;": "\u212D",
      "Cconint;": "\u2230",
      "ccupssm;": "\u2A50",
      "Cedilla;": "\xB8",
      "cemptyv;": "\u29B2",
      "cirscir;": "\u29C2",
      "coloneq;": "\u2254",
      "congdot;": "\u2A6D",
      "cudarrl;": "\u2938",
      "cudarrr;": "\u2935",
      "cularrp;": "\u293D",
      "curarrm;": "\u293C",
      "dbkarow;": "\u290F",
      "ddagger;": "\u2021",
      "ddotseq;": "\u2A77",
      "demptyv;": "\u29B1",
      "Diamond;": "\u22C4",
      "diamond;": "\u22C4",
      "digamma;": "\u03DD",
      "dotplus;": "\u2214",
      "DownTee;": "\u22A4",
      "dwangle;": "\u29A6",
      "Element;": "\u2208",
      "Epsilon;": "\u0395",
      "epsilon;": "\u03B5",
      "eqcolon;": "\u2255",
      "equivDD;": "\u2A78",
      "gesdoto;": "\u2A82",
      "gtquest;": "\u2A7C",
      "gtrless;": "\u2277",
      "harrcir;": "\u2948",
      "Implies;": "\u21D2",
      "intprod;": "\u2A3C",
      "isindot;": "\u22F5",
      "larrbfs;": "\u291F",
      "larrsim;": "\u2973",
      "lbrksld;": "\u298F",
      "lbrkslu;": "\u298D",
      "ldrdhar;": "\u2967",
      "LeftTee;": "\u22A3",
      "lesdoto;": "\u2A81",
      "lessdot;": "\u22D6",
      "lessgtr;": "\u2276",
      "lesssim;": "\u2272",
      "lotimes;": "\u2A34",
      "lozenge;": "\u25CA",
      "ltquest;": "\u2A7B",
      "luruhar;": "\u2966",
      "maltese;": "\u2720",
      "minusdu;": "\u2A2A",
      "napprox;": "\u2249",
      "natural;": "\u266E",
      "nearrow;": "\u2197",
      "NewLine;": "\n",
      "nexists;": "\u2204",
      "NoBreak;": "\u2060",
      "notinva;": "\u2209",
      "notinvb;": "\u22F7",
      "notinvc;": "\u22F6",
      "NotLess;": "\u226E",
      "notniva;": "\u220C",
      "notnivb;": "\u22FE",
      "notnivc;": "\u22FD",
      "npolint;": "\u2A14",
      "npreceq;": "\u2AAF\u0338",
      "nsqsube;": "\u22E2",
      "nsqsupe;": "\u22E3",
      "nsubset;": "\u2282\u20D2",
      "nsucceq;": "\u2AB0\u0338",
      "nsupset;": "\u2283\u20D2",
      "nvinfin;": "\u29DE",
      "nvltrie;": "\u22B4\u20D2",
      "nvrtrie;": "\u22B5\u20D2",
      "nwarrow;": "\u2196",
      "olcross;": "\u29BB",
      "Omicron;": "\u039F",
      "omicron;": "\u03BF",
      "orderof;": "\u2134",
      "orslope;": "\u2A57",
      "OverBar;": "\u203E",
      "pertenk;": "\u2031",
      "planckh;": "\u210E",
      "pluscir;": "\u2A22",
      "plussim;": "\u2A26",
      "plustwo;": "\u2A27",
      "precsim;": "\u227E",
      "Product;": "\u220F",
      "quatint;": "\u2A16",
      "questeq;": "\u225F",
      "rarrbfs;": "\u2920",
      "rarrsim;": "\u2974",
      "rbrksld;": "\u298E",
      "rbrkslu;": "\u2990",
      "rdldhar;": "\u2969",
      "realine;": "\u211B",
      "rotimes;": "\u2A35",
      "ruluhar;": "\u2968",
      "searrow;": "\u2198",
      "simplus;": "\u2A24",
      "simrarr;": "\u2972",
      "subedot;": "\u2AC3",
      "submult;": "\u2AC1",
      "subplus;": "\u2ABF",
      "subrarr;": "\u2979",
      "succsim;": "\u227F",
      "supdsub;": "\u2AD8",
      "supedot;": "\u2AC4",
      "suphsol;": "\u27C9",
      "suphsub;": "\u2AD7",
      "suplarr;": "\u297B",
      "supmult;": "\u2AC2",
      "supplus;": "\u2AC0",
      "swarrow;": "\u2199",
      "topfork;": "\u2ADA",
      "triplus;": "\u2A39",
      "tritime;": "\u2A3B",
      "UpArrow;": "\u2191",
      "Uparrow;": "\u21D1",
      "uparrow;": "\u2191",
      "Upsilon;": "\u03A5",
      "upsilon;": "\u03C5",
      "uwangle;": "\u29A7",
      "vzigzag;": "\u299A",
      "zigrarr;": "\u21DD",
      "andslope;": "\u2A58",
      "angmsdaa;": "\u29A8",
      "angmsdab;": "\u29A9",
      "angmsdac;": "\u29AA",
      "angmsdad;": "\u29AB",
      "angmsdae;": "\u29AC",
      "angmsdaf;": "\u29AD",
      "angmsdag;": "\u29AE",
      "angmsdah;": "\u29AF",
      "angrtvbd;": "\u299D",
      "approxeq;": "\u224A",
      "awconint;": "\u2233",
      "backcong;": "\u224C",
      "barwedge;": "\u2305",
      "bbrktbrk;": "\u23B6",
      "bigoplus;": "\u2A01",
      "bigsqcup;": "\u2A06",
      "biguplus;": "\u2A04",
      "bigwedge;": "\u22C0",
      "boxminus;": "\u229F",
      "boxtimes;": "\u22A0",
      "bsolhsub;": "\u27C8",
      "capbrcup;": "\u2A49",
      "circledR;": "\xAE",
      "circledS;": "\u24C8",
      "cirfnint;": "\u2A10",
      "clubsuit;": "\u2663",
      "cupbrcap;": "\u2A48",
      "curlyvee;": "\u22CE",
      "cwconint;": "\u2232",
      "DDotrahd;": "\u2911",
      "doteqdot;": "\u2251",
      "DotEqual;": "\u2250",
      "dotminus;": "\u2238",
      "drbkarow;": "\u2910",
      "dzigrarr;": "\u27FF",
      "elinters;": "\u23E7",
      "emptyset;": "\u2205",
      "eqvparsl;": "\u29E5",
      "fpartint;": "\u2A0D",
      "geqslant;": "\u2A7E",
      "gesdotol;": "\u2A84",
      "gnapprox;": "\u2A8A",
      "hksearow;": "\u2925",
      "hkswarow;": "\u2926",
      "imagline;": "\u2110",
      "imagpart;": "\u2111",
      "infintie;": "\u29DD",
      "integers;": "\u2124",
      "Integral;": "\u222B",
      "intercal;": "\u22BA",
      "intlarhk;": "\u2A17",
      "laemptyv;": "\u29B4",
      "ldrushar;": "\u294B",
      "leqslant;": "\u2A7D",
      "lesdotor;": "\u2A83",
      "LessLess;": "\u2AA1",
      "llcorner;": "\u231E",
      "lnapprox;": "\u2A89",
      "lrcorner;": "\u231F",
      "lurdshar;": "\u294A",
      "mapstoup;": "\u21A5",
      "multimap;": "\u22B8",
      "naturals;": "\u2115",
      "ncongdot;": "\u2A6D\u0338",
      "NotEqual;": "\u2260",
      "notindot;": "\u22F5\u0338",
      "NotTilde;": "\u2241",
      "otimesas;": "\u2A36",
      "parallel;": "\u2225",
      "PartialD;": "\u2202",
      "plusacir;": "\u2A23",
      "pointint;": "\u2A15",
      "Precedes;": "\u227A",
      "precneqq;": "\u2AB5",
      "precnsim;": "\u22E8",
      "profalar;": "\u232E",
      "profline;": "\u2312",
      "profsurf;": "\u2313",
      "raemptyv;": "\u29B3",
      "realpart;": "\u211C",
      "RightTee;": "\u22A2",
      "rppolint;": "\u2A12",
      "rtriltri;": "\u29CE",
      "scpolint;": "\u2A13",
      "setminus;": "\u2216",
      "shortmid;": "\u2223",
      "smeparsl;": "\u29E4",
      "sqsubset;": "\u228F",
      "sqsupset;": "\u2290",
      "subseteq;": "\u2286",
      "Succeeds;": "\u227B",
      "succneqq;": "\u2AB6",
      "succnsim;": "\u22E9",
      "SuchThat;": "\u220B",
      "Superset;": "\u2283",
      "supseteq;": "\u2287",
      "thetasym;": "\u03D1",
      "thicksim;": "\u223C",
      "timesbar;": "\u2A31",
      "triangle;": "\u25B5",
      "triminus;": "\u2A3A",
      "trpezium;": "\u23E2",
      "Uarrocir;": "\u2949",
      "ulcorner;": "\u231C",
      "UnderBar;": "_",
      "urcorner;": "\u231D",
      "varkappa;": "\u03F0",
      "varsigma;": "\u03C2",
      "vartheta;": "\u03D1",
      "backprime;": "\u2035",
      "backsimeq;": "\u22CD",
      "Backslash;": "\u2216",
      "bigotimes;": "\u2A02",
      "CenterDot;": "\xB7",
      "centerdot;": "\xB7",
      "checkmark;": "\u2713",
      "CircleDot;": "\u2299",
      "complexes;": "\u2102",
      "Congruent;": "\u2261",
      "Coproduct;": "\u2210",
      "dotsquare;": "\u22A1",
      "DoubleDot;": "\xA8",
      "DownArrow;": "\u2193",
      "Downarrow;": "\u21D3",
      "downarrow;": "\u2193",
      "DownBreve;": "\u0311",
      "gtrapprox;": "\u2A86",
      "gtreqless;": "\u22DB",
      "gvertneqq;": "\u2269\uFE00",
      "heartsuit;": "\u2665",
      "HumpEqual;": "\u224F",
      "LeftArrow;": "\u2190",
      "Leftarrow;": "\u21D0",
      "leftarrow;": "\u2190",
      "LeftFloor;": "\u230A",
      "lesseqgtr;": "\u22DA",
      "LessTilde;": "\u2272",
      "lvertneqq;": "\u2268\uFE00",
      "Mellintrf;": "\u2133",
      "MinusPlus;": "\u2213",
      "ngeqslant;": "\u2A7E\u0338",
      "nleqslant;": "\u2A7D\u0338",
      "NotCupCap;": "\u226D",
      "NotExists;": "\u2204",
      "NotSubset;": "\u2282\u20D2",
      "nparallel;": "\u2226",
      "nshortmid;": "\u2224",
      "nsubseteq;": "\u2288",
      "nsupseteq;": "\u2289",
      "OverBrace;": "\u23DE",
      "pitchfork;": "\u22D4",
      "PlusMinus;": "\xB1",
      "rationals;": "\u211A",
      "spadesuit;": "\u2660",
      "subseteqq;": "\u2AC5",
      "subsetneq;": "\u228A",
      "supseteqq;": "\u2AC6",
      "supsetneq;": "\u228B",
      "Therefore;": "\u2234",
      "therefore;": "\u2234",
      "ThinSpace;": "\u2009",
      "triangleq;": "\u225C",
      "TripleDot;": "\u20DB",
      "UnionPlus;": "\u228E",
      "varpropto;": "\u221D",
      "Bernoullis;": "\u212C",
      "circledast;": "\u229B",
      "CirclePlus;": "\u2295",
      "complement;": "\u2201",
      "curlywedge;": "\u22CF",
      "eqslantgtr;": "\u2A96",
      "EqualTilde;": "\u2242",
      "Fouriertrf;": "\u2131",
      "gtreqqless;": "\u2A8C",
      "ImaginaryI;": "\u2148",
      "Laplacetrf;": "\u2112",
      "LeftVector;": "\u21BC",
      "lessapprox;": "\u2A85",
      "lesseqqgtr;": "\u2A8B",
      "Lleftarrow;": "\u21DA",
      "lmoustache;": "\u23B0",
      "longmapsto;": "\u27FC",
      "mapstodown;": "\u21A7",
      "mapstoleft;": "\u21A4",
      "nLeftarrow;": "\u21CD",
      "nleftarrow;": "\u219A",
      "NotElement;": "\u2209",
      "NotGreater;": "\u226F",
      "nsubseteqq;": "\u2AC5\u0338",
      "nsupseteqq;": "\u2AC6\u0338",
      "precapprox;": "\u2AB7",
      "Proportion;": "\u2237",
      "RightArrow;": "\u2192",
      "Rightarrow;": "\u21D2",
      "rightarrow;": "\u2192",
      "RightFloor;": "\u230B",
      "rmoustache;": "\u23B1",
      "sqsubseteq;": "\u2291",
      "sqsupseteq;": "\u2292",
      "subsetneqq;": "\u2ACB",
      "succapprox;": "\u2AB8",
      "supsetneqq;": "\u2ACC",
      "ThickSpace;": "\u205F\u200A",
      "TildeEqual;": "\u2243",
      "TildeTilde;": "\u2248",
      "UnderBrace;": "\u23DF",
      "UpArrowBar;": "\u2912",
      "UpTeeArrow;": "\u21A5",
      "upuparrows;": "\u21C8",
      "varepsilon;": "\u03F5",
      "varnothing;": "\u2205",
      "backepsilon;": "\u03F6",
      "blacksquare;": "\u25AA",
      "circledcirc;": "\u229A",
      "circleddash;": "\u229D",
      "CircleMinus;": "\u2296",
      "CircleTimes;": "\u2297",
      "curlyeqprec;": "\u22DE",
      "curlyeqsucc;": "\u22DF",
      "diamondsuit;": "\u2666",
      "eqslantless;": "\u2A95",
      "Equilibrium;": "\u21CC",
      "expectation;": "\u2130",
      "GreaterLess;": "\u2277",
      "LeftCeiling;": "\u2308",
      "LessGreater;": "\u2276",
      "MediumSpace;": "\u205F",
      "NotLessLess;": "\u226A\u0338",
      "NotPrecedes;": "\u2280",
      "NotSucceeds;": "\u2281",
      "NotSuperset;": "\u2283\u20D2",
      "nRightarrow;": "\u21CF",
      "nrightarrow;": "\u219B",
      "OverBracket;": "\u23B4",
      "preccurlyeq;": "\u227C",
      "precnapprox;": "\u2AB9",
      "quaternions;": "\u210D",
      "RightVector;": "\u21C0",
      "Rrightarrow;": "\u21DB",
      "RuleDelayed;": "\u29F4",
      "SmallCircle;": "\u2218",
      "SquareUnion;": "\u2294",
      "straightphi;": "\u03D5",
      "SubsetEqual;": "\u2286",
      "succcurlyeq;": "\u227D",
      "succnapprox;": "\u2ABA",
      "thickapprox;": "\u2248",
      "UpDownArrow;": "\u2195",
      "Updownarrow;": "\u21D5",
      "updownarrow;": "\u2195",
      "VerticalBar;": "\u2223",
      "blacklozenge;": "\u29EB",
      "DownArrowBar;": "\u2913",
      "DownTeeArrow;": "\u21A7",
      "ExponentialE;": "\u2147",
      "exponentiale;": "\u2147",
      "GreaterEqual;": "\u2265",
      "GreaterTilde;": "\u2273",
      "HilbertSpace;": "\u210B",
      "HumpDownHump;": "\u224E",
      "Intersection;": "\u22C2",
      "LeftArrowBar;": "\u21E4",
      "LeftTeeArrow;": "\u21A4",
      "LeftTriangle;": "\u22B2",
      "LeftUpVector;": "\u21BF",
      "NotCongruent;": "\u2262",
      "NotHumpEqual;": "\u224F\u0338",
      "NotLessEqual;": "\u2270",
      "NotLessTilde;": "\u2274",
      "Proportional;": "\u221D",
      "RightCeiling;": "\u2309",
      "risingdotseq;": "\u2253",
      "RoundImplies;": "\u2970",
      "ShortUpArrow;": "\u2191",
      "SquareSubset;": "\u228F",
      "triangledown;": "\u25BF",
      "triangleleft;": "\u25C3",
      "UnderBracket;": "\u23B5",
      "varsubsetneq;": "\u228A\uFE00",
      "varsupsetneq;": "\u228B\uFE00",
      "VerticalLine;": "|",
      "ApplyFunction;": "\u2061",
      "bigtriangleup;": "\u25B3",
      "blacktriangle;": "\u25B4",
      "DifferentialD;": "\u2146",
      "divideontimes;": "\u22C7",
      "DoubleLeftTee;": "\u2AE4",
      "DoubleUpArrow;": "\u21D1",
      "fallingdotseq;": "\u2252",
      "hookleftarrow;": "\u21A9",
      "leftarrowtail;": "\u21A2",
      "leftharpoonup;": "\u21BC",
      "LeftTeeVector;": "\u295A",
      "LeftVectorBar;": "\u2952",
      "LessFullEqual;": "\u2266",
      "LongLeftArrow;": "\u27F5",
      "Longleftarrow;": "\u27F8",
      "longleftarrow;": "\u27F5",
      "looparrowleft;": "\u21AB",
      "measuredangle;": "\u2221",
      "NotEqualTilde;": "\u2242\u0338",
      "NotTildeEqual;": "\u2244",
      "NotTildeTilde;": "\u2249",
      "ntriangleleft;": "\u22EA",
      "Poincareplane;": "\u210C",
      "PrecedesEqual;": "\u2AAF",
      "PrecedesTilde;": "\u227E",
      "RightArrowBar;": "\u21E5",
      "RightTeeArrow;": "\u21A6",
      "RightTriangle;": "\u22B3",
      "RightUpVector;": "\u21BE",
      "shortparallel;": "\u2225",
      "smallsetminus;": "\u2216",
      "SucceedsEqual;": "\u2AB0",
      "SucceedsTilde;": "\u227F",
      "SupersetEqual;": "\u2287",
      "triangleright;": "\u25B9",
      "UpEquilibrium;": "\u296E",
      "upharpoonleft;": "\u21BF",
      "varsubsetneqq;": "\u2ACB\uFE00",
      "varsupsetneqq;": "\u2ACC\uFE00",
      "VerticalTilde;": "\u2240",
      "VeryThinSpace;": "\u200A",
      "curvearrowleft;": "\u21B6",
      "DiacriticalDot;": "\u02D9",
      "doublebarwedge;": "\u2306",
      "DoubleRightTee;": "\u22A8",
      "downdownarrows;": "\u21CA",
      "DownLeftVector;": "\u21BD",
      "GreaterGreater;": "\u2AA2",
      "hookrightarrow;": "\u21AA",
      "HorizontalLine;": "\u2500",
      "InvisibleComma;": "\u2063",
      "InvisibleTimes;": "\u2062",
      "LeftDownVector;": "\u21C3",
      "leftleftarrows;": "\u21C7",
      "LeftRightArrow;": "\u2194",
      "Leftrightarrow;": "\u21D4",
      "leftrightarrow;": "\u2194",
      "leftthreetimes;": "\u22CB",
      "LessSlantEqual;": "\u2A7D",
      "LongRightArrow;": "\u27F6",
      "Longrightarrow;": "\u27F9",
      "longrightarrow;": "\u27F6",
      "looparrowright;": "\u21AC",
      "LowerLeftArrow;": "\u2199",
      "NestedLessLess;": "\u226A",
      "NotGreaterLess;": "\u2279",
      "NotLessGreater;": "\u2278",
      "NotSubsetEqual;": "\u2288",
      "NotVerticalBar;": "\u2224",
      "nshortparallel;": "\u2226",
      "ntriangleright;": "\u22EB",
      "OpenCurlyQuote;": "\u2018",
      "ReverseElement;": "\u220B",
      "rightarrowtail;": "\u21A3",
      "rightharpoonup;": "\u21C0",
      "RightTeeVector;": "\u295B",
      "RightVectorBar;": "\u2953",
      "ShortDownArrow;": "\u2193",
      "ShortLeftArrow;": "\u2190",
      "SquareSuperset;": "\u2290",
      "TildeFullEqual;": "\u2245",
      "trianglelefteq;": "\u22B4",
      "upharpoonright;": "\u21BE",
      "UpperLeftArrow;": "\u2196",
      "ZeroWidthSpace;": "\u200B",
      "bigtriangledown;": "\u25BD",
      "circlearrowleft;": "\u21BA",
      "CloseCurlyQuote;": "\u2019",
      "ContourIntegral;": "\u222E",
      "curvearrowright;": "\u21B7",
      "DoubleDownArrow;": "\u21D3",
      "DoubleLeftArrow;": "\u21D0",
      "downharpoonleft;": "\u21C3",
      "DownRightVector;": "\u21C1",
      "leftharpoondown;": "\u21BD",
      "leftrightarrows;": "\u21C6",
      "LeftRightVector;": "\u294E",
      "LeftTriangleBar;": "\u29CF",
      "LeftUpTeeVector;": "\u2960",
      "LeftUpVectorBar;": "\u2958",
      "LowerRightArrow;": "\u2198",
      "nLeftrightarrow;": "\u21CE",
      "nleftrightarrow;": "\u21AE",
      "NotGreaterEqual;": "\u2271",
      "NotGreaterTilde;": "\u2275",
      "NotHumpDownHump;": "\u224E\u0338",
      "NotLeftTriangle;": "\u22EA",
      "NotSquareSubset;": "\u228F\u0338",
      "ntrianglelefteq;": "\u22EC",
      "OverParenthesis;": "\u23DC",
      "RightDownVector;": "\u21C2",
      "rightleftarrows;": "\u21C4",
      "rightsquigarrow;": "\u219D",
      "rightthreetimes;": "\u22CC",
      "ShortRightArrow;": "\u2192",
      "straightepsilon;": "\u03F5",
      "trianglerighteq;": "\u22B5",
      "UpperRightArrow;": "\u2197",
      "vartriangleleft;": "\u22B2",
      "circlearrowright;": "\u21BB",
      "DiacriticalAcute;": "\xB4",
      "DiacriticalGrave;": "`",
      "DiacriticalTilde;": "\u02DC",
      "DoubleRightArrow;": "\u21D2",
      "DownArrowUpArrow;": "\u21F5",
      "downharpoonright;": "\u21C2",
      "EmptySmallSquare;": "\u25FB",
      "GreaterEqualLess;": "\u22DB",
      "GreaterFullEqual;": "\u2267",
      "LeftAngleBracket;": "\u27E8",
      "LeftUpDownVector;": "\u2951",
      "LessEqualGreater;": "\u22DA",
      "NonBreakingSpace;": "\xA0",
      "NotPrecedesEqual;": "\u2AAF\u0338",
      "NotRightTriangle;": "\u22EB",
      "NotSucceedsEqual;": "\u2AB0\u0338",
      "NotSucceedsTilde;": "\u227F\u0338",
      "NotSupersetEqual;": "\u2289",
      "ntrianglerighteq;": "\u22ED",
      "rightharpoondown;": "\u21C1",
      "rightrightarrows;": "\u21C9",
      "RightTriangleBar;": "\u29D0",
      "RightUpTeeVector;": "\u295C",
      "RightUpVectorBar;": "\u2954",
      "twoheadleftarrow;": "\u219E",
      "UnderParenthesis;": "\u23DD",
      "UpArrowDownArrow;": "\u21C5",
      "vartriangleright;": "\u22B3",
      "blacktriangledown;": "\u25BE",
      "blacktriangleleft;": "\u25C2",
      "DoubleUpDownArrow;": "\u21D5",
      "DoubleVerticalBar;": "\u2225",
      "DownLeftTeeVector;": "\u295E",
      "DownLeftVectorBar;": "\u2956",
      "FilledSmallSquare;": "\u25FC",
      "GreaterSlantEqual;": "\u2A7E",
      "LeftDoubleBracket;": "\u27E6",
      "LeftDownTeeVector;": "\u2961",
      "LeftDownVectorBar;": "\u2959",
      "leftrightharpoons;": "\u21CB",
      "LeftTriangleEqual;": "\u22B4",
      "NegativeThinSpace;": "\u200B",
      "NotGreaterGreater;": "\u226B\u0338",
      "NotLessSlantEqual;": "\u2A7D\u0338",
      "NotNestedLessLess;": "\u2AA1\u0338",
      "NotReverseElement;": "\u220C",
      "NotSquareSuperset;": "\u2290\u0338",
      "NotTildeFullEqual;": "\u2247",
      "RightAngleBracket;": "\u27E9",
      "rightleftharpoons;": "\u21CC",
      "RightUpDownVector;": "\u294F",
      "SquareSubsetEqual;": "\u2291",
      "twoheadrightarrow;": "\u21A0",
      "VerticalSeparator;": "\u2758",
      "blacktriangleright;": "\u25B8",
      "DownRightTeeVector;": "\u295F",
      "DownRightVectorBar;": "\u2957",
      "LongLeftRightArrow;": "\u27F7",
      "Longleftrightarrow;": "\u27FA",
      "longleftrightarrow;": "\u27F7",
      "NegativeThickSpace;": "\u200B",
      "NotLeftTriangleBar;": "\u29CF\u0338",
      "PrecedesSlantEqual;": "\u227C",
      "ReverseEquilibrium;": "\u21CB",
      "RightDoubleBracket;": "\u27E7",
      "RightDownTeeVector;": "\u295D",
      "RightDownVectorBar;": "\u2955",
      "RightTriangleEqual;": "\u22B5",
      "SquareIntersection;": "\u2293",
      "SucceedsSlantEqual;": "\u227D",
      "DoubleLongLeftArrow;": "\u27F8",
      "DownLeftRightVector;": "\u2950",
      "LeftArrowRightArrow;": "\u21C6",
      "leftrightsquigarrow;": "\u21AD",
      "NegativeMediumSpace;": "\u200B",
      "NotGreaterFullEqual;": "\u2267\u0338",
      "NotRightTriangleBar;": "\u29D0\u0338",
      "RightArrowLeftArrow;": "\u21C4",
      "SquareSupersetEqual;": "\u2292",
      "CapitalDifferentialD;": "\u2145",
      "DoubleLeftRightArrow;": "\u21D4",
      "DoubleLongRightArrow;": "\u27F9",
      "EmptyVerySmallSquare;": "\u25AB",
      "NestedGreaterGreater;": "\u226B",
      "NotDoubleVerticalBar;": "\u2226",
      "NotGreaterSlantEqual;": "\u2A7E\u0338",
      "NotLeftTriangleEqual;": "\u22EC",
      "NotSquareSubsetEqual;": "\u22E2",
      "OpenCurlyDoubleQuote;": "\u201C",
      "ReverseUpEquilibrium;": "\u296F",
      "CloseCurlyDoubleQuote;": "\u201D",
      "DoubleContourIntegral;": "\u222F",
      "FilledVerySmallSquare;": "\u25AA",
      "NegativeVeryThinSpace;": "\u200B",
      "NotPrecedesSlantEqual;": "\u22E0",
      "NotRightTriangleEqual;": "\u22ED",
      "NotSucceedsSlantEqual;": "\u22E1",
      "DiacriticalDoubleAcute;": "\u02DD",
      "NotSquareSupersetEqual;": "\u22E3",
      "NotNestedGreaterGreater;": "\u2AA2\u0338",
      "ClockwiseContourIntegral;": "\u2232",
      "DoubleLongLeftRightArrow;": "\u27FA",
      "CounterClockwiseContourIntegral;": "\u2233"
    };
    var maxCRNameLength;
    var decodeHtml = (rawText, asAttr) => {
      let offset = 0;
      const end = rawText.length;
      let decodedText = "";
      function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
      }
      while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (!head || offset + head.index >= end) {
          const remaining = end - offset;
          decodedText += rawText.slice(0, remaining);
          advance(remaining);
          break;
        }
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === "&") {
          let name = "";
          let value = void 0;
          if (/[0-9a-z]/i.test(rawText[1])) {
            if (!maxCRNameLength) {
              maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
            }
            for (let length = maxCRNameLength; !value && length > 0; --length) {
              name = rawText.substr(1, length);
              value = namedCharacterReferences[name];
            }
            if (value) {
              const semi = name.endsWith(";");
              if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                decodedText += "&" + name;
                advance(1 + name.length);
              } else {
                decodedText += value;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&" + name;
              advance(1 + name.length);
            }
          } else {
            decodedText += "&";
            advance(1);
          }
        } else {
          const hex = head[0] === "&#x";
          const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
          const body = pattern.exec(rawText);
          if (!body) {
            decodedText += head[0];
            advance(head[0].length);
          } else {
            let cp = Number.parseInt(body[1], hex ? 16 : 10);
            if (cp === 0) {
              cp = 65533;
            } else if (cp > 1114111) {
              cp = 65533;
            } else if (cp >= 55296 && cp <= 57343) {
              cp = 65533;
            } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534)
              ;
            else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {
              cp = CCR_REPLACEMENTS[cp] || cp;
            }
            decodedText += String.fromCodePoint(cp);
            advance(body[0].length);
          }
        }
      }
      return decodedText;
    };
    var CCR_REPLACEMENTS = {
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376
    };
    var isRawTextContainer = /* @__PURE__ */ shared.makeMap("style,iframe,script,noscript", true);
    var parserOptions = {
      isVoidTag: shared.isVoidTag,
      isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtml,
      isBuiltInComponent: (tag) => {
        if (compilerCore.isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    var transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    var parseInlineCSS = (cssText, loc) => {
      const normalized = shared.parseStringStyle(cssText);
      return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
    };
    function createDOMCompilerError(code, loc) {
      return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
    }
    var DOMErrorMessages = {
      [49]: `v-html is missing expression.`,
      [50]: `v-html will override element children.`,
      [51]: `v-text is missing expression.`,
      [52]: `v-text will override element children.`,
      [53]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [54]: `v-model argument is not supported on plain elements.`,
      [55]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [56]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [57]: `v-show is missing expression.`,
      [58]: `<Transition> expects exactly one child element or component.`,
      [59]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    var transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(49, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(50, loc));
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
        ]
      };
    };
    var transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(51, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(52, loc));
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
        ]
      };
    };
    var transformModel = (dir, node, context) => {
      const baseResult = compilerCore.transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(54, dir.arg.loc));
      }
      function checkDuplicatedValue() {
        const value = compilerCore.findProp(node, "value");
        if (value) {
          context.onError(createDOMCompilerError(56, value.loc));
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = compilerCore.findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(55, dir.loc));
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (compilerCore.hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(53, dir.loc));
      }
      baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
      return baseResult;
    };
    var isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
    var isNonKeyModifier = /* @__PURE__ */ shared.makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
    var maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
    var isKeyboardEvent = /* @__PURE__ */ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
    var resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (compilerCore.isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    var transformClick = (key, event) => {
      const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    var transformOn = (dir, node, context) => {
      return compilerCore.transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
          key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [compilerCore.createObjectProperty(key, handlerExp)]
        };
      });
    };
    var transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(57, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    var warnTransitionChildren = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (node.children.length && hasMultipleChildren(node)) {
              context.onError(createDOMCompilerError(58, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          };
        }
      }
    };
    function hasMultipleChildren(node) {
      const children = node.children = node.children.filter((c) => c.type !== 3);
      const child = children[0];
      return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
    }
    var stringifyStatic = (children, context, parent) => {
      if (context.scopes.vSlot > 0) {
        return;
      }
      let nc = 0;
      let ec = 0;
      const currentChunk = [];
      const stringifyCurrentChunk = (currentIndex) => {
        if (nc >= 20 || ec >= 5) {
          const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
            JSON.stringify(currentChunk.map((node) => stringifyNode(node, context)).join("")),
            String(currentChunk.length)
          ]);
          replaceHoist(currentChunk[0], staticCall, context);
          if (currentChunk.length > 1) {
            for (let i2 = 1; i2 < currentChunk.length; i2++) {
              replaceHoist(currentChunk[i2], null, context);
            }
            const deleteCount = currentChunk.length - 1;
            children.splice(currentIndex - currentChunk.length + 1, deleteCount);
            return deleteCount;
          }
        }
        return 0;
      };
      let i = 0;
      for (; i < children.length; i++) {
        const child = children[i];
        const hoisted = getHoistedNode(child);
        if (hoisted) {
          const node = child;
          const result = analyzeNode(node);
          if (result) {
            nc += result[0];
            ec += result[1];
            currentChunk.push(node);
            continue;
          }
        }
        i -= stringifyCurrentChunk(i);
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
      }
      stringifyCurrentChunk(i);
    };
    var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
    var dataAriaRE = /^(data|aria)-/;
    var isStringifiableAttr = (name, ns) => {
      return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
    };
    var replaceHoist = (node, replacement, context) => {
      const hoistToReplace = node.codegenNode.hoisted;
      context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
    };
    var isNonStringifiable = /* @__PURE__ */ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
    function analyzeNode(node) {
      if (node.type === 1 && isNonStringifiable(node.tag)) {
        return false;
      }
      if (node.type === 12) {
        return [1, 0];
      }
      let nc = 1;
      let ec = node.props.length > 0 ? 1 : 0;
      let bailed = false;
      const bail = () => {
        bailed = true;
        return false;
      };
      function walk2(node2) {
        for (let i = 0; i < node2.props.length; i++) {
          const p = node2.props[i];
          if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
            return bail();
          }
          if (p.type === 7 && p.name === "bind") {
            if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
              return bail();
            }
          }
        }
        for (let i = 0; i < node2.children.length; i++) {
          nc++;
          const child = node2.children[i];
          if (child.type === 1) {
            if (child.props.length > 0) {
              ec++;
            }
            walk2(child);
            if (bailed) {
              return false;
            }
          }
        }
        return true;
      }
      return walk2(node) ? [nc, ec] : false;
    }
    function stringifyNode(node, context) {
      if (shared.isString(node)) {
        return node;
      }
      if (shared.isSymbol(node)) {
        return ``;
      }
      switch (node.type) {
        case 1:
          return stringifyElement(node, context);
        case 2:
          return shared.escapeHtml(node.content);
        case 3:
          return `<!--${shared.escapeHtml(node.content)}-->`;
        case 5:
          return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
        case 8:
          return shared.escapeHtml(evaluateConstant(node));
        case 12:
          return stringifyNode(node.content, context);
        default:
          return "";
      }
    }
    function stringifyElement(node, context) {
      let res = `<${node.tag}`;
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          res += ` ${p.name}`;
          if (p.value) {
            res += `="${shared.escapeHtml(p.value.content)}"`;
          }
        } else if (p.type === 7 && p.name === "bind") {
          let evaluated = evaluateConstant(p.exp);
          if (evaluated != null) {
            const arg = p.arg && p.arg.content;
            if (arg === "class") {
              evaluated = shared.normalizeClass(evaluated);
            } else if (arg === "style") {
              evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
            }
            res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
          }
        }
      }
      if (context.scopeId) {
        res += ` ${context.scopeId}`;
      }
      res += `>`;
      for (let i = 0; i < node.children.length; i++) {
        res += stringifyNode(node.children[i], context);
      }
      if (!shared.isVoidTag(node.tag)) {
        res += `</${node.tag}>`;
      }
      return res;
    }
    function evaluateConstant(exp) {
      if (exp.type === 4) {
        return new Function(`return ${exp.content}`)();
      } else {
        let res = ``;
        exp.children.forEach((c) => {
          if (shared.isString(c) || shared.isSymbol(c)) {
            return;
          }
          if (c.type === 2) {
            res += c.content;
          } else if (c.type === 5) {
            res += shared.toDisplayString(evaluateConstant(c.content));
          } else {
            res += evaluateConstant(c);
          }
        });
        return res;
      }
    }
    var ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(createDOMCompilerError(59, node.loc));
        context.removeNode();
      }
    };
    var DOMNodeTransforms = [
      transformStyle,
      ...[warnTransitionChildren]
    ];
    var DOMDirectiveTransforms = {
      cloak: compilerCore.noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel,
      on: transformOn,
      show: transformShow
    };
    function compile(template2, options = {}) {
      return compilerCore.baseCompile(template2, shared.extend({}, parserOptions, options, {
        nodeTransforms: [
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: stringifyStatic
      }));
    }
    function parse3(template2, options = {}) {
      return compilerCore.baseParse(template2, shared.extend({}, parserOptions, options));
    }
    Object.keys(compilerCore).forEach(function(k) {
      if (k !== "default")
        exports2[k] = compilerCore[k];
    });
    exports2.DOMDirectiveTransforms = DOMDirectiveTransforms;
    exports2.DOMNodeTransforms = DOMNodeTransforms;
    exports2.TRANSITION = TRANSITION;
    exports2.TRANSITION_GROUP = TRANSITION_GROUP;
    exports2.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
    exports2.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
    exports2.V_MODEL_RADIO = V_MODEL_RADIO;
    exports2.V_MODEL_SELECT = V_MODEL_SELECT;
    exports2.V_MODEL_TEXT = V_MODEL_TEXT;
    exports2.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
    exports2.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
    exports2.V_SHOW = V_SHOW;
    exports2.compile = compile;
    exports2.createDOMCompilerError = createDOMCompilerError;
    exports2.parse = parse3;
    exports2.parserOptions = parserOptions;
    exports2.transformStyle = transformStyle;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-dom-npm-3.2.4-0229722813-c73fc217bd.zip/node_modules/@vue/compiler-dom/index.js
var require_compiler_dom = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-dom-npm-3.2.4-0229722813-c73fc217bd.zip/node_modules/@vue/compiler-dom/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_compiler_dom_cjs();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/hash-sum-npm-2.0.0-2216318cf2-efeeacf09e.zip/node_modules/hash-sum/hash-sum.js
var require_hash_sum = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/hash-sum-npm-2.0.0-2216318cf2-efeeacf09e.zip/node_modules/hash-sum/hash-sum.js"(exports2, module2) {
    "use strict";
    function pad(hash, len) {
      while (hash.length < len) {
        hash = "0" + hash;
      }
      return hash;
    }
    function fold(hash, text) {
      var i;
      var chr;
      var len;
      if (text.length === 0) {
        return hash;
      }
      for (i = 0, len = text.length; i < len; i++) {
        chr = text.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
      }
      return hash < 0 ? hash * -2 : hash;
    }
    function foldObject(hash, o, seen) {
      return Object.keys(o).sort().reduce(foldKey, hash);
      function foldKey(hash2, key) {
        return foldValue(hash2, o[key], key, seen);
      }
    }
    function foldValue(input, value, key, seen) {
      var hash = fold(fold(fold(input, key), toString(value)), typeof value);
      if (value === null) {
        return fold(hash, "null");
      }
      if (value === void 0) {
        return fold(hash, "undefined");
      }
      if (typeof value === "object" || typeof value === "function") {
        if (seen.indexOf(value) !== -1) {
          return fold(hash, "[Circular]" + key);
        }
        seen.push(value);
        var objHash = foldObject(hash, value, seen);
        if (!("valueOf" in value) || typeof value.valueOf !== "function") {
          return objHash;
        }
        try {
          return fold(objHash, String(value.valueOf()));
        } catch (err) {
          return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
        }
      }
      return fold(hash, value.toString());
    }
    function toString(o) {
      return Object.prototype.toString.call(o);
    }
    function sum(o) {
      return pad(foldValue(0, o, "", []).toString(16), 8);
    }
    module2.exports = sum;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-ssr-npm-3.2.4-bcfd102149-fc2b4b65ee.zip/node_modules/@vue/compiler-ssr/dist/compiler-ssr.cjs.js
var require_compiler_ssr_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-ssr-npm-3.2.4-bcfd102149-fc2b4b65ee.zip/node_modules/@vue/compiler-ssr/dist/compiler-ssr.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var compilerDom = require_compiler_dom();
    var shared = require_shared();
    var SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
    var SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
    var SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
    var SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
    var SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
    var SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
    var SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
    var SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
    var SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
    var SSR_RENDER_LIST = Symbol(`ssrRenderList`);
    var SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);
    var SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
    var SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
    var SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
    var SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
    var SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
    var SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
    var ssrHelpers = {
      [SSR_INTERPOLATE]: `ssrInterpolate`,
      [SSR_RENDER_VNODE]: `ssrRenderVNode`,
      [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
      [SSR_RENDER_SLOT]: `ssrRenderSlot`,
      [SSR_RENDER_CLASS]: `ssrRenderClass`,
      [SSR_RENDER_STYLE]: `ssrRenderStyle`,
      [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
      [SSR_RENDER_ATTR]: `ssrRenderAttr`,
      [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
      [SSR_RENDER_LIST]: `ssrRenderList`,
      [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,
      [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
      [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
      [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
      [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
      [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
      [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`
    };
    compilerDom.registerRuntimeHelpers(ssrHelpers);
    var ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);
    function ssrProcessIf(node, context, disableNestedFragments = false) {
      const [rootBranch] = node.branches;
      const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));
      context.pushStatement(ifStatement);
      let currentIf = ifStatement;
      for (let i = 1; i < node.branches.length; i++) {
        const branch = node.branches[i];
        const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);
        if (branch.condition) {
          currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);
        } else {
          currentIf.alternate = branchBlockStatement;
        }
      }
      if (!currentIf.alternate) {
        currentIf.alternate = compilerDom.createBlockStatement([
          compilerDom.createCallExpression(`_push`, ["`<!---->`"])
        ]);
      }
    }
    function processIfBranch(branch, context, disableNestedFragments = false) {
      const { children } = branch;
      const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && !(children.length === 1 && children[0].type === 11);
      return processChildrenAsStatement(children, context, needFragmentWrapper);
    }
    var ssrTransformFor = compilerDom.createStructuralDirectiveTransform("for", compilerDom.processFor);
    function ssrProcessFor(node, context, disableNestedFragments = false) {
      const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);
      const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));
      renderLoop.body = processChildrenAsStatement(node.children, context, needFragmentWrapper);
      if (!disableNestedFragments) {
        context.pushStringPart(`<!--[-->`);
      }
      context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [
        node.source,
        renderLoop
      ]));
      if (!disableNestedFragments) {
        context.pushStringPart(`<!--]-->`);
      }
    }
    var ssrTransformSlotOutlet = (node, context) => {
      if (compilerDom.isSlotOutlet(node)) {
        const { slotName, slotProps } = compilerDom.processSlotOutlet(node, context);
        const args = [
          `_ctx.$slots`,
          slotName,
          slotProps || `{}`,
          `null`,
          `_push`,
          `_parent`
        ];
        if (context.scopeId && context.slotted !== false) {
          args.push(`"${context.scopeId}-s"`);
        }
        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_SLOT), args);
      }
    };
    function ssrProcessSlotOutlet(node, context) {
      const renderCall = node.ssrCodegenNode;
      if (node.children.length) {
        const fallbackRenderFn = compilerDom.createFunctionExpression([]);
        fallbackRenderFn.body = processChildrenAsStatement(node.children, context);
        renderCall.arguments[3] = fallbackRenderFn;
      }
      if (context.withSlotScopeId) {
        const slotScopeId = renderCall.arguments[6];
        renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
      }
      context.pushStatement(node.ssrCodegenNode);
    }
    function createSSRCompilerError(code, loc) {
      return compilerDom.createCompilerError(code, loc, SSRErrorMessages);
    }
    var SSRErrorMessages = {
      [60]: `Custom directive is missing corresponding SSR transform and will be ignored.`,
      [61]: `Unsafe attribute name for SSR.`,
      [62]: `Missing the 'to' prop on teleport element.`,
      [63]: `Invalid AST node during SSR transform.`
    };
    function ssrProcessTeleport(node, context) {
      const targetProp = compilerDom.findProp(node, "to");
      if (!targetProp) {
        context.onError(createSSRCompilerError(62, node.loc));
        return;
      }
      let target;
      if (targetProp.type === 6) {
        target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);
      } else {
        target = targetProp.exp;
      }
      if (!target) {
        context.onError(createSSRCompilerError(62, targetProp.loc));
        return;
      }
      const disabledProp = compilerDom.findProp(node, "disabled", false, true);
      const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
      const contentRenderFn = compilerDom.createFunctionExpression([`_push`], void 0, true, false, node.loc);
      contentRenderFn.body = processChildrenAsStatement(node.children, context);
      context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
        `_push`,
        contentRenderFn,
        target,
        disabled,
        `_parent`
      ]));
    }
    var wipMap = new WeakMap();
    function ssrTransformSuspense(node, context) {
      return () => {
        if (node.children.length) {
          const wipEntry = {
            slotsExp: null,
            wipSlots: []
          };
          wipMap.set(node, wipEntry);
          wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, children, loc) => {
            const fn = compilerDom.createFunctionExpression([], void 0, true, false, loc);
            wipEntry.wipSlots.push({
              fn,
              children
            });
            return fn;
          }).slots;
        }
      };
    }
    function ssrProcessSuspense(node, context) {
      const wipEntry = wipMap.get(node);
      if (!wipEntry) {
        return;
      }
      const { slotsExp, wipSlots } = wipEntry;
      for (let i = 0; i < wipSlots.length; i++) {
        const { fn, children } = wipSlots[i];
        fn.body = processChildrenAsStatement(children, context);
      }
      context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
        `_push`,
        slotsExp
      ]));
    }
    function ssrProcessTransitionGroup(node, context) {
      const tag = compilerDom.findProp(node, "tag");
      if (tag) {
        if (tag.type === 7) {
          context.pushStringPart(`<`);
          context.pushStringPart(tag.exp);
          context.pushStringPart(`>`);
          processChildren(node.children, context, false, true);
          context.pushStringPart(`</`);
          context.pushStringPart(tag.exp);
          context.pushStringPart(`>`);
        } else {
          context.pushStringPart(`<${tag.value.content}>`);
          processChildren(node.children, context, false, true);
          context.pushStringPart(`</${tag.value.content}>`);
        }
      } else {
        processChildren(node.children, context, true, true);
      }
    }
    var wipMap$1 = new WeakMap();
    var componentTypeMap = new WeakMap();
    var ssrTransformComponent = (node, context) => {
      if (node.type !== 1 || node.tagType !== 1) {
        return;
      }
      const component = compilerDom.resolveComponentType(node, context, true);
      componentTypeMap.set(node, component);
      if (shared.isSymbol(component)) {
        if (component === compilerDom.SUSPENSE) {
          return ssrTransformSuspense(node, context);
        }
        return;
      }
      const vnodeBranches = [];
      const clonedNode = clone(node);
      return function ssrPostTransformComponent() {
        if (clonedNode.children.length) {
          compilerDom.buildSlots(clonedNode, context, (props2, children) => {
            vnodeBranches.push(createVNodeSlotBranch(props2, children, context));
            return compilerDom.createFunctionExpression(void 0);
          });
        }
        const props = node.props.length > 0 ? compilerDom.buildProps(node, context).props || `null` : `null`;
        const wipEntries = [];
        wipMap$1.set(node, wipEntries);
        const buildSSRSlotFn = (props2, children, loc) => {
          const fn = compilerDom.createFunctionExpression([props2 || `_`, `_push`, `_parent`, `_scopeId`], void 0, true, true, loc);
          wipEntries.push({
            fn,
            children,
            vnodeBranch: vnodeBranches[wipEntries.length]
          });
          return fn;
        };
        const slots = node.children.length ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots : `null`;
        if (typeof component !== "string") {
          node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [
            `_push`,
            compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [
              component,
              props,
              slots
            ]),
            `_parent`
          ]);
        } else {
          node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, props, slots, `_parent`]);
        }
      };
    };
    function ssrProcessComponent(node, context) {
      const component = componentTypeMap.get(node);
      if (!node.ssrCodegenNode) {
        if (component === compilerDom.TELEPORT) {
          return ssrProcessTeleport(node, context);
        } else if (component === compilerDom.SUSPENSE) {
          return ssrProcessSuspense(node, context);
        } else if (component === compilerDom.TRANSITION_GROUP) {
          return ssrProcessTransitionGroup(node, context);
        } else {
          processChildren(node.children, context);
        }
      } else {
        const wipEntries = wipMap$1.get(node) || [];
        for (let i = 0; i < wipEntries.length; i++) {
          const { fn, children, vnodeBranch } = wipEntries[i];
          fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(children, context, false, true), vnodeBranch);
        }
        if (context.withSlotScopeId) {
          node.ssrCodegenNode.arguments.push(`_scopeId`);
        }
        if (typeof component === "string") {
          context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));
        } else {
          context.pushStatement(node.ssrCodegenNode);
        }
      }
    }
    var rawOptionsMap = new WeakMap();
    var [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);
    var vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];
    var vnodeDirectiveTransforms = Object.assign(Object.assign({}, baseDirectiveTransforms), compilerDom.DOMDirectiveTransforms);
    function createVNodeSlotBranch(props, children, parentContext) {
      const rawOptions = rawOptionsMap.get(parentContext.root);
      const subOptions = Object.assign(Object.assign({}, rawOptions), {
        nodeTransforms: [
          ...vnodeNodeTransforms,
          ...rawOptions.nodeTransforms || []
        ],
        directiveTransforms: Object.assign(Object.assign({}, vnodeDirectiveTransforms), rawOptions.directiveTransforms || {})
      });
      const wrapperNode = {
        type: 1,
        ns: 0,
        tag: "template",
        tagType: 3,
        isSelfClosing: false,
        props: [
          {
            type: 7,
            name: "slot",
            exp: props,
            arg: void 0,
            modifiers: [],
            loc: compilerDom.locStub
          }
        ],
        children,
        loc: compilerDom.locStub,
        codegenNode: void 0
      };
      subTransform(wrapperNode, subOptions, parentContext);
      return compilerDom.createReturnStatement(children);
    }
    function subTransform(node, options, parentContext) {
      const childRoot = compilerDom.createRoot([node]);
      const childContext = compilerDom.createTransformContext(childRoot, options);
      childContext.ssr = false;
      childContext.scopes = Object.assign({}, parentContext.scopes);
      childContext.identifiers = Object.assign({}, parentContext.identifiers);
      childContext.imports = parentContext.imports;
      compilerDom.traverseNode(childRoot, childContext);
      ["helpers", "components", "directives"].forEach((key) => {
        childContext[key].forEach((value, helperKey) => {
          if (key === "helpers") {
            const parentCount = parentContext.helpers.get(helperKey);
            if (parentCount === void 0) {
              parentContext.helpers.set(helperKey, value);
            } else {
              parentContext.helpers.set(helperKey, value + parentCount);
            }
          } else {
            parentContext[key].add(value);
          }
        });
      });
    }
    function clone(v) {
      if (shared.isArray(v)) {
        return v.map(clone);
      } else if (shared.isObject(v)) {
        const res = {};
        for (const key in v) {
          res[key] = clone(v[key]);
        }
        return res;
      } else {
        return v;
      }
    }
    var rawChildrenMap = new WeakMap();
    var ssrTransformElement = (node, context) => {
      if (node.type !== 1 || node.tagType !== 0) {
        return;
      }
      return function ssrPostTransformElement() {
        const openTag = [`<${node.tag}`];
        const needTagForRuntime = node.tag === "textarea" || node.tag.indexOf("-") > 0;
        const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);
        if (hasDynamicVBind) {
          const { props } = compilerDom.buildProps(node, context, node.props, true);
          if (props) {
            const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [props]);
            if (node.tag === "textarea") {
              const existingText = node.children[0];
              if (!existingText || existingText.type !== 5) {
                const tempId = `_temp${context.temps++}`;
                propsExp.arguments = [
                  compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), props)
                ];
                rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
                  compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`"value" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)
                ]));
              }
            } else if (node.tag === "input") {
              const vModel = findVModel(node);
              if (vModel) {
                const tempId = `_temp${context.temps++}`;
                const tempExp = compilerDom.createSimpleExpression(tempId, false);
                propsExp.arguments = [
                  compilerDom.createSequenceExpression([
                    compilerDom.createAssignmentExpression(tempExp, props),
                    compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [
                      tempExp,
                      compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                        tempExp,
                        vModel.exp
                      ])
                    ])
                  ])
                ];
              }
            }
            if (needTagForRuntime) {
              propsExp.arguments.push(`"${node.tag}"`);
            }
            openTag.push(propsExp);
          }
        }
        let dynamicClassBinding = void 0;
        let staticClassBinding = void 0;
        let dynamicStyleBinding = void 0;
        for (let i = 0; i < node.props.length; i++) {
          const prop = node.props[i];
          if (node.tag === "input" && isTrueFalseValue(prop)) {
            continue;
          }
          if (prop.type === 7) {
            if (prop.name === "html" && prop.exp) {
              rawChildrenMap.set(node, prop.exp);
            } else if (prop.name === "text" && prop.exp) {
              node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
            } else if (prop.name === "slot") {
              context.onError(compilerDom.createCompilerError(39, prop.loc));
            } else if (isTextareaWithValue(node, prop) && prop.exp) {
              if (!hasDynamicVBind) {
                node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
              }
            } else {
              const directiveTransform = context.directiveTransforms[prop.name];
              if (!directiveTransform) {
                context.onError(createSSRCompilerError(60, prop.loc));
              } else if (!hasDynamicVBind) {
                const { props, ssrTagParts } = directiveTransform(prop, node, context);
                if (ssrTagParts) {
                  openTag.push(...ssrTagParts);
                }
                for (let j = 0; j < props.length; j++) {
                  const { key, value } = props[j];
                  if (compilerDom.isStaticExp(key)) {
                    let attrName = key.content;
                    if (attrName === "key" || attrName === "ref") {
                      continue;
                    }
                    if (attrName === "class") {
                      openTag.push(` class="`, dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `"`);
                    } else if (attrName === "style") {
                      if (dynamicStyleBinding) {
                        mergeCall(dynamicStyleBinding, value);
                      } else {
                        openTag.push(` style="`, dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `"`);
                      }
                    } else {
                      attrName = node.tag.indexOf("-") > 0 ? attrName : shared.propsToAttrMap[attrName] || attrName.toLowerCase();
                      if (shared.isBooleanAttr(attrName)) {
                        openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(" " + attrName, true), compilerDom.createSimpleExpression("", true), false));
                      } else if (shared.isSSRSafeAttrName(attrName)) {
                        openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [
                          key,
                          value
                        ]));
                      } else {
                        context.onError(createSSRCompilerError(61, key.loc));
                      }
                    }
                  } else {
                    const args = [key, value];
                    if (needTagForRuntime) {
                      args.push(`"${node.tag}"`);
                    }
                    openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
                  }
                }
              }
            }
          } else {
            if (node.tag === "textarea" && prop.name === "value" && prop.value) {
              rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));
            } else if (!hasDynamicVBind) {
              if (prop.name === "key" || prop.name === "ref") {
                continue;
              }
              if (prop.name === "class" && prop.value) {
                staticClassBinding = JSON.stringify(prop.value.content);
              }
              openTag.push(` ${prop.name}` + (prop.value ? `="${shared.escapeHtml(prop.value.content)}"` : ``));
            }
          }
        }
        if (dynamicClassBinding && staticClassBinding) {
          mergeCall(dynamicClassBinding, staticClassBinding);
          removeStaticBinding(openTag, "class");
        }
        if (context.scopeId) {
          openTag.push(` ${context.scopeId}`);
        }
        node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);
      };
    };
    function isTrueFalseValue(prop) {
      if (prop.type === 7) {
        return prop.name === "bind" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
      } else {
        return prop.name === "true-value" || prop.name === "false-value";
      }
    }
    function isTextareaWithValue(node, prop) {
      return !!(node.tag === "textarea" && prop.name === "bind" && compilerDom.isBindKey(prop.arg, "value"));
    }
    function mergeCall(call, arg) {
      const existing = call.arguments[0];
      if (existing.type === 17) {
        existing.elements.push(arg);
      } else {
        call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);
      }
    }
    function removeStaticBinding(tag, binding) {
      const regExp = new RegExp(`^ ${binding}=".+"$`);
      const i = tag.findIndex((e) => typeof e === "string" && regExp.test(e));
      if (i > -1) {
        tag.splice(i, 1);
      }
    }
    function findVModel(node) {
      return node.props.find((p) => p.type === 7 && p.name === "model" && p.exp);
    }
    function ssrProcessElement(node, context) {
      const isVoidTag = context.options.isVoidTag || shared.NO;
      const elementsToAdd = node.ssrCodegenNode.elements;
      for (let j = 0; j < elementsToAdd.length; j++) {
        context.pushStringPart(elementsToAdd[j]);
      }
      if (context.withSlotScopeId) {
        context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));
      }
      context.pushStringPart(`>`);
      const rawChildren = rawChildrenMap.get(node);
      if (rawChildren) {
        context.pushStringPart(rawChildren);
      } else if (node.children.length) {
        processChildren(node.children, context);
      }
      if (!isVoidTag(node.tag)) {
        context.pushStringPart(`</${node.tag}>`);
      }
    }
    function ssrCodegenTransform(ast, options) {
      const context = createSSRTransformContext(ast, options);
      if (options.ssrCssVars) {
        const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), compilerDom.createTransformContext(compilerDom.createRoot([]), options));
        context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));
      }
      const isFragment = ast.children.length > 1 && ast.children.some((c) => !compilerDom.isText(c));
      processChildren(ast.children, context, isFragment);
      ast.codegenNode = compilerDom.createBlockStatement(context.body);
      ast.ssrHelpers = Array.from(new Set([...ast.helpers.filter((h) => h in ssrHelpers), ...context.helpers]));
      ast.helpers = ast.helpers.filter((h) => !(h in ssrHelpers));
    }
    function createSSRTransformContext(root, options, helpers = new Set(), withSlotScopeId = false) {
      const body = [];
      let currentString = null;
      return {
        root,
        options,
        body,
        helpers,
        withSlotScopeId,
        onError: options.onError || ((e) => {
          throw e;
        }),
        helper(name) {
          helpers.add(name);
          return name;
        },
        pushStringPart(part) {
          if (!currentString) {
            const currentCall = compilerDom.createCallExpression(`_push`);
            body.push(currentCall);
            currentString = compilerDom.createTemplateLiteral([]);
            currentCall.arguments.push(currentString);
          }
          const bufferedElements = currentString.elements;
          const lastItem = bufferedElements[bufferedElements.length - 1];
          if (shared.isString(part) && shared.isString(lastItem)) {
            bufferedElements[bufferedElements.length - 1] += part;
          } else {
            bufferedElements.push(part);
          }
        },
        pushStatement(statement) {
          currentString = null;
          body.push(statement);
        }
      };
    }
    function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
      return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
    }
    function processChildren(children, context, asFragment = false, disableNestedFragments = false) {
      if (asFragment) {
        context.pushStringPart(`<!--[-->`);
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
          case 1:
            switch (child.tagType) {
              case 0:
                ssrProcessElement(child, context);
                break;
              case 1:
                ssrProcessComponent(child, context);
                break;
              case 2:
                ssrProcessSlotOutlet(child, context);
                break;
              case 3:
                break;
              default:
                context.onError(createSSRCompilerError(63, child.loc));
                const exhaustiveCheck2 = child;
                return exhaustiveCheck2;
            }
            break;
          case 2:
            context.pushStringPart(shared.escapeHtml(child.content));
            break;
          case 3:
            context.pushStringPart(`<!--${child.content}-->`);
            break;
          case 5:
            context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));
            break;
          case 9:
            ssrProcessIf(child, context, disableNestedFragments);
            break;
          case 11:
            ssrProcessFor(child, context, disableNestedFragments);
            break;
          case 10:
            break;
          case 12:
          case 8:
            break;
          default:
            context.onError(createSSRCompilerError(63, child.loc));
            const exhaustiveCheck = child;
            return exhaustiveCheck;
        }
      }
      if (asFragment) {
        context.pushStringPart(`<!--]-->`);
      }
    }
    function processChildrenAsStatement(children, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
      const childContext = createChildContext(parentContext, withSlotScopeId);
      processChildren(children, childContext, asFragment);
      return compilerDom.createBlockStatement(childContext.body);
    }
    var ssrTransformModel = (dir, node, context) => {
      const model = dir.exp;
      function checkDuplicatedValue() {
        const value = compilerDom.findProp(node, "value");
        if (value) {
          context.onError(compilerDom.createDOMCompilerError(56, value.loc));
        }
      }
      if (node.tagType === 0) {
        const res = { props: [] };
        const defaultProps = [
          compilerDom.createObjectProperty(`value`, model)
        ];
        if (node.tag === "input") {
          const type = compilerDom.findProp(node, "type");
          if (type) {
            const value = findValueBinding(node);
            if (type.type === 7) {
              res.ssrTagParts = [
                compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
                  type.exp,
                  model,
                  value
                ])
              ];
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  res.props = [
                    compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                      model,
                      value
                    ]))
                  ];
                  break;
                case "checkbox":
                  const trueValueBinding = compilerDom.findProp(node, "true-value");
                  if (trueValueBinding) {
                    const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                    res.props = [
                      compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                        model,
                        trueValue
                      ]))
                    ];
                  } else {
                    res.props = [
                      compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                        model,
                        value
                      ]), model))
                    ];
                  }
                  break;
                case "file":
                  context.onError(compilerDom.createDOMCompilerError(55, dir.loc));
                  break;
                default:
                  checkDuplicatedValue();
                  res.props = defaultProps;
                  break;
              }
            }
          } else if (compilerDom.hasDynamicKeyVBind(node))
            ;
          else {
            checkDuplicatedValue();
            res.props = defaultProps;
          }
        } else if (node.tag === "textarea") {
          checkDuplicatedValue();
          node.children = [compilerDom.createInterpolation(model, model.loc)];
        } else if (node.tag === "select")
          ;
        else {
          context.onError(compilerDom.createDOMCompilerError(53, dir.loc));
        }
        return res;
      } else {
        return compilerDom.transformModel(dir, node, context);
      }
    };
    function findValueBinding(node) {
      const valueBinding = compilerDom.findProp(node, "value");
      return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);
    }
    var ssrTransformShow = (dir, node, context) => {
      if (!dir.exp) {
        context.onError(compilerDom.createDOMCompilerError(57));
      }
      return {
        props: [
          compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([
            compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))
          ]), false))
        ]
      };
    };
    var hasSingleChild = (node) => node.children.filter((n) => n.type !== 3).length === 1;
    var ssrInjectFallthroughAttrs = (node, context) => {
      if (node.type === 0) {
        context.identifiers._attrs = 1;
      }
      if (node.type === 1 && node.tagType === 1 && (compilerDom.isBuiltInType(node.tag, "Transition") || compilerDom.isBuiltInType(node.tag, "KeepAlive"))) {
        if (hasSingleChild(node)) {
          injectFallthroughAttrs(node.children[0]);
        }
        return;
      }
      const parent = context.parent;
      if (!parent || parent.type !== 0) {
        return;
      }
      if (node.type === 10 && hasSingleChild(node)) {
        injectFallthroughAttrs(node.children[0]);
      } else if (hasSingleChild(parent)) {
        injectFallthroughAttrs(node);
      }
    };
    function injectFallthroughAttrs(node) {
      if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
        node.props.push({
          type: 7,
          name: "bind",
          arg: void 0,
          exp: compilerDom.createSimpleExpression(`_attrs`, false),
          modifiers: [],
          loc: compilerDom.locStub
        });
      }
    }
    var ssrInjectCssVars = (node, context) => {
      if (!context.ssrCssVars) {
        return;
      }
      if (node.type === 0) {
        context.identifiers._cssVars = 1;
      }
      const parent = context.parent;
      if (!parent || parent.type !== 0) {
        return;
      }
      if (node.type === 10) {
        for (const child of node.children) {
          injectCssVars(child);
        }
      } else {
        injectCssVars(node);
      }
    };
    function injectCssVars(node) {
      if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
        if (compilerDom.isBuiltInType(node.tag, "Suspense")) {
          for (const child of node.children) {
            if (child.type === 1 && child.tagType === 3) {
              child.children.forEach(injectCssVars);
            } else {
              injectCssVars(child);
            }
          }
        } else {
          node.props.push({
            type: 7,
            name: "bind",
            arg: void 0,
            exp: compilerDom.createSimpleExpression(`_cssVars`, false),
            modifiers: [],
            loc: compilerDom.locStub
          });
        }
      }
    }
    function compile(template2, options = {}) {
      options = Object.assign(Object.assign(Object.assign({}, options), compilerDom.parserOptions), {
        ssr: true,
        inSSR: true,
        scopeId: options.mode === "function" ? null : options.scopeId,
        prefixIdentifiers: true,
        cacheHandlers: false,
        hoistStatic: false
      });
      const ast = compilerDom.baseParse(template2, options);
      rawOptionsMap.set(ast, options);
      compilerDom.transform(ast, Object.assign(Object.assign({}, options), { hoistStatic: false, nodeTransforms: [
        ssrTransformIf,
        ssrTransformFor,
        compilerDom.trackVForSlotScopes,
        compilerDom.transformExpression,
        ssrTransformSlotOutlet,
        ssrInjectFallthroughAttrs,
        ssrInjectCssVars,
        ssrTransformElement,
        ssrTransformComponent,
        compilerDom.trackSlotScopes,
        compilerDom.transformStyle,
        ...options.nodeTransforms || []
      ], directiveTransforms: Object.assign({
        bind: compilerDom.transformBind,
        model: ssrTransformModel,
        show: ssrTransformShow,
        on: compilerDom.noopDirectiveTransform,
        cloak: compilerDom.noopDirectiveTransform,
        once: compilerDom.noopDirectiveTransform
      }, options.directiveTransforms || {}) }));
      ssrCodegenTransform(ast, options);
      return compilerDom.generate(ast, options);
    }
    exports2.compile = compile;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/colorette-npm-1.3.0-850a0c65bc-bda403dfba.zip/node_modules/colorette/index.cjs
var require_colorette = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/colorette-npm-1.3.0-850a0c65bc-bda403dfba.zip/node_modules/colorette/index.cjs"(exports2) {
    var env2 = process.env;
    var isDisabled = "NO_COLOR" in env2;
    var isForced = "FORCE_COLOR" in env2;
    var isWindows = process.platform === "win32";
    var isCompatibleTerminal = process.stdout != null && process.stdout.isTTY && env2.TERM && env2.TERM !== "dumb";
    var isCI = "CI" in env2 && ("GITHUB_ACTIONS" in env2 || "GITLAB_CI" in env2 || "CIRCLECI" in env2);
    var enabled = !isDisabled && (isForced || isWindows || isCompatibleTerminal || isCI);
    var raw = (open, close, searchRegex, replaceValue) => (s) => enabled ? open + (~(s += "").indexOf(close, 4) ? s.replace(searchRegex, replaceValue) : s) + close : s;
    var init = (open, close) => {
      return raw(`[${open}m`, `[${close}m`, new RegExp(`\\x1b\\[${close}m`, "g"), `[${open}m`);
    };
    exports2.options = Object.defineProperty({}, "enabled", {
      get: () => enabled,
      set: (value) => enabled = value
    });
    exports2.reset = init(0, 0);
    exports2.bold = raw("[1m", "[22m", /\x1b\[22m/g, "[22m[1m");
    exports2.dim = raw("[2m", "[22m", /\x1b\[22m/g, "[22m[2m");
    exports2.italic = init(3, 23);
    exports2.underline = init(4, 24);
    exports2.inverse = init(7, 27);
    exports2.hidden = init(8, 28);
    exports2.strikethrough = init(9, 29);
    exports2.black = init(30, 39);
    exports2.red = init(31, 39);
    exports2.green = init(32, 39);
    exports2.yellow = init(33, 39);
    exports2.blue = init(34, 39);
    exports2.magenta = init(35, 39);
    exports2.cyan = init(36, 39);
    exports2.white = init(37, 39);
    exports2.gray = init(90, 39);
    exports2.bgBlack = init(40, 49);
    exports2.bgRed = init(41, 49);
    exports2.bgGreen = init(42, 49);
    exports2.bgYellow = init(43, 49);
    exports2.bgBlue = init(44, 49);
    exports2.bgMagenta = init(45, 49);
    exports2.bgCyan = init(46, 49);
    exports2.bgWhite = init(47, 49);
    exports2.blackBright = init(90, 39);
    exports2.redBright = init(91, 39);
    exports2.greenBright = init(92, 39);
    exports2.yellowBright = init(93, 39);
    exports2.blueBright = init(94, 39);
    exports2.magentaBright = init(95, 39);
    exports2.cyanBright = init(96, 39);
    exports2.whiteBright = init(97, 39);
    exports2.bgBlackBright = init(100, 49);
    exports2.bgRedBright = init(101, 49);
    exports2.bgGreenBright = init(102, 49);
    exports2.bgYellowBright = init(103, 49);
    exports2.bgBlueBright = init(104, 49);
    exports2.bgMagentaBright = init(105, 49);
    exports2.bgCyanBright = init(106, 49);
    exports2.bgWhiteBright = init(107, 49);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer(input, options = {}) {
      let css = input.css.valueOf();
      let ignore = options.ignoreErrors;
      let code, next, quote, content, escape;
      let escaped, escapePos, prev, n, currentToken;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n = css.charCodeAt(pos + 1);
            if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape = !escape;
            }
            code = css.charCodeAt(next + 1);
            if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        nextToken,
        endOfFile,
        position
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/terminal-highlight.js"(exports2, module2) {
    "use strict";
    var { cyan, gray, green, yellow, magenta } = require_colorette();
    var tokenizer = require_tokenize();
    var Input;
    function registerInput(dependant) {
      Input = dependant;
    }
    var HIGHLIGHT_THEME = {
      "brackets": cyan,
      "at-word": cyan,
      "comment": gray,
      "string": green,
      "class": yellow,
      "hash": magenta,
      "call": cyan,
      "(": cyan,
      ")": cyan,
      "{": yellow,
      "}": yellow,
      "[": yellow,
      "]": yellow,
      ":": yellow,
      ";": yellow
    };
    function getTokenType([type, value], processor) {
      if (type === "word") {
        if (value[0] === ".") {
          return "class";
        }
        if (value[0] === "#") {
          return "hash";
        }
      }
      if (!processor.endOfFile()) {
        let next = processor.nextToken();
        processor.back(next);
        if (next[0] === "brackets" || next[0] === "(")
          return "call";
      }
      return type;
    }
    function terminalHighlight(css) {
      let processor = tokenizer(new Input(css), { ignoreErrors: true });
      let result = "";
      while (!processor.endOfFile()) {
        let token = processor.nextToken();
        let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
        if (color) {
          result += token[1].split(/\r?\n/).map((i) => color(i)).join("\n");
        } else {
          result += token[1];
        }
      }
      return result;
    }
    terminalHighlight.registerInput = registerInput;
    module2.exports = terminalHighlight;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var { red, bold, gray, options: colorette } = require_colorette();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class extends Error {
      constructor(message, line, column, source, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          this.line = line;
          this.column = column;
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color == null)
          color = colorette.enabled;
        if (terminalHighlight) {
          if (color)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color) {
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark = aside = (str) => str;
        }
        return lines.slice(start, end).map((line, index) => {
          let number = start + 1 + index;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      colon: ": ",
      indent: "    ",
      beforeDecl: "\n",
      beforeRule: "\n",
      beforeOpen: " ",
      beforeClose: "\n",
      beforeComment: "\n",
      after: "\n",
      emptyBody: "",
      commentLeft: " ",
      commentRight: " ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error("Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier.");
        }
        this[node.type](node, semicolon);
      }
      document(node) {
        this.body(node);
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string += node.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      atrule(node, semicolon) {
        let name = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name += node.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node);
        }
      }
      body(node) {
        let last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i || semicolon);
        }
      }
      block(node, start) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      }
      raw(node, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root = node.root();
        if (!root.rawCache)
          root.rawCache = {};
        if (typeof root.rawCache[detect] !== "undefined") {
          return root.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node);
          } else {
            root.walk((i) => {
              value = i.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        return value;
      }
      rawSemicolon(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length && i.last.type === "decl") {
            value = i.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawEmptyBody(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length === 0) {
            value = i.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root) {
        if (root.raws.indent)
          return root.raws.indent;
        let value;
        root.walk((i) => {
          let p = i.parent;
          if (p && p !== root && p.parent && p.parent === root) {
            if (typeof i.raws.before !== "undefined") {
              let parts = i.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawBeforeComment(root, node) {
        let value;
        root.walkComments((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root, node) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeRule(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && (i.parent !== root || root.first !== i)) {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeClose(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== "undefined") {
              value = i.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeOpen(root) {
        let value;
        root.walk((i) => {
          if (i.type !== "decl") {
            value = i.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawColon(root) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.between !== "undefined") {
            value = i.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      beforeAfter(node, detect) {
        let value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value += indent;
          }
        }
        return value;
      }
      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
    };
    module2.exports = Stringifier;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify2(node, builder) {
      let str = new Stringifier(builder);
      str.stringify(node);
    }
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/node.js
var require_node2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify2 = require_stringify2();
    function cloneNode(obj2, parent) {
      let cloned = new obj2.constructor();
      for (let i in obj2) {
        if (!Object.prototype.hasOwnProperty.call(obj2, i)) {
          continue;
        }
        if (i === "proxyCache")
          continue;
        let value = obj2[i];
        let type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent)
            cloned[i] = parent;
        } else if (i === "source") {
          cloned[i] = value;
        } else if (Array.isArray(value)) {
          cloned[i] = value.map((j) => cloneNode(j, cloned));
        } else {
          if (type === "object" && value !== null)
            value = cloneNode(value);
          cloned[i] = value;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node of defaults[name]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults[name];
          }
        }
      }
      error(message, opts = {}) {
        if (this.source) {
          let pos = this.positionBy(opts);
          return this.source.input.error(message, pos.line, pos.column, opts);
        }
        return new CssSyntaxError(message);
      }
      warn(result, text, opts) {
        let data = { node: this };
        for (let i in opts)
          data[i] = opts[i];
        return result.warn(text, data);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      toString(stringifier = stringify2) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i) => {
          result += i;
        });
        return result;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      next() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index + 1];
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index - 1];
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      toJSON(_, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i) => {
              if (typeof i === "object" && i.toJSON) {
                return i.toJSON(null, inputs);
              } else {
                return i;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              inputId,
              start: value.start,
              end: value.end
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      positionInside(index) {
        let string = this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i = 0; i < index; i++) {
          if (string[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { line, column };
      }
      positionBy(opts) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index);
        } else if (opts.word) {
          let index = this.toString().indexOf(opts.word);
          if (index !== -1)
            pos = this.positionInside(index);
        }
        return pos;
      }
      getProxyProcessor() {
        return {
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
              node.markDirty();
            }
            return true;
          },
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          }
        };
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s = this.source;
          error.stack = error.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
        }
        return error;
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node2;
    Node2.default = Node2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node2();
    var Declaration = class extends Node2 {
      constructor(defaults) {
        if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
          defaults = { ...defaults, value: String(defaults.value) };
        }
        super(defaults);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/base64.js
var require_base642 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base642();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/util.js
var require_util2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj2 = Object.create(null);
      return !("__proto__" in obj2);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/array-set.js
var require_array_set2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util = require_util2();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq2();
    var util = require_util2();
    var ArraySet = require_array_set2().ArraySet;
    var MappingList = require_mapping_list2().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/binary-search.js
var require_binary_search2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/quick-sort.js"(exports2) {
    function SortTemplate(comparator) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator2, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator2(ary[j], pivot, false) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator2, p, q - 1);
          doQuickSort(ary, comparator2, q + 1, r);
        }
      }
      return doQuickSort;
    }
    function cloneSort(comparator) {
      let template2 = SortTemplate.toString();
      let templateFn = new Function(`return ${template2}`)();
      return templateFn(comparator);
    }
    var sortCache = new WeakMap();
    exports2.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort = sortCache.get(comparator);
      if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
      }
      doQuickSort(ary, comparator, start, ary.length - 1);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-map-consumer.js"(exports2) {
    var util = require_util2();
    var binarySearch = require_binary_search2();
    var ArraySet = require_array_set2().ArraySet;
    var base64VLQ = require_base64_vlq2();
    var quickSort = require_quick_sort2().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array, start) {
      let l = array.length;
      let n = array.length - start;
      if (n <= 1) {
        return;
      } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
          array[start] = b;
          array[start + 1] = a;
        }
      } else if (n < 20) {
        for (let i = start; i < l; i++) {
          for (let j = i; j > start; j--) {
            let a = array[j - 1];
            let b = array[j];
            if (compareGenerated(a, b) <= 0) {
              break;
            }
            array[j - 1] = b;
            array[j] = a;
          }
        }
      } else {
        quickSort(array, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      let subarrayStart = 0;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i = 0; i < originalMappings.length; i++) {
        if (originalMappings[i] != null) {
          quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret2 = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret2;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-node.js
var require_source_node2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
    var util = require_util2();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/source-map.js
var require_source_map2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-js-npm-0.6.2-af388ea7f1-9c8151a29e.zip/node_modules/source-map-js/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer2().SourceMapConsumer;
    exports2.SourceNode = require_source_node2().SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map2();
    var { dirname, resolve, relative, sep } = require("path");
    var { pathToFileURL } = require("url");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve && relative && sep);
    var MapGenerator = class {
      constructor(stringify2, root, opts) {
        this.stringify = stringify2;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          this.root.walk((node) => {
            if (node.source && node.source.input.map) {
              let map = node.source.input.map;
              if (!this.previousMaps.includes(map)) {
                this.previousMaps.push(map);
              }
            }
          });
        }
        return this.previousMaps;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.inline);
        }
        return true;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.withContent());
        }
        return true;
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        let node;
        for (let i = this.root.nodes.length - 1; i >= 0; i--) {
          node = this.root.nodes[i];
          if (node.type !== "comment")
            continue;
          if (node.text.indexOf("# sourceMappingURL=") === 0) {
            this.root.removeChild(i);
          }
        }
      }
      setSourcesContent() {
        let already = {};
        this.root.walk((node) => {
          if (node.source) {
            let from = node.source.input.from;
            if (from && !already[from]) {
              already[from] = true;
              this.map.setSourceContent(this.toUrl(this.path(from)), node.source.input.css);
            }
          }
        });
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root = prev.root || dirname(prev.file);
          let map;
          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);
            if (map.sourcesContent) {
              map.sourcesContent = map.sourcesContent.map(() => null);
            }
          } else {
            map = prev.consumer();
          }
          this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
        }
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.annotation);
        }
        return true;
      }
      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        }
        if (this.opts.from) {
          return this.path(this.opts.from);
        }
        return "to.css";
      }
      generateMap() {
        this.generateString();
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        }
        return [this.css, this.map];
      }
      path(file) {
        if (file.indexOf("<") === 0)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        if (this.mapOpts.absolute)
          return file;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve(from, this.mapOpts.annotation));
        }
        file = relative(from, file);
        return file;
      }
      toUrl(path) {
        if (sep === "\\") {
          path = path.replace(/\\/g, "/");
        }
        return encodeURI(path).replace(/[#?]/g, encodeURIComponent);
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.mapOpts.absolute) {
          if (pathToFileURL) {
            return pathToFileURL(node.source.input.from).toString();
          } else {
            throw new Error("`map.absolute` option is not available in this PostCSS build");
          }
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({ file: this.outputFile() });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          source: "",
          generated: { line: 0, column: 0 },
          original: { line: 0, column: 0 }
        };
        let lines, last;
        this.stringify(this.root, (str, node, type) => {
          this.css += str;
          if (node && type !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node && type !== "start") {
            let p = node.parent || { raws: {} };
            if (node.type !== "decl" || node !== p.last || p.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        }
        let result = "";
        this.stringify(this.root, (i) => {
          result += i;
        });
        return [result];
      }
    };
    module2.exports = MapGenerator;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node2();
    var Comment = class extends Node2 {
      constructor(defaults) {
        super(defaults);
        this.type = "comment";
      }
    };
    module2.exports = Comment;
    Comment.default = Comment;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment = require_comment();
    var Node2 = require_node2();
    var parse3;
    var Rule;
    var AtRule;
    function cleanSource(nodes) {
      return nodes.map((i) => {
        if (i.nodes)
          i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
      });
    }
    function markDirtyUp(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i of node.proxyOf.nodes) {
          markDirtyUp(i);
        }
      }
    }
    var Container = class extends Node2 {
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index], index);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      walk(callback) {
        return this.each((child, i) => {
          let result;
          try {
            result = callback(child, i);
          } catch (e) {
            throw child.addToError(e);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i) => {
            if (child.type === "decl") {
              return callback(child, i);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i) => {
            if (child.type === "rule") {
              return callback(child, i);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i);
          }
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i) => {
            if (child.type === "atrule") {
              return callback(child, i);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i) => {
          if (child.type === "comment") {
            return callback(child, i);
          }
        });
      }
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      insertBefore(exist, add) {
        exist = this.index(exist);
        let type = exist === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();
        for (let node of nodes)
          this.proxyOf.nodes.splice(exist, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (exist <= index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertAfter(exist, add) {
        exist = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
        for (let node of nodes)
          this.proxyOf.nodes.splice(exist + 1, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (exist < index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        this.markDirty();
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern, callback);
        });
        this.markDirty();
        return this;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse3(nodes).nodes);
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i) => {
          if (!i[my])
            Container.rebuild(i);
          i = i.proxyOf;
          if (i.parent)
            i.parent.removeChild(i);
          if (i[isClean])
            markDirtyUp(i);
          if (typeof i.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i.parent = this;
          return i;
        });
        return processed;
      }
      getProxyProcessor() {
        return {
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          },
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](...args.map((i) => {
                  if (typeof i === "function") {
                    return (child, index) => i(child.toProxy(), index);
                  } else {
                    return i;
                  }
                }));
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i) => i.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          }
        };
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
    };
    Container.registerParse = (dependant) => {
      parse3 = dependant;
    };
    Container.registerRule = (dependant) => {
      Rule = dependant;
    };
    Container.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    module2.exports = Container;
    Container.default = Container;
    Container.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container.rebuild(child);
        });
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Document = class extends Container {
      constructor(defaults) {
        super({ type: "document", ...defaults });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Document.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Document;
    Document.default = Document;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let pos = opts.node.positionBy(opts);
          this.line = pos.line;
          this.column = pos.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning;
    Warning.default = Warning;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i) => i.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result;
    Result.default = Result;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var AtRule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module2.exports = AtRule;
    AtRule.default = AtRule;
    Container.registerAtRule(AtRule);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Root = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      removeChild(child, ignore) {
        let index = this.index(child);
        if (!ignore && index === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index].raws.before;
        }
        return super.removeChild(child);
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Root;
    Root.default = Root;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list = {
      split(string, separators, last) {
        let array = [];
        let current = "";
        let split = false;
        let func = 0;
        let quote = false;
        let escape = false;
        for (let letter of string) {
          if (escape) {
            escape = false;
          } else if (letter === "\\") {
            escape = true;
          } else if (quote) {
            if (letter === quote) {
              quote = false;
            }
          } else if (letter === '"' || letter === "'") {
            quote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array.push(current.trim());
        return array;
      },
      space(string) {
        let spaces = [" ", "\n", "	"];
        return list.split(string, spaces);
      },
      comma(string) {
        return list.split(string, [","], true);
      }
    };
    module2.exports = list;
    list.default = list;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var list = require_list();
    var Rule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list.comma(this.selector);
      }
      set selectors(values) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module2.exports = Rule;
    Rule.default = Rule;
    Container.registerRule(Rule);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer = require_tokenize();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root();
    var Rule = require_rule();
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.customProperty = false;
        this.createTokenizer();
        this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      comment(token) {
        let node = new Comment();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }
      emptyRule(token) {
        let node = new Rule();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== "space" && token !== "comment")
              break;
            this.tokenizer.back(tokens.pop());
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      decl(tokens, customProperty) {
        let node = new Declaration();
        this.init(node, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(last[3] || last[2]);
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);
        for (let i = tokens.length - 1; i >= 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string = this.stringFrom(tokens, i);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node.raws.important = string;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache = tokens.slice(0);
            let str = "";
            for (let j = i; j > 0; j--) {
              let type = cache[j][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str;
              tokens = cache;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
        this.raw(node, "value", tokens);
        if (hasWord) {
          node.raws.between += firstSpaces;
        } else {
          node.value = firstSpaces + node.value;
        }
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      atrule(token) {
        let node = new AtRule();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node.source.end = this.getPosition(token[2]);
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          offset,
          line: pos.line,
          column: pos.col
        };
      }
      init(node, offset) {
        this.current.push(node);
        node.source = {
          start: this.getPosition(offset),
          input: this.input
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      raw(node, prop, tokens) {
        let token, type;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        let pattern = /^([#.|])?(\w)+/i;
        for (let i = 0; i < length; i += 1) {
          token = tokens[i];
          type = token[0];
          if (type === "comment" && node.type === "rule") {
            prev = tokens[i - 1];
            next = tokens[i + 1];
            if (prev[0] !== "space" && next[0] !== "space" && pattern.test(prev[1]) && pattern.test(next[1])) {
              value += token[1];
            } else {
              clean = false;
            }
            continue;
          }
          if (type === "comment" || type === "space" && i === length - 1) {
            clean = false;
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i) => all + i[1], "");
          node.raws[prop] = { value, raw };
        }
        node[prop] = value;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result = "";
        for (let i = from; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      }
      colon(tokens) {
        let brackets = 0;
        let token, type, prev;
        for (let [i, element] of tokens.entries()) {
          token = element;
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i;
            }
          }
          prev = token;
        }
        return false;
      }
      unclosedBracket(bracket) {
        throw this.input.error("Unclosed bracket", bracket[2]);
      }
      unknownWord(tokens) {
        throw this.input.error("Unknown word", tokens[0][2]);
      }
      unexpectedClose(token) {
        throw this.input.error("Unexpected }", token[2]);
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      doubleColon(token) {
        throw this.input.error("Double colon", token[2]);
      }
      unnamedAtrule(node, token) {
        throw this.input.error("At-rule without name", token[2]);
      }
      precheckMissedSemicolon() {
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j = colon - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
      }
    };
    module2.exports = Parser;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/nanoid-npm-3.1.25-c8f62ce160-e2353828c7.zip/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/nanoid-npm-3.1.25-c8f62ce160-e2353828c7.zip/node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var customAlphabet = (alphabet, size) => {
      return () => {
        let id = "";
        let i = size;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module2.exports = { nanoid, customAlphabet };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map2();
    var { existsSync, readFileSync } = require("fs");
    var { dirname, join } = require("path");
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
      startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
      }
      loadAnnotation(css) {
        let annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
        if (annotations && annotations.length > 0) {
          let lastAnnotation = annotations[annotations.length - 1];
          if (lastAnnotation) {
            this.annotation = this.getAnnotationURL(lastAnnotation);
          }
        }
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      loadFile(path) {
        this.root = dirname(path);
        if (existsSync(path)) {
          this.mapFile = path;
          return readFileSync(path, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map = this.loadFile(prevPath);
              if (!map) {
                throw new Error("Unable to load previous source map: " + prevPath.toString());
              }
              return map;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error("Unsupported previous source map format: " + prev.toString());
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map = this.annotation;
          if (file)
            map = join(dirname(file), map);
          return this.loadFile(map);
        }
      }
      isMap(map) {
        if (typeof map !== "object")
          return false;
        return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map2();
    var { fileURLToPath, pathToFileURL } = require("url");
    var { resolve, isAbsolute } = require("path");
    var { nanoid } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve && isAbsolute);
    var Input = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map = new PreviousMap(this.css, opts);
          if (map.text) {
            this.map = map;
            let file = map.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i = 0, l = lines.length; i < l; i++) {
            lineToIndex[i] = prevIndex;
            prevIndex += lines[i].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min = 0;
        if (offset >= lastLine) {
          min = lineToIndex.length - 1;
        } else {
          let max = lineToIndex.length - 2;
          let mid;
          while (min < max) {
            mid = min + (max - min >> 1);
            if (offset < lineToIndex[mid]) {
              max = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min = mid + 1;
            } else {
              min = mid;
              break;
            }
          }
        }
        return {
          line: min + 1,
          col: offset - lineToIndex[min] + 1
        };
      }
      error(message, line, column, opts = {}) {
        let result;
        if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column);
        if (origin) {
          result = new CssSyntaxError(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
        } else {
          result = new CssSyntaxError(message, line, column, this.css, this.file, opts.plugin);
        }
        result.input = { line, column, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result.input.url = pathToFileURL(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      origin(line, column) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ line, column });
        if (!from.source)
          return false;
        let fromUrl;
        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
        }
        let result = {
          url: fromUrl.toString(),
          line: from.line,
          column: from.column
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source)
          result.source = source;
        return result;
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      get from() {
        return this.file || this.id;
      }
      toJSON() {
        let json = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json[name] = this[name];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = void 0;
          }
        }
        return json;
      }
    };
    module2.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/parse.js
var require_parse3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var Parser = require_parser();
    var Input = require_input();
    function parse3(css, opts) {
      let input = new Input(css, opts);
      let parser = new Parser(input);
      try {
        parser.parse();
      } catch (e) {
        if (true) {
          if (e.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e;
      }
      return parser.root;
    }
    module2.exports = parse3;
    parse3.default = parse3;
    Container.registerParse(parse3);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify2();
    var Container = require_container();
    var Document = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse3 = require_parse3();
    var Root = require_root();
    var TYPE_TO_CLASS_NAME = {
      document: "Document",
      root: "Root",
      atrule: "AtRule",
      rule: "Rule",
      decl: "Declaration",
      comment: "Comment"
    };
    var PLUGIN_PROPS = {
      postcssPlugin: true,
      prepare: true,
      Once: true,
      Document: true,
      Root: true,
      Declaration: true,
      Rule: true,
      AtRule: true,
      Comment: true,
      DeclarationExit: true,
      RuleExit: true,
      AtRuleExit: true,
      CommentExit: true,
      RootExit: true,
      DocumentExit: true,
      OnceExit: true
    };
    var NOT_VISITORS = {
      postcssPlugin: true,
      prepare: true,
      Once: true
    };
    var CHILDREN = 0;
    function isPromise(obj2) {
      return typeof obj2 === "object" && typeof obj2.then === "function";
    }
    function getEvents(node) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key = node.name.toLowerCase();
      }
      if (key && node.append) {
        return [
          type,
          type + "-" + key,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key
        ];
      } else if (key) {
        return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
      } else if (node.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node) {
      let events;
      if (node.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node);
      }
      return {
        node,
        events,
        eventIndex: 0,
        visitors: [],
        visitorIndex: 0,
        iterator: 0
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i) => cleanMarks(i));
      return node;
    }
    var postcss = {};
    var LazyResult = class {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof Result) {
          root = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser = parse3;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root = parser(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root && !root[my]) {
            Container.rebuild(root);
          }
        }
        this.result = new Result(processor, root, opts);
        this.helpers = { ...postcss, result: this.result, postcss };
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return { ...plugin, ...plugin.prepare(this.result) };
          } else {
            return plugin;
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
      get processor() {
        return this.result.processor;
      }
      get opts() {
        return this.result.opts;
      }
      get css() {
        return this.stringify().css;
      }
      get content() {
        return this.stringify().content;
      }
      get map() {
        return this.stringify().map;
      }
      get root() {
        return this.sync().root;
      }
      get messages() {
        return this.sync().messages;
      }
      warnings() {
        return this.sync().warnings();
      }
      toString() {
        return this.css;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            this.walkSync(root);
          }
          if (this.listeners.OnceExit) {
            if (root.type === "document") {
              for (let subRoot of root.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root);
            }
          }
        }
        return this.result;
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify2;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map = new MapGenerator(str, this.result.root, this.result.opts);
        let data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      visitSync(visitors, node) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e) {
            throw this.handleError(e, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin.postcssPlugin;
            error.setMessage();
          } else if (plugin.postcssVersion) {
            if (true) {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a = pluginVer.split(".");
              let b = runtimeVer.split(".");
              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i = 0; i < this.plugins.length; i++) {
          let plugin = this.plugins[i];
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            let stack = [toStack(root)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root.type === "document") {
                  let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
                  await Promise.all(roots);
                } else {
                  await visitor(root, this.helpers);
                }
              } catch (e) {
                throw this.handleError(e);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter in plugin[event]) {
                    if (filter === "*") {
                      add(plugin, event, plugin[event][filter]);
                    } else {
                      add(plugin, event + "-" + filter.toLowerCase(), plugin[event][filter]);
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e) {
            throw this.handleError(e, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document.registerLazyResult(LazyResult);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var LazyResult = require_lazy_result();
    var Document = require_document();
    var Root = require_root();
    var Processor = class {
      constructor(plugins = []) {
        this.version = "8.3.6";
        this.plugins = this.normalize(plugins);
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
      process(css, opts = {}) {
        if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined" && !opts.hideNothingWarning) {
          if (true) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on https://www.postcss.parts/ and use them in postcss.config.js.");
            }
          }
        }
        return new LazyResult(this, css, opts);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i of plugins) {
          if (i.postcss === true) {
            i = i();
          } else if (i.postcss) {
            i = i.postcss;
          }
          if (typeof i === "object" && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === "object" && i.postcssPlugin) {
            normalized.push(i);
          } else if (typeof i === "function") {
            normalized.push(i);
          } else if (typeof i === "object" && (i.parse || i.stringify)) {
            if (true) {
              throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
            }
          } else {
            throw new Error(i + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
    };
    module2.exports = Processor;
    Processor.default = Processor;
    Root.registerProcessor(Processor);
    Document.registerProcessor(Processor);
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root();
    var Rule = require_rule();
    function fromJSON(json, inputs) {
      if (Array.isArray(json))
        return json.map((n) => fromJSON(n));
      let { inputs: ownInputs, ...defaults } = json;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json.nodes.map((n) => fromJSON(n, inputs));
      }
      if (defaults.source) {
        let { inputId, ...source } = defaults.source;
        defaults.source = source;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === "root") {
        return new Root(defaults);
      } else if (defaults.type === "decl") {
        return new Declaration(defaults);
      } else if (defaults.type === "rule") {
        return new Rule(defaults);
      } else if (defaults.type === "comment") {
        return new Comment(defaults);
      } else if (defaults.type === "atrule") {
        return new AtRule(defaults);
      } else {
        throw new Error("Unknown node type: " + json.type);
      }
    }
    module2.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-npm-8.3.6-e6c5350483-ff55b91bea.zip/node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container = require_container();
    var Processor = require_processor();
    var stringify2 = require_stringify2();
    var fromJSON = require_fromJSON();
    var Document = require_document();
    var Warning = require_warning();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse3 = require_parse3();
    var list = require_list();
    var Rule = require_rule();
    var Root = require_root();
    var Node2 = require_node2();
    function postcss(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor(plugins);
    }
    postcss.plugin = function plugin(name, initializer) {
      if (console && console.warn) {
        console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
        if (process.env.LANG && process.env.LANG.startsWith("cn")) {
          console.warn(name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226");
        }
      }
      function creator(...args) {
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor().version;
        return transformer;
      }
      let cache;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache)
            cache = creator();
          return cache;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss.stringify = stringify2;
    postcss.parse = parse3;
    postcss.fromJSON = fromJSON;
    postcss.list = list;
    postcss.comment = (defaults) => new Comment(defaults);
    postcss.atRule = (defaults) => new AtRule(defaults);
    postcss.decl = (defaults) => new Declaration(defaults);
    postcss.rule = (defaults) => new Rule(defaults);
    postcss.root = (defaults) => new Root(defaults);
    postcss.document = (defaults) => new Document(defaults);
    postcss.CssSyntaxError = CssSyntaxError;
    postcss.Declaration = Declaration;
    postcss.Container = Container;
    postcss.Document = Document;
    postcss.Comment = Comment;
    postcss.Warning = Warning;
    postcss.AtRule = AtRule;
    postcss.Result = Result;
    postcss.Input = Input;
    postcss.Rule = Rule;
    postcss.Root = Root;
    postcss.Node = Node2;
    LazyResult.registerPostcss(postcss);
    module2.exports = postcss;
    postcss.default = postcss;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/unesc.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex = "";
      var spaceTerminated = false;
      for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
        var code = lower.charCodeAt(i);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex += lower[i];
      }
      if (hex.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret2 = "";
      for (var i = 0; i < str.length; i++) {
        if (str[i] === "\\") {
          var gobbled = gobbleHex(str.slice(i + 1, i + 7));
          if (gobbled !== void 0) {
            ret2 += gobbled[0];
            i += gobbled[1];
            continue;
          }
          if (str[i + 1] === "\\") {
            ret2 += "\\";
            i++;
            continue;
          }
          if (str.length === i + 1) {
            ret2 += str[i];
          }
          continue;
        }
        ret2 += str[i];
      }
      return ret2;
    }
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/getProp.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = getProp;
    function getProp(obj2) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj2[prop]) {
          return void 0;
        }
        obj2 = obj2[prop];
      }
      return obj2;
    }
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = ensureObject;
    function ensureObject(obj2) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj2[prop]) {
          obj2[prop] = {};
        }
        obj2 = obj2[prop];
      }
    }
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = stripComments;
    function stripComments(str) {
      var s = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s = s + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s = s + str.slice(lastEnd);
      return s;
    }
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/index.js
var require_util3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/util/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.stripComments = exports2.ensureObject = exports2.getProp = exports2.unesc = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports2.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports2.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports2.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports2.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/node.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _util = require_util3();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj2, parent) {
      if (typeof obj2 !== "object" || obj2 === null) {
        return obj2;
      }
      var cloned = new obj2.constructor();
      for (var i in obj2) {
        if (!obj2.hasOwnProperty(i)) {
          continue;
        }
        var value = obj2[i];
        var type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent) {
            cloned[i] = parent;
          }
        } else if (value instanceof Array) {
          cloned[i] = value.map(function(j) {
            return cloneNode2(j, cloned);
          });
        } else {
          cloned[i] = cloneNode2(value, cloned);
        }
      }
      return cloned;
    };
    var Node2 = /* @__PURE__ */ function() {
      function Node3(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node3.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index in arguments) {
            this.parent.insertBefore(this, arguments[index]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value;
        if (originalEscaped || valueEscaped !== value) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node3, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node3;
    }();
    exports2["default"] = Node2;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/types.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.UNIVERSAL = exports2.ATTRIBUTE = exports2.CLASS = exports2.COMBINATOR = exports2.COMMENT = exports2.ID = exports2.NESTING = exports2.PSEUDO = exports2.ROOT = exports2.SELECTOR = exports2.STRING = exports2.TAG = void 0;
    var TAG = "tag";
    exports2.TAG = TAG;
    var STRING = "string";
    exports2.STRING = STRING;
    var SELECTOR = "selector";
    exports2.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports2.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports2.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports2.NESTING = NESTING;
    var ID = "id";
    exports2.ID = ID;
    var COMMENT = "comment";
    exports2.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports2.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports2.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports2.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports2.UNIVERSAL = UNIVERSAL;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/container.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var types = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      }
      if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
        return { "default": obj2 };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj2)) {
        return cache.get(obj2);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj2) {
        if (Object.prototype.hasOwnProperty.call(obj2, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj2[key];
          }
        }
      }
      newObj["default"] = obj2;
      if (cache) {
        cache.set(obj2, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Container = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container2.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index) {
        return this.nodes[index];
      };
      _proto.index = function index(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (oldIndex <= index) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index <= oldIndex) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index, result;
        while (this.indexes[id] < this.length) {
          index = this.indexes[id];
          result = callback(this.at(index), index);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk2(callback) {
        return this.each(function(node, i) {
          var result = callback(node, i);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node, index) {
          var split2 = callback.call(_this11, node);
          current.push(node);
          if (split2) {
            memo.push(current);
            current = [];
          } else if (index === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass(Container2, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container2;
    }(_node["default"]);
    exports2["default"] = Container;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/root.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Root = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root2, [{
        key: "errorGenerator",
        set: function set(handler) {
          this._error = handler;
        }
      }]);
      return Root2;
    }(_container["default"]);
    exports2["default"] = Root;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports2["default"] = Selector;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/cssesc-npm-3.0.0-15ec56f86f-f8c4ababff.zip/node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/cssesc-npm-3.0.0-15ec56f86f-f8c4ababff.zip/node_modules/cssesc/cssesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier2 = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier2) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier2 && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module2.exports = cssesc;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/className.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util3();
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped !== v) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports2["default"] = ClassName;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Comment = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment2, _Node);
      function Comment2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment2;
    }(_node["default"]);
    exports2["default"] = Comment;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/id.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports2["default"] = ID;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util3();
    var _node = _interopRequireDefault(require_node3());
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Namespace = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
          return this.namespaceString + "|" + value;
        } else {
          return value;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports2["default"] = Namespace;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports2["default"] = Tag;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/string.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports2["default"] = String2;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports2["default"] = Pseudo;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/util-deprecate-npm-1.0.2-e3fe1a219c-474acf1146.zip/node_modules/util-deprecate/node.js
var require_node4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/util-deprecate-npm-1.0.2-e3fe1a219c-474acf1146.zip/node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.unescapeValue = unescapeValue;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var deprecate = require_node4();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value;
      var m = unescaped.match(WRAPPED_IN_QUOTES);
      if (m) {
        quoteMark = m[1];
        unescaped = m[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v = this.value;
        var numSingleQuotes = v.replace(/[^']/g, "").length;
        var numDoubleQuotes = v.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });
          if (escaped === v) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value, {
            isIdentifier: true
          });
          if (escaped !== value) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
          return value ? count : -1;
        }
        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value) {
          warnOfDeprecatedQuotedAssignment();
        }
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v) {
          if (this._constructed) {
            var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
            if (deprecatedUsage) {
              warnOfDeprecatedValueAssignment();
            }
            if (unescaped === this._value && quoteMark === this._quoteMark) {
              return;
            }
            this._value = unescaped;
            this._quoteMark = quoteMark;
            this._syncRawValue();
          } else {
            this._value = v;
          }
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports2["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports2["default"] = Universal;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports2["default"] = Combinator;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports2["default"] = Nesting;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/sortAscending.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = sortAscending;
    function sortAscending(list) {
      return list.sort(function(a, b) {
        return a - b;
      });
    }
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.combinator = exports2.word = exports2.comment = exports2.str = exports2.tab = exports2.newline = exports2.feed = exports2.cr = exports2.backslash = exports2.bang = exports2.slash = exports2.doubleQuote = exports2.singleQuote = exports2.space = exports2.greaterThan = exports2.pipe = exports2.equals = exports2.plus = exports2.caret = exports2.tilde = exports2.dollar = exports2.closeSquare = exports2.openSquare = exports2.closeParenthesis = exports2.openParenthesis = exports2.semicolon = exports2.colon = exports2.comma = exports2.at = exports2.asterisk = exports2.ampersand = void 0;
    var ampersand = 38;
    exports2.ampersand = ampersand;
    var asterisk = 42;
    exports2.asterisk = asterisk;
    var at = 64;
    exports2.at = at;
    var comma = 44;
    exports2.comma = comma;
    var colon = 58;
    exports2.colon = colon;
    var semicolon = 59;
    exports2.semicolon = semicolon;
    var openParenthesis = 40;
    exports2.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports2.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports2.openSquare = openSquare;
    var closeSquare = 93;
    exports2.closeSquare = closeSquare;
    var dollar = 36;
    exports2.dollar = dollar;
    var tilde = 126;
    exports2.tilde = tilde;
    var caret = 94;
    exports2.caret = caret;
    var plus = 43;
    exports2.plus = plus;
    var equals = 61;
    exports2.equals = equals;
    var pipe = 124;
    exports2.pipe = pipe;
    var greaterThan = 62;
    exports2.greaterThan = greaterThan;
    var space = 32;
    exports2.space = space;
    var singleQuote = 39;
    exports2.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports2.doubleQuote = doubleQuote;
    var slash = 47;
    exports2.slash = slash;
    var bang = 33;
    exports2.bang = bang;
    var backslash = 92;
    exports2.backslash = backslash;
    var cr = 13;
    exports2.cr = cr;
    var feed = 12;
    exports2.feed = feed;
    var newline = 10;
    exports2.newline = newline;
    var tab = 9;
    exports2.tab = tab;
    var str = singleQuote;
    exports2.str = str;
    var comment = -1;
    exports2.comment = comment;
    var word = -2;
    exports2.word = word;
    var combinator = -3;
    exports2.combinator = combinator;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/tokenize.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = tokenize;
    exports2.FIELDS = void 0;
    var t2 = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      }
      if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
        return { "default": obj2 };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj2)) {
        return cache.get(obj2);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj2) {
        if (Object.prototype.hasOwnProperty.call(obj2, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj2[key];
          }
        }
      }
      newObj["default"] = obj2;
      if (cache) {
        cache.set(obj2, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t2.tab] = true, _unescapable[t2.newline] = true, _unescapable[t2.cr] = true, _unescapable[t2.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t2.space] = true, _wordDelimiters[t2.tab] = true, _wordDelimiters[t2.newline] = true, _wordDelimiters[t2.cr] = true, _wordDelimiters[t2.feed] = true, _wordDelimiters[t2.ampersand] = true, _wordDelimiters[t2.asterisk] = true, _wordDelimiters[t2.bang] = true, _wordDelimiters[t2.comma] = true, _wordDelimiters[t2.colon] = true, _wordDelimiters[t2.semicolon] = true, _wordDelimiters[t2.openParenthesis] = true, _wordDelimiters[t2.closeParenthesis] = true, _wordDelimiters[t2.openSquare] = true, _wordDelimiters[t2.closeSquare] = true, _wordDelimiters[t2.singleQuote] = true, _wordDelimiters[t2.doubleQuote] = true, _wordDelimiters[t2.plus] = true, _wordDelimiters[t2.pipe] = true, _wordDelimiters[t2.tilde] = true, _wordDelimiters[t2.greaterThan] = true, _wordDelimiters[t2.equals] = true, _wordDelimiters[t2.dollar] = true, _wordDelimiters[t2.caret] = true, _wordDelimiters[t2.slash] = true, _wordDelimiters);
    var hex = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i = 0; i < hexChars.length; i++) {
      hex[hexChars.charCodeAt(i)] = true;
    }
    var i;
    function consumeWord(css, start) {
      var next = start;
      var code;
      do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
          return next - 1;
        } else if (code === t2.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code = css.charCodeAt(next + 1);
      if (unescapable[code]) {
      } else if (hex[code]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code = css.charCodeAt(next + 1);
        } while (hex[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t2.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports2.FIELDS = FIELDS;
    function tokenize(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length = _css.length;
      var offset = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset, start);
        }
      }
      while (start < length) {
        code = css.charCodeAt(start);
        if (code === t2.newline) {
          offset = start;
          line += 1;
        }
        switch (code) {
          case t2.space:
          case t2.tab:
          case t2.newline:
          case t2.cr:
          case t2.feed:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === t2.newline) {
                offset = next;
                line += 1;
              }
            } while (code === t2.space || code === t2.newline || code === t2.tab || code === t2.cr || code === t2.feed);
            tokenType = t2.space;
            endLine = line;
            endColumn = next - offset - 1;
            end = next;
            break;
          case t2.plus:
          case t2.greaterThan:
          case t2.tilde:
          case t2.pipe:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === t2.plus || code === t2.greaterThan || code === t2.tilde || code === t2.pipe);
            tokenType = t2.combinator;
            endLine = line;
            endColumn = start - offset;
            end = next;
            break;
          case t2.asterisk:
          case t2.ampersand:
          case t2.bang:
          case t2.comma:
          case t2.equals:
          case t2.dollar:
          case t2.caret:
          case t2.openSquare:
          case t2.closeSquare:
          case t2.colon:
          case t2.semicolon:
          case t2.openParenthesis:
          case t2.closeParenthesis:
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          case t2.singleQuote:
          case t2.doubleQuote:
            quote = code === t2.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t2.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t2.str;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          default:
            if (code === t2.slash && css.charCodeAt(start + 1) === t2.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              tokenType = t2.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code === t2.slash) {
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t2.word;
              endLine = line;
              endColumn = next - offset;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          line,
          start - offset,
          endLine,
          endColumn,
          start,
          end
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/parser.js
var require_parser2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/parser.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string2());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize2());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types = _interopRequireWildcard(require_types());
    var _util = require_util3();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      }
      if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
        return { "default": obj2 };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj2)) {
        return cache.get(obj2);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj2) {
        if (Object.prototype.hasOwnProperty.call(obj2, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj2[key];
          }
        }
      }
      newObj["default"] = obj2;
      if (cache) {
        cache.set(obj2, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value = node[prop];
      if (typeof value !== "string") {
        return;
      }
      if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i = -1;
      var indexes = [];
      while ((i = array.indexOf(item, i + 1)) !== -1) {
        indexes.push(i);
      }
      return indexes;
    }
    function uniqs() {
      var list = Array.prototype.concat.apply([], arguments);
      return list.filter(function(item, i) {
        return i === list.indexOf(item);
      });
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(rule, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser2.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n) {
          var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position) {
        if (position === void 0) {
          position = this.position;
        }
        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n) {
                return _this3.newNode(n);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i) {
          return word[i - 1] !== "\\";
        });
        var hasId = indexesOf(word, "#").filter(function(i) {
          return word[i - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i) {
          var index = indices[i + 1] || word.length;
          var value = word.slice(ind, index);
          if (i === 0 && firstCallback) {
            return firstCallback.call(_this5, value, indices.length);
          }
          var node;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse3(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser2, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser2;
    }();
    exports2["default"] = Parser;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/processor.js
var require_processor2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/processor.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser2());
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    var Processor = /* @__PURE__ */ function() {
      function Processor2(func, options) {
        this.func = func || function noop() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor2.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var parser = new _parser["default"](rule, this._parseOptions(options));
        return parser.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve, reject) {
          try {
            var root = _this._root(rule, options);
            Promise.resolve(_this.func(root)).then(function(transform) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule, options)) {
                string = root.toString();
                rule.selector = string;
              }
              return {
                transform,
                root,
                string
              };
            }).then(resolve, reject);
          } catch (e) {
            reject(e);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule !== "string") {
          string = root.toString();
          rule.selector = string;
        }
        return {
          transform,
          root,
          string
        };
      };
      _proto.ast = function ast(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
      };
      _proto.transform = function transform(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
      };
      _proto.process = function process2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
      };
      return Processor2;
    }();
    exports2["default"] = Processor;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.universal = exports2.tag = exports2.string = exports2.selector = exports2.root = exports2.pseudo = exports2.nesting = exports2.id = exports2.comment = exports2.combinator = exports2.className = exports2.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string2());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports2.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports2.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports2.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    exports2.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports2.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports2.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports2.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    exports2.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports2.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports2.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports2.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports2.universal = universal;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.isNode = isNode2;
    exports2.isPseudoElement = isPseudoElement;
    exports2.isPseudoClass = isPseudoClass;
    exports2.isContainer = isContainer;
    exports2.isNamespace = isNamespace;
    exports2.isUniversal = exports2.isTag = exports2.isString = exports2.isSelector = exports2.isRoot = exports2.isPseudo = exports2.isNesting = exports2.isIdentifier = exports2.isComment = exports2.isCombinator = exports2.isClassName = exports2.isAttribute = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode2(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode2(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports2.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports2.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports2.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports2.isComment = isComment;
    var isIdentifier2 = isNodeType.bind(null, _types.ID);
    exports2.isIdentifier = isIdentifier2;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports2.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports2.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    exports2.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports2.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports2.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports2.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports2.isUniversal = isUniversal;
    function isPseudoElement(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement(node);
    }
    function isContainer(node) {
      return !!(isNode2(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/selectors/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _types[key])
        return;
      exports2[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _constructors[key])
        return;
      exports2[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _guards[key])
        return;
      exports2[key] = _guards[key];
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/index.js
var require_dist = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-selector-parser-npm-6.0.6-4df491c1e3-3602758798.zip/node_modules/postcss-selector-parser/dist/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor2());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      }
      if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
        return { "default": obj2 };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj2)) {
        return cache.get(obj2);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj2) {
        if (Object.prototype.hasOwnProperty.call(obj2, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj2[key];
          }
        }
      }
      newObj["default"] = obj2;
      if (cache) {
        cache.set(obj2, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { "default": obj2 };
    }
    var parser = function parser2(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser, selectors);
    delete parser.__esModule;
    var _default = parser;
    exports2["default"] = _default;
    module2.exports = exports2.default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/merge-source-map-npm-1.1.0-f4ef12b36d-945a83dcc5.zip/node_modules/merge-source-map/index.js
var require_merge_source_map = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/merge-source-map-npm-1.1.0-f4ef12b36d-945a83dcc5.zip/node_modules/merge-source-map/index.js"(exports2, module2) {
    var sourceMap = require_source_map();
    var SourceMapConsumer = sourceMap.SourceMapConsumer;
    var SourceMapGenerator = sourceMap.SourceMapGenerator;
    module2.exports = merge;
    function merge(oldMap, newMap) {
      if (!oldMap)
        return newMap;
      if (!newMap)
        return oldMap;
      var oldMapConsumer = new SourceMapConsumer(oldMap);
      var newMapConsumer = new SourceMapConsumer(newMap);
      var mergedMapGenerator = new SourceMapGenerator();
      newMapConsumer.eachMapping(function(m) {
        if (m.originalLine == null)
          return;
        var origPosInOldMap = oldMapConsumer.originalPositionFor({
          line: m.originalLine,
          column: m.originalColumn
        });
        if (origPosInOldMap.source == null)
          return;
        mergedMapGenerator.addMapping({
          original: {
            line: origPosInOldMap.line,
            column: origPosInOldMap.column
          },
          generated: {
            line: m.generatedLine,
            column: m.generatedColumn
          },
          source: origPosInOldMap.source,
          name: origPosInOldMap.name
        });
      });
      var consumers = [oldMapConsumer, newMapConsumer];
      consumers.forEach(function(consumer) {
        consumer.sources.forEach(function(sourceFile) {
          mergedMapGenerator._sources.add(sourceFile);
          var sourceContent = consumer.sourceContentFor(sourceFile);
          if (sourceContent != null) {
            mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
          }
        });
      });
      mergedMapGenerator._sourceRoot = oldMap.sourceRoot;
      mergedMapGenerator._file = oldMap.file;
      return JSON.parse(mergedMapGenerator.toString());
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/sourcemap-codec-npm-1.4.8-3a1a9e60b1-b57981c056.zip/node_modules/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/sourcemap-codec-npm-1.4.8-3a1a9e60b1-b57981c056.zip/node_modules/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      var charToInteger = {};
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      for (var i = 0; i < chars.length; i++) {
        charToInteger[chars.charCodeAt(i)] = i;
      }
      function decode(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
          0,
          0,
          0,
          0,
          0
        ];
        var j = 0;
        for (var i2 = 0, shift = 0, value = 0; i2 < mappings.length; i2++) {
          var c = mappings.charCodeAt(i2);
          if (c === 44) {
            segmentify(line, segment, j);
            j = 0;
          } else if (c === 59) {
            segmentify(line, segment, j);
            j = 0;
            decoded.push(line);
            line = [];
            segment[0] = 0;
          } else {
            var integer = charToInteger[c];
            if (integer === void 0) {
              throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value += integer << shift;
            if (hasContinuationBit) {
              shift += 5;
            } else {
              var shouldNegate = value & 1;
              value >>>= 1;
              if (shouldNegate) {
                value = value === 0 ? -2147483648 : -value;
              }
              segment[j] += value;
              j++;
              value = shift = 0;
            }
          }
        }
        segmentify(line, segment, j);
        decoded.push(line);
        return decoded;
      }
      function segmentify(line, segment, j) {
        if (j === 4)
          line.push([segment[0], segment[1], segment[2], segment[3]]);
        else if (j === 5)
          line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
        else if (j === 1)
          line.push([segment[0]]);
      }
      function encode(decoded) {
        var sourceFileIndex = 0;
        var sourceCodeLine = 0;
        var sourceCodeColumn = 0;
        var nameIndex = 0;
        var mappings = "";
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          if (i2 > 0)
            mappings += ";";
          if (line.length === 0)
            continue;
          var generatedCodeColumn = 0;
          var lineMappings = [];
          for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
              segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
              sourceFileIndex = segment[1];
              sourceCodeLine = segment[2];
              sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
              segmentMappings += encodeInteger(segment[4] - nameIndex);
              nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
          }
          mappings += lineMappings.join(",");
        }
        return mappings;
      }
      function encodeInteger(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          var clamped = num & 31;
          num >>>= 5;
          if (num > 0) {
            clamped |= 32;
          }
          result += chars[clamped];
        } while (num > 0);
        return result;
      }
      exports3.decode = decode;
      exports3.encode = encode;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/magic-string-npm-0.25.7-0a0bd9c864-727a1fb70f.zip/node_modules/magic-string/dist/magic-string.cjs.js
var require_magic_string_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/magic-string-npm-0.25.7-0a0bd9c864-727a1fb70f.zip/node_modules/magic-string/dist/magic-string.cjs.js"(exports2, module2) {
    "use strict";
    var sourcemapCodec = require_sourcemap_codec_umd();
    var BitSet = function BitSet2(arg) {
      this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
    };
    BitSet.prototype.add = function add(n2) {
      this.bits[n2 >> 5] |= 1 << (n2 & 31);
    };
    BitSet.prototype.has = function has(n2) {
      return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
    };
    var Chunk = function Chunk2(start, end, content) {
      this.start = start;
      this.end = end;
      this.original = content;
      this.intro = "";
      this.outro = "";
      this.content = content;
      this.storeName = false;
      this.edited = false;
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    };
    Chunk.prototype.appendLeft = function appendLeft(content) {
      this.outro += content;
    };
    Chunk.prototype.appendRight = function appendRight(content) {
      this.intro = this.intro + content;
    };
    Chunk.prototype.clone = function clone() {
      var chunk = new Chunk(this.start, this.end, this.original);
      chunk.intro = this.intro;
      chunk.outro = this.outro;
      chunk.content = this.content;
      chunk.storeName = this.storeName;
      chunk.edited = this.edited;
      return chunk;
    };
    Chunk.prototype.contains = function contains(index) {
      return this.start < index && index < this.end;
    };
    Chunk.prototype.eachNext = function eachNext(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.next;
      }
    };
    Chunk.prototype.eachPrevious = function eachPrevious(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.previous;
      }
    };
    Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
      this.content = content;
      if (!contentOnly) {
        this.intro = "";
        this.outro = "";
      }
      this.storeName = storeName;
      this.edited = true;
      return this;
    };
    Chunk.prototype.prependLeft = function prependLeft(content) {
      this.outro = content + this.outro;
    };
    Chunk.prototype.prependRight = function prependRight(content) {
      this.intro = content + this.intro;
    };
    Chunk.prototype.split = function split(index) {
      var sliceIndex = index - this.start;
      var originalBefore = this.original.slice(0, sliceIndex);
      var originalAfter = this.original.slice(sliceIndex);
      this.original = originalBefore;
      var newChunk = new Chunk(index, this.end, originalAfter);
      newChunk.outro = this.outro;
      this.outro = "";
      this.end = index;
      if (this.edited) {
        newChunk.edit("", false);
        this.content = "";
      } else {
        this.content = originalBefore;
      }
      newChunk.next = this.next;
      if (newChunk.next) {
        newChunk.next.previous = newChunk;
      }
      newChunk.previous = this;
      this.next = newChunk;
      return newChunk;
    };
    Chunk.prototype.toString = function toString2() {
      return this.intro + this.content + this.outro;
    };
    Chunk.prototype.trimEnd = function trimEnd(rx) {
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.start + trimmed.length).edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
      }
    };
    Chunk.prototype.trimStart = function trimStart(rx) {
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.end - trimmed.length);
          this.edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
      }
    };
    var btoa = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    } else if (typeof Buffer === "function") {
      btoa = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
      };
    }
    var SourceMap = function SourceMap2(properties) {
      this.version = 3;
      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = sourcemapCodec.encode(properties.mappings);
    };
    SourceMap.prototype.toString = function toString2() {
      return JSON.stringify(this);
    };
    SourceMap.prototype.toUrl = function toUrl() {
      return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
    };
    function guessIndent(code) {
      var lines = code.split("\n");
      var tabbed = lines.filter(function(line) {
        return /^\t+/.test(line);
      });
      var spaced = lines.filter(function(line) {
        return /^ {2,}/.test(line);
      });
      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }
      if (tabbed.length >= spaced.length) {
        return "	";
      }
      var min = spaced.reduce(function(previous, current) {
        var numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);
      return new Array(min + 1).join(" ");
    }
    function getRelativePath(from, to) {
      var fromParts = from.split(/[/\\]/);
      var toParts = to.split(/[/\\]/);
      fromParts.pop();
      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }
      if (fromParts.length) {
        var i = fromParts.length;
        while (i--) {
          fromParts[i] = "..";
        }
      }
      return fromParts.concat(toParts).join("/");
    }
    var toString = Object.prototype.toString;
    function isObject2(thing) {
      return toString.call(thing) === "[object Object]";
    }
    function getLocator(source) {
      var originalLines = source.split("\n");
      var lineOffsets = [];
      for (var i = 0, pos = 0; i < originalLines.length; i++) {
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
      }
      return function locate(index) {
        var i2 = 0;
        var j = lineOffsets.length;
        while (i2 < j) {
          var m = i2 + j >> 1;
          if (index < lineOffsets[m]) {
            j = m;
          } else {
            i2 = m + 1;
          }
        }
        var line = i2 - 1;
        var column = index - lineOffsets[line];
        return { line, column };
      };
    }
    var Mappings = function Mappings2(hires) {
      this.hires = hires;
      this.generatedCodeLine = 0;
      this.generatedCodeColumn = 0;
      this.raw = [];
      this.rawSegments = this.raw[this.generatedCodeLine] = [];
      this.pending = null;
    };
    Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
      if (content.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
      } else if (this.pending) {
        this.rawSegments.push(this.pending);
      }
      this.advance(content);
      this.pending = null;
    };
    Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
      var originalCharIndex = chunk.start;
      var first = true;
      while (originalCharIndex < chunk.end) {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === "\n") {
          loc.line += 1;
          loc.column = 0;
          this.generatedCodeLine += 1;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
          first = true;
        } else {
          loc.column += 1;
          this.generatedCodeColumn += 1;
          first = false;
        }
        originalCharIndex += 1;
      }
      this.pending = null;
    };
    Mappings.prototype.advance = function advance(str) {
      if (!str) {
        return;
      }
      var lines = str.split("\n");
      if (lines.length > 1) {
        for (var i = 0; i < lines.length - 1; i++) {
          this.generatedCodeLine++;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    var n = "\n";
    var warned = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    var MagicString = function MagicString2(string, options) {
      if (options === void 0)
        options = {};
      var chunk = new Chunk(0, string.length, string);
      Object.defineProperties(this, {
        original: { writable: true, value: string },
        outro: { writable: true, value: "" },
        intro: { writable: true, value: "" },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options.filename },
        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: new BitSet() },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent(string) }
      });
      this.byStart[0] = chunk;
      this.byEnd[string.length] = chunk;
    };
    MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
      this.sourcemapLocations.add(char);
    };
    MagicString.prototype.append = function append(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.outro += content;
      return this;
    };
    MagicString.prototype.appendLeft = function appendLeft(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.appendLeft(content);
      } else {
        this.intro += content;
      }
      return this;
    };
    MagicString.prototype.appendRight = function appendRight(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.appendRight(content);
      } else {
        this.outro += content;
      }
      return this;
    };
    MagicString.prototype.clone = function clone() {
      var cloned = new MagicString(this.original, { filename: this.filename });
      var originalChunk = this.firstChunk;
      var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
      while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
          clonedChunk.next = nextClonedChunk;
          nextClonedChunk.previous = clonedChunk;
          clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
      }
      cloned.lastChunk = clonedChunk;
      if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
      }
      cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
      cloned.intro = this.intro;
      cloned.outro = this.outro;
      return cloned;
    };
    MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
      var this$1 = this;
      options = options || {};
      var sourceIndex = 0;
      var names = Object.keys(this.storedNames);
      var mappings = new Mappings(options.hires);
      var locate = getLocator(this.original);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.firstChunk.eachNext(function(chunk) {
        var loc = locate(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
        } else {
          mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: [options.source ? getRelativePath(options.file || "", options.source) : null],
        sourcesContent: options.includeContent ? [this.original] : [null],
        names,
        mappings: mappings.raw
      };
    };
    MagicString.prototype.generateMap = function generateMap(options) {
      return new SourceMap(this.generateDecodedMap(options));
    };
    MagicString.prototype.getIndentString = function getIndentString() {
      return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString.prototype.indent = function indent(indentStr, options) {
      var pattern = /^[^\r\n]/gm;
      if (isObject2(indentStr)) {
        options = indentStr;
        indentStr = void 0;
      }
      indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
      if (indentStr === "") {
        return this;
      }
      options = options || {};
      var isExcluded = {};
      if (options.exclude) {
        var exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
        exclusions.forEach(function(exclusion) {
          for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
            isExcluded[i] = true;
          }
        });
      }
      var shouldIndentNextCharacter = options.indentStart !== false;
      var replacer = function(match) {
        if (shouldIndentNextCharacter) {
          return "" + indentStr + match;
        }
        shouldIndentNextCharacter = true;
        return match;
      };
      this.intro = this.intro.replace(pattern, replacer);
      var charIndex = 0;
      var chunk = this.firstChunk;
      while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
          if (!isExcluded[charIndex]) {
            chunk.content = chunk.content.replace(pattern, replacer);
            if (chunk.content.length) {
              shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
            }
          }
        } else {
          charIndex = chunk.start;
          while (charIndex < end) {
            if (!isExcluded[charIndex]) {
              var char = this.original[charIndex];
              if (char === "\n") {
                shouldIndentNextCharacter = true;
              } else if (char !== "\r" && shouldIndentNextCharacter) {
                shouldIndentNextCharacter = false;
                if (charIndex === chunk.start) {
                  chunk.prependRight(indentStr);
                } else {
                  this._splitChunk(chunk, charIndex);
                  chunk = chunk.next;
                  chunk.prependRight(indentStr);
                }
              }
            }
            charIndex += 1;
          }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
      }
      this.outro = this.outro.replace(pattern, replacer);
      return this;
    };
    MagicString.prototype.insert = function insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    };
    MagicString.prototype.insertLeft = function insertLeft(index, content) {
      if (!warned.insertLeft) {
        console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
        warned.insertLeft = true;
      }
      return this.appendLeft(index, content);
    };
    MagicString.prototype.insertRight = function insertRight(index, content) {
      if (!warned.insertRight) {
        console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
        warned.insertRight = true;
      }
      return this.prependRight(index, content);
    };
    MagicString.prototype.move = function move(start, end, index) {
      if (index >= start && index <= end) {
        throw new Error("Cannot move a selection inside itself");
      }
      this._split(start);
      this._split(end);
      this._split(index);
      var first = this.byStart[start];
      var last = this.byEnd[end];
      var oldLeft = first.previous;
      var oldRight = last.next;
      var newRight = this.byStart[index];
      if (!newRight && last === this.lastChunk) {
        return this;
      }
      var newLeft = newRight ? newRight.previous : this.lastChunk;
      if (oldLeft) {
        oldLeft.next = oldRight;
      }
      if (oldRight) {
        oldRight.previous = oldLeft;
      }
      if (newLeft) {
        newLeft.next = first;
      }
      if (newRight) {
        newRight.previous = last;
      }
      if (!first.previous) {
        this.firstChunk = last.next;
      }
      if (!last.next) {
        this.lastChunk = first.previous;
        this.lastChunk.next = null;
      }
      first.previous = newLeft;
      last.next = newRight || null;
      if (!newLeft) {
        this.firstChunk = first;
      }
      if (!newRight) {
        this.lastChunk = last;
      }
      return this;
    };
    MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
      if (typeof content !== "string") {
        throw new TypeError("replacement content must be a string");
      }
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (end > this.original.length) {
        throw new Error("end is out of bounds");
      }
      if (start === end) {
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      }
      this._split(start);
      this._split(end);
      if (options === true) {
        if (!warned.storeName) {
          console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
          warned.storeName = true;
        }
        options = { storeName: true };
      }
      var storeName = options !== void 0 ? options.storeName : false;
      var contentOnly = options !== void 0 ? options.contentOnly : false;
      if (storeName) {
        var original = this.original.slice(start, end);
        this.storedNames[original] = true;
      }
      var first = this.byStart[start];
      var last = this.byEnd[end];
      if (first) {
        if (end > first.end && first.next !== this.byStart[first.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        first.edit(content, storeName, contentOnly);
        if (first !== last) {
          var chunk = first.next;
          while (chunk !== last) {
            chunk.edit("", false);
            chunk = chunk.next;
          }
          chunk.edit("", false);
        }
      } else {
        var newChunk = new Chunk(start, end, "").edit(content, storeName);
        last.next = newChunk;
        newChunk.previous = last;
      }
      return this;
    };
    MagicString.prototype.prepend = function prepend(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.intro = content + this.intro;
      return this;
    };
    MagicString.prototype.prependLeft = function prependLeft(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.prependLeft(content);
      } else {
        this.intro = content + this.intro;
      }
      return this;
    };
    MagicString.prototype.prependRight = function prependRight(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.prependRight(content);
      } else {
        this.outro = content + this.outro;
      }
      return this;
    };
    MagicString.prototype.remove = function remove(start, end) {
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (start === end) {
        return this;
      }
      if (start < 0 || end > this.original.length) {
        throw new Error("Character is out of bounds");
      }
      if (start > end) {
        throw new Error("end must be greater than start");
      }
      this._split(start);
      this._split(end);
      var chunk = this.byStart[start];
      while (chunk) {
        chunk.intro = "";
        chunk.outro = "";
        chunk.edit("");
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
      }
      return this;
    };
    MagicString.prototype.lastChar = function lastChar() {
      if (this.outro.length) {
        return this.outro[this.outro.length - 1];
      }
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length) {
          return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
          return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
          return chunk.intro[chunk.intro.length - 1];
        }
      } while (chunk = chunk.previous);
      if (this.intro.length) {
        return this.intro[this.intro.length - 1];
      }
      return "";
    };
    MagicString.prototype.lastLine = function lastLine() {
      var lineIndex = this.outro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
      }
      var lineStr = this.outro;
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length > 0) {
          lineIndex = chunk.outro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.outro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
          lineIndex = chunk.content.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.content.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
          lineIndex = chunk.intro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.intro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.intro + lineStr;
        }
      } while (chunk = chunk.previous);
      lineIndex = this.intro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
      }
      return this.intro + lineStr;
    };
    MagicString.prototype.slice = function slice(start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = this.original.length;
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      var result = "";
      var chunk = this.firstChunk;
      while (chunk && (chunk.start > start || chunk.end <= start)) {
        if (chunk.start < end && chunk.end >= end) {
          return result;
        }
        chunk = chunk.next;
      }
      if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
      }
      var startChunk = chunk;
      while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
          result += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
          throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
          result += chunk.outro;
        }
        if (containsEnd) {
          break;
        }
        chunk = chunk.next;
      }
      return result;
    };
    MagicString.prototype.snip = function snip(start, end) {
      var clone = this.clone();
      clone.remove(0, start);
      clone.remove(end, clone.original.length);
      return clone;
    };
    MagicString.prototype._split = function _split(index) {
      if (this.byStart[index] || this.byEnd[index]) {
        return;
      }
      var chunk = this.lastSearchedChunk;
      var searchForward = index > chunk.end;
      while (chunk) {
        if (chunk.contains(index)) {
          return this._splitChunk(chunk, index);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      }
    };
    MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
      if (chunk.edited && chunk.content.length) {
        var loc = getLocator(this.original)(index);
        throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
      }
      var newChunk = chunk.split(index);
      this.byEnd[index] = chunk;
      this.byStart[index] = newChunk;
      this.byEnd[newChunk.end] = newChunk;
      if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
      }
      this.lastSearchedChunk = chunk;
      return true;
    };
    MagicString.prototype.toString = function toString2() {
      var str = this.intro;
      var chunk = this.firstChunk;
      while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
      }
      return str + this.outro;
    };
    MagicString.prototype.isEmpty = function isEmpty() {
      var chunk = this.firstChunk;
      do {
        if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
          return false;
        }
      } while (chunk = chunk.next);
      return true;
    };
    MagicString.prototype.length = function length() {
      var chunk = this.firstChunk;
      var length2 = 0;
      do {
        length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
      } while (chunk = chunk.next);
      return length2;
    };
    MagicString.prototype.trimLines = function trimLines() {
      return this.trim("[\\r\\n]");
    };
    MagicString.prototype.trim = function trim(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var chunk = this.lastChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        if (chunk.end !== end) {
          if (this.lastChunk === chunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.previous;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimEnd = function trimEnd(charType) {
      this.trimEndAborted(charType);
      return this;
    };
    MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var chunk = this.firstChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
          if (chunk === this.lastChunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.next;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimStart = function trimStart(charType) {
      this.trimStartAborted(charType);
      return this;
    };
    var hasOwnProp = Object.prototype.hasOwnProperty;
    var Bundle = function Bundle2(options) {
      if (options === void 0)
        options = {};
      this.intro = options.intro || "";
      this.separator = options.separator !== void 0 ? options.separator : "\n";
      this.sources = [];
      this.uniqueSources = [];
      this.uniqueSourceIndexByFilename = {};
    };
    Bundle.prototype.addSource = function addSource(source) {
      if (source instanceof MagicString) {
        return this.addSource({
          content: source,
          filename: source.filename,
          separator: this.separator
        });
      }
      if (!isObject2(source) || !source.content) {
        throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      }
      ["filename", "indentExclusionRanges", "separator"].forEach(function(option) {
        if (!hasOwnProp.call(source, option)) {
          source[option] = source.content[option];
        }
      });
      if (source.separator === void 0) {
        source.separator = this.separator;
      }
      if (source.filename) {
        if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
          this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
          this.uniqueSources.push({ filename: source.filename, content: source.content.original });
        } else {
          var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
          if (source.content.original !== uniqueSource.content) {
            throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
          }
        }
      }
      this.sources.push(source);
      return this;
    };
    Bundle.prototype.append = function append(str, options) {
      this.addSource({
        content: new MagicString(str),
        separator: options && options.separator || ""
      });
      return this;
    };
    Bundle.prototype.clone = function clone() {
      var bundle = new Bundle({
        intro: this.intro,
        separator: this.separator
      });
      this.sources.forEach(function(source) {
        bundle.addSource({
          filename: source.filename,
          content: source.content.clone(),
          separator: source.separator
        });
      });
      return bundle;
    };
    Bundle.prototype.generateDecodedMap = function generateDecodedMap(options) {
      var this$1 = this;
      if (options === void 0)
        options = {};
      var names = [];
      this.sources.forEach(function(source) {
        Object.keys(source.content.storedNames).forEach(function(name) {
          if (!~names.indexOf(name)) {
            names.push(name);
          }
        });
      });
      var mappings = new Mappings(options.hires);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.sources.forEach(function(source, i) {
        if (i > 0) {
          mappings.advance(this$1.separator);
        }
        var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;
        var magicString = source.content;
        var locate = getLocator(magicString.original);
        if (magicString.intro) {
          mappings.advance(magicString.intro);
        }
        magicString.firstChunk.eachNext(function(chunk) {
          var loc = locate(chunk.start);
          if (chunk.intro.length) {
            mappings.advance(chunk.intro);
          }
          if (source.filename) {
            if (chunk.edited) {
              mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
            } else {
              mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
            }
          } else {
            mappings.advance(chunk.content);
          }
          if (chunk.outro.length) {
            mappings.advance(chunk.outro);
          }
        });
        if (magicString.outro) {
          mappings.advance(magicString.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: this.uniqueSources.map(function(source) {
          return options.file ? getRelativePath(options.file, source.filename) : source.filename;
        }),
        sourcesContent: this.uniqueSources.map(function(source) {
          return options.includeContent ? source.content : null;
        }),
        names,
        mappings: mappings.raw
      };
    };
    Bundle.prototype.generateMap = function generateMap(options) {
      return new SourceMap(this.generateDecodedMap(options));
    };
    Bundle.prototype.getIndentString = function getIndentString() {
      var indentStringCounts = {};
      this.sources.forEach(function(source) {
        var indentStr = source.content.indentStr;
        if (indentStr === null) {
          return;
        }
        if (!indentStringCounts[indentStr]) {
          indentStringCounts[indentStr] = 0;
        }
        indentStringCounts[indentStr] += 1;
      });
      return Object.keys(indentStringCounts).sort(function(a, b) {
        return indentStringCounts[a] - indentStringCounts[b];
      })[0] || "	";
    };
    Bundle.prototype.indent = function indent(indentStr) {
      var this$1 = this;
      if (!arguments.length) {
        indentStr = this.getIndentString();
      }
      if (indentStr === "") {
        return this;
      }
      var trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
      this.sources.forEach(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1.separator;
        var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
        source.content.indent(indentStr, {
          exclude: source.indentExclusionRanges,
          indentStart
        });
        trailingNewline = source.content.lastChar() === "\n";
      });
      if (this.intro) {
        this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function(match, index) {
          return index > 0 ? indentStr + match : match;
        });
      }
      return this;
    };
    Bundle.prototype.prepend = function prepend(str) {
      this.intro = str + this.intro;
      return this;
    };
    Bundle.prototype.toString = function toString2() {
      var this$1 = this;
      var body = this.sources.map(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1.separator;
        var str = (i > 0 ? separator : "") + source.content.toString();
        return str;
      }).join("");
      return this.intro + body;
    };
    Bundle.prototype.isEmpty = function isEmpty() {
      if (this.intro.length && this.intro.trim()) {
        return false;
      }
      if (this.sources.some(function(source) {
        return !source.content.isEmpty();
      })) {
        return false;
      }
      return true;
    };
    Bundle.prototype.length = function length() {
      return this.sources.reduce(function(length2, source) {
        return length2 + source.content.length();
      }, this.intro.length);
    };
    Bundle.prototype.trimLines = function trimLines() {
      return this.trim("[\\r\\n]");
    };
    Bundle.prototype.trim = function trim(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    Bundle.prototype.trimStart = function trimStart(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (!this.intro) {
        var source;
        var i = 0;
        do {
          source = this.sources[i++];
          if (!source) {
            break;
          }
        } while (!source.content.trimStartAborted(charType));
      }
      return this;
    };
    Bundle.prototype.trimEnd = function trimEnd(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      var source;
      var i = this.sources.length - 1;
      do {
        source = this.sources[i--];
        if (!source) {
          this.intro = this.intro.replace(rx, "");
          break;
        }
      } while (!source.content.trimEndAborted(charType));
      return this;
    };
    MagicString.Bundle = Bundle;
    MagicString.SourceMap = SourceMap;
    MagicString.default = MagicString;
    module2.exports = MagicString;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/yallist-npm-3.1.1-a568a556b4-48f7bb00dc.zip/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/yallist-npm-3.1.1-a568a556b4-48f7bb00dc.zip/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/yallist-npm-3.1.1-a568a556b4-48f7bb00dc.zip/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/yallist-npm-3.1.1-a568a556b4-48f7bb00dc.zip/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret2 = new Yallist();
      if (to < from || to < 0) {
        return ret2;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret2.push(walker.value);
      }
      return ret2;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret2 = new Yallist();
      if (to < from || to < 0) {
        return ret2;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret2.push(walker.value);
      }
      return ret2;
    };
    Yallist.prototype.splice = function(start, deleteCount) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret2 = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret2.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 2; i < arguments.length; i++) {
        walker = insert(this, walker, arguments[i]);
      }
      return ret2;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/lru-cache-npm-5.1.1-f475882a51-c154ae1cbb.zip/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/lru-cache-npm-5.1.1-f475882a51-c154ae1cbb.zip/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj2, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj2) {
        return obj2;
      };
      ObjectGetPrototypeOf = function(obj2) {
        try {
          return Object(obj2).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj2) {
        try {
          return str.call(obj2) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/util.js
var require_util4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj2, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj2, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
      }
    }
    function notEnumerableProp(obj2, name, value) {
      if (isPrimitive(obj2))
        return obj2;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj2, name, descriptor);
      return obj2;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj2) {
          var ret2 = [];
          var visitedKeys = Object.create(null);
          while (obj2 != null && !isExcludedProto(obj2)) {
            var keys;
            try {
              keys = getKeys(obj2);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj2, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj2 = es5.getPrototypeOf(obj2);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj2) {
          if (isExcludedProto(obj2))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj2) {
              if (hasProp.call(obj2, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var receiver = new FakeConstructor();
      function ic() {
        return typeof receiver.foo;
      }
      ic();
      ic();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj2) {
      try {
        return obj2 + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj2) {
      return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj2) {
      return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj2) {
      return {}.toString.call(obj2);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if (classString(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    var reflectHandler;
    function contextBind(ctx, cb) {
      if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
        return cb;
      }
      if (ctx.domain !== null) {
        cb = ctx.domain.bind(cb);
      }
      var async = ctx.async;
      if (async !== null) {
        var old = cb;
        cb = function() {
          var $_len = arguments.length + 2;
          var args = new Array($_len);
          for (var $_i = 2; $_i < $_len; ++$_i) {
            args[$_i] = arguments[$_i - 2];
          }
          ;
          args[0] = old;
          args[1] = this;
          return async.runInAsyncScope.apply(async, args);
        };
      }
      return cb;
    }
    var ret = {
      setReflectHandler: function(fn) {
        reflectHandler = fn;
      },
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      contextBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version;
      if (process.versions && process.versions.node) {
        version = process.versions.node.split(".").map(Number);
      } else if (process.version) {
        version = process.version.split(".").map(Number);
      }
      return version[0] === 0 && version[1] > 10 || version[0] > 0;
    }();
    ret.nodeSupportsAsyncResource = ret.isNode && function() {
      var supportsAsync = false;
      try {
        var res = require("async_hooks").AsyncResource;
        supportsAsync = typeof res.prototype.runInAsyncScope === "function";
      } catch (e) {
        supportsAsync = false;
      }
      return supportsAsync;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/queue.js
var require_queue2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver2, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver2);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver2;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/async.js
var require_async6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue2();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver2, arg) {
      this._lateQueue.push(fn, receiver2, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver2, arg) {
      this._normalQueue.push(fn, receiver2, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
    function _drainQueue(queue) {
      while (queue.length() > 0) {
        _drainQueueStep(queue);
      }
    }
    function _drainQueueStep(queue) {
      var fn = queue.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
      } else {
        var receiver2 = queue.shift();
        var arg = queue.shift();
        fn.call(receiver2, arg);
      }
    }
    Async.prototype._drainQueues = function() {
      _drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      _drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/errors.js
var require_errors = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util4();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    var i;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util4();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj2, context) {
        if (isObject2(obj2)) {
          if (obj2 instanceof Promise2)
            return obj2;
          var then = getThen(obj2);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj2)) {
              var ret2 = new Promise2(INTERNAL);
              obj2._then(ret2._fulfill, ret2._reject, void 0, ret2, null);
              return ret2;
            }
            return doThenable(obj2, then, context);
          }
        }
        return obj2;
      }
      function doGetThen(obj2) {
        return obj2.then;
      }
      function getThen(obj2) {
        try {
          return doGetThen(obj2);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj2) {
        try {
          return hasProp.call(obj2, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util4();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
          case -6:
            return new Map();
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
          values.suppressUnhandledRejections();
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
      var async = Promise2._async;
      var Warning = require_errors().Warning;
      var util = require_util4();
      var es52 = require_es5();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      var deferUnhandledRejectionCheck;
      (function() {
        var promises = [];
        function unhandledRejectionCheck() {
          for (var i = 0; i < promises.length; ++i) {
            promises[i]._notifyUnhandledRejection();
          }
          unhandledRejectionClear();
        }
        function unhandledRejectionClear() {
          promises.length = 0;
        }
        deferUnhandledRejectionCheck = function(promise) {
          promises.push(promise);
          setTimeout(unhandledRejectionCheck, 1);
        };
        es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
          value: unhandledRejectionCheck
        });
        es52.defineProperty(Promise2, "_unhandledRejectionClear", {
          value: unhandledRejectionClear
        });
      })();
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        deferUnhandledRejectionCheck(this);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var context = Promise2._getContext();
        possiblyUnhandledRejection = util.contextBind(context, fn);
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var context = Promise2._getContext();
        unhandledRejectionHandled = util.contextBind(context, fn);
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
          config.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
            Context.deactivateLongStackTraces();
            config.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
          Context.activateLongStackTraces();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
      };
      var legacyHandlers = {
        unhandledrejection: {
          before: function() {
            var ret2 = util.global.onunhandledrejection;
            util.global.onunhandledrejection = null;
            return ret2;
          },
          after: function(fn) {
            util.global.onunhandledrejection = fn;
          }
        },
        rejectionhandled: {
          before: function() {
            var ret2 = util.global.onrejectionhandled;
            util.global.onrejectionhandled = null;
            return ret2;
          },
          after: function(fn) {
            util.global.onrejectionhandled = fn;
          }
        }
      };
      var fireDomEvent = function() {
        var dispatch = function(legacy, e) {
          if (legacy) {
            var fn;
            try {
              fn = legacy.before();
              return !util.global.dispatchEvent(e);
            } finally {
              legacy.after(fn);
            }
          } else {
            return !util.global.dispatchEvent(e);
          }
        };
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var eventData = {
                detail: event2,
                cancelable: true
              };
              var domEvent = new CustomEvent(name, eventData);
              es52.defineProperty(domEvent, "promise", { value: event2.promise });
              es52.defineProperty(domEvent, "reason", { value: event2.reason });
              return dispatch(legacyHandlers[name], domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var domEvent = new Event(name, {
                cancelable: true
              });
              domEvent.detail = event2;
              es52.defineProperty(domEvent, "promise", { value: event2.promise });
              es52.defineProperty(domEvent, "reason", { value: event2.reason });
              return dispatch(legacyHandlers[name], domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(name, false, true, event2);
              return dispatch(legacyHandlers[name], domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config.warnings = !!warningsOption;
          wForgottenReturn = config.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error("cannot enable cancellation after promises are in use");
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
          var prev = config.asyncHooks;
          var cur = !!opts.asyncHooks;
          if (prev !== cur) {
            config.asyncHooks = cur;
            if (cur) {
              enableAsyncHooks();
            } else {
              disableAsyncHooks();
            }
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject) {
        try {
          executor(resolve, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._dereferenceTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
          executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace2(error)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error);
          } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          }
        }
      }
      function longStackTracesDereferenceTrace() {
        this._trace = void 0;
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
          message,
          stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
          } else {
            message = title + String(error);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj2) {
        var str;
        if (typeof obj2 === "function") {
          str = "[function " + (obj2.name || "anonymous") + "]";
        } else {
          str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj2);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = (firstLineError.stack || "").split("\n");
        var lastStackLines = (lastLineError.stack || "").split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if (error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver2, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver2, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "[33m" : "[31m";
            console.warn(color + message + "[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
          };
        }
      }
      var config = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false,
        asyncHooks: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        asyncHooks: function() {
          return config.asyncHooks;
        },
        longStackTraces: function() {
          return config.longStackTraces;
        },
        warnings: function() {
          return config.warnings;
        },
        cancellation: function() {
          return config.cancellation;
        },
        monitoring: function() {
          return config.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util4();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
      var util = require_util4();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 === NEXT_FILTER) {
            return ret2;
          } else if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                }
              }
              return maybePromise._then(succeed, fail, void 0, this, void 0);
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(success, fail2, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      Promise2.prototype.tapCatch = function(handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
          return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
        } else {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return Promise2.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
            }
          }
          catchInstances.length = j;
          var handler = arguments[i];
          return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
        }
      };
      return PassThroughHandlerContext;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj2) {
      return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj2) {
      var ret2;
      if (isUntypedError(obj2)) {
        ret2 = new OperationalError(obj2);
        ret2.name = obj2.name;
        ret2.message = obj2.message;
        ret2.stack = obj2.stack;
        var keys = es52.keys(obj2);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj2[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj2);
      return obj2;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug2) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug2.checkForgottenReturns(value, promiseCreated, "Promise.method", ret2);
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug2.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug2.checkForgottenReturns(value, promiseCreated, "Promise.try", ret2);
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug2) {
      var calledBind = false;
      var rejectThis = function(_, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug2.propagateFromFunction();
          Promise2.prototype._boundValue = debug2.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(bindingResolved, bindingRejected, void 0, ret2, context);
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj2) {
        if (obj2 !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj2;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug2) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug2.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(returner, void 0, void 0, { value }, void 0);
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(thrower2, void 0, void 0, { reason }, void 0);
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(void 0, thrower2, void 0, { reason }, void 0);
        } else {
          var _reason = arguments[1];
          var handler = function() {
            throw _reason;
          };
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(void 0, returner, void 0, { value }, void 0);
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = function() {
            return _value;
          };
          return this.caught(value, handler);
        }
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
      var util = require_util4();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(callbacks[i2], reject, void 0, ret2, holder);
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(ret2, maybePromise._value(), holder);
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var context = Promise2._getContext();
                  holder.fn = util.contextBind(context, holder.fn);
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util4();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj2, methodName) {
        var fn;
        if (obj2 != null)
          fn = obj2[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj2) {
        var methodName = this.pop();
        var fn = ensureMethod(obj2, methodName);
        return fn.apply(obj2, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(maybeCaller, void 0, void 0, args, void 0);
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj2) {
        return obj2[this];
      }
      function indexedGetter(obj2) {
        var index = +this;
        if (index < 0)
          index = Math.max(0, index + obj2.length);
        return obj2[index];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2) {
      var errors = require_errors();
      var TypeError2 = errors.TypeError;
      var util = require_util4();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
        if (debug2.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver2;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug2.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError("generator .return() sentinel");
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(this._generator, void 0);
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
            if (maybePromise === null) {
              this._promiseRejected(new TypeError2("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack);
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug2.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var context = Promise2._getContext();
        this._callback = util.contextBind(context, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
        if (util.isArray(promises)) {
          for (var i = 0; i < promises.length; ++i) {
            var maybePromise = promises[i];
            if (maybePromise instanceof Promise2) {
              maybePromise.suppressUnhandledRejections();
            }
          }
        }
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver2 = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver2, value, index, length);
          var promiseCreated = promise._popContext();
          debug2.checkForgottenReturns(ret2, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index = queue.pop();
          this._promiseFulfilled(values[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options) {
        return map(this, fn, options, null);
      };
      Promise2.map = function(promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util4();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver2 = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver2, null) : tryCatch2(nodeback).call(receiver2, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(adapter, errorAdapter, void 0, this, nodeback);
        }
        return this;
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util4();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj2, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj2, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj2);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj2[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver2, originalName, fn, _, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver2 === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver2 === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver2, withAppended2, maybeWrapAsError2, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
      }
      function makeNodePromisifiedClosure(callback, receiver2, _, fn, __, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver2;
          if (receiver2 === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj2[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj2);
        return obj2;
      }
      function promisify(callback, receiver2, multiArgs) {
        return makeNodePromisified(callback, receiver2, void 0, callback, null, multiArgs);
      }
      Promise2.promisify = function(fn, options) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options = Object(options);
        var receiver2 = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn, receiver2, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util4();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size] = key;
          index++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj2) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
          entries = mapToEntries(obj2);
          isMap = true;
        } else {
          var keys = es52.keys(obj2);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj2[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, isMap ? -6 : -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(Promise2.props, void 0, void 0, void 0, void 0);
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util4();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
      var util = require_util4();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var context = Promise2._getContext();
        this._fn = util.contextBind(context, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        for (var j = i; j < length; ++j) {
          var maybePromise = values[j];
          if (maybePromise instanceof Promise2) {
            maybePromise.suppressUnhandledRejections();
          }
        }
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
            if ((i & 127) === 0) {
              value._setNoAsyncGuarantee();
            }
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug2.checkForgottenReturns(ret2, promiseCreated, array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", promise);
        return ret2;
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug2) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util4();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug2.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.allSettled = function(promises) {
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util4();
      var RangeError2 = require_errors().RangeError;
      var AggregateError = require_errors().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, debug2) {
      var util = require_util4();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug2.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug2.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug2.cancellation()) {
          parent = this.then();
          ret2 = parent._then(successClear, failureClear, void 0, handleWrapper, void 0);
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(successClear, failureClear, void 0, handleWrapper, void 0);
        }
        return ret2;
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2) {
      var util = require_util4();
      var TypeError2 = require_errors().TypeError;
      var inherits2 = require_util4().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(iterator, thrower2, null, null, null);
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug2.checkForgottenReturns(ret2, promiseCreated, "Promise.using", promise);
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler2 = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util4();
      util.setReflectHandler(reflectHandler2);
      var getDomain = function() {
        var domain = process.domain;
        if (domain === void 0) {
          return null;
        }
        return domain;
      };
      var getContextDefault = function() {
        return null;
      };
      var getContextDomain = function() {
        return {
          domain: getDomain(),
          async: null
        };
      };
      var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? require("async_hooks").AsyncResource : null;
      var getContextAsyncHooks = function() {
        return {
          domain: getDomain(),
          async: new AsyncResource("Bluebird::Promise")
        };
      };
      var getContext = util.isNode ? getContextDomain : getContextDefault;
      util.notEnumerableProp(Promise2, "_getContext", getContext);
      var enableAsyncHooks = function() {
        getContext = getContextAsyncHooks;
        util.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
      };
      var disableAsyncHooks = function() {
        getContext = getContextDomain;
        util.notEnumerableProp(Promise2, "_getContext", getContextDomain);
      };
      var es52 = require_es5();
      var Async = require_async6();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug2 = require_debuggability()(Promise2, Context, enableAsyncHooks, disableAsyncHooks);
      var CapturedTrace = debug2.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (self2 == null || self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
      }
      function Promise2(executor) {
        if (executor !== INTERNAL) {
          check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          if (typeof fn !== "function") {
            throw new TypeError2("The last argument to .catch() must be a function, got " + util.toString(fn));
          }
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(reflectHandler2, reflectHandler2, void 0, this, void 0);
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug2.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj2) {
        var ret2 = tryConvertToPromise(obj2);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj2;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver2, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver2 === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver2 = this._boundValue();
            } else {
              receiver2 = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var context = getContext();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: util.contextBind(context, handler),
            promise,
            receiver: receiver2,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver2, context);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        var bitField = this._bitField;
        this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
      };
      Promise2.prototype._setNoAsyncGuarantee = function() {
        this._bitField = (this._bitField | 536870912) & ~134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver2 = follower._receiverAt(0);
        if (receiver2 === void 0)
          receiver2 = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver2, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver2 = follower._receiverAt(index);
        if (receiver2 === void 0)
          receiver2 = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver2, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, context) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver2;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = util.contextBind(context, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = util.contextBind(context, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver2;
          if (typeof fulfill === "function") {
            this[base + 0] = util.contextBind(context, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = util.contextBind(context, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(maybePromise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug2.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        if (executor === INTERNAL)
          return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver2 === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler).call(receiver2, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug2.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
            receiver2.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver2, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler2) {
            promise._fulfill(reflectHandler2.call(receiver2));
          } else if (receiver2 instanceof Proxyable) {
            receiver2._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver2.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver2, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver2, value, promise);
          }
        } else if (receiver2 instanceof Proxyable) {
          if (!receiver2._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver2._promiseFulfilled(value, promise);
            } else {
              receiver2._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver2 = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver2, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver2, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver2 = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver2, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
          this._dereferenceTrace();
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver2 = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver2, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver2 = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver2, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
          get: function() {
            return "Object";
          }
        });
      }
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug2.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
      require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug2);
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug2);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug2);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async);
      Promise2.Promise = Promise2;
      Promise2.version = "3.7.2";
      require_call_get()(Promise2);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2);
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
      require_settle()(Promise2, PromiseArray, debug2);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_timers()(Promise2, INTERNAL, debug2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2);
      require_any()(Promise2);
      require_each()(Promise2, INTERNAL);
      require_filter()(Promise2, INTERNAL);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug2.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/bluebird-npm-3.7.2-6a54136ee3-869417503c.zip/node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    "use strict";
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/consolidate-virtual-2c5dfc8d8e/0/cache/consolidate-npm-0.16.0-1a9b3c81f9-f17164ffb2.zip/node_modules/consolidate/lib/consolidate.js
var require_consolidate = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/consolidate-virtual-2c5dfc8d8e/0/cache/consolidate-npm-0.16.0-1a9b3c81f9-f17164ffb2.zip/node_modules/consolidate/lib/consolidate.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var Promise2 = require_bluebird();
    var join = path.join;
    var resolve = path.resolve;
    var extname = path.extname;
    var dirname = path.dirname;
    var isAbsolute = path.isAbsolute;
    var readCache = {};
    var cacheStore = {};
    var requires = {};
    exports2.clearCache = function() {
      readCache = {};
      cacheStore = {};
    };
    function cache(options, compiled) {
      if (compiled && options.filename && options.cache) {
        delete readCache[options.filename];
        cacheStore[options.filename] = compiled;
        return compiled;
      }
      if (options.filename && options.cache) {
        return cacheStore[options.filename];
      }
      return compiled;
    }
    function read(path2, options, cb) {
      var str = readCache[path2];
      var cached = options.cache && str && typeof str === "string";
      if (cached)
        return cb(null, str);
      fs2.readFile(path2, "utf8", function(err, str2) {
        if (err)
          return cb(err);
        str2 = str2.replace(/^\uFEFF/, "");
        if (options.cache)
          readCache[path2] = str2;
        cb(null, str2);
      });
    }
    function readPartials(path2, options, cb) {
      if (!options.partials)
        return cb();
      var keys = Object.keys(options.partials);
      var partials = {};
      function next(index) {
        if (index === keys.length)
          return cb(null, partials);
        var key = keys[index];
        var partialPath = options.partials[key];
        if (partialPath === void 0 || partialPath === null || partialPath === false) {
          return next(++index);
        }
        var file;
        if (isAbsolute(partialPath)) {
          if (extname(partialPath) !== "") {
            file = partialPath;
          } else {
            file = join(partialPath + extname(path2));
          }
        } else {
          file = join(dirname(path2), partialPath + extname(path2));
        }
        read(file, options, function(err, str) {
          if (err)
            return cb(err);
          partials[key] = str;
          next(++index);
        });
      }
      next(0);
    }
    function promisify(cb, fn) {
      return new Promise2(function(resolve2, reject) {
        cb = cb || function(err, html) {
          if (err) {
            return reject(err);
          }
          resolve2(html);
        };
        fn(cb);
      });
    }
    function fromStringRenderer(name) {
      return function(path2, options, cb) {
        options.filename = path2;
        return promisify(cb, function(cb2) {
          readPartials(path2, options, function(err, partials) {
            var extend = requires.extend || (requires.extend = require("util")._extend);
            var opts = extend({}, options);
            opts.partials = partials;
            if (err)
              return cb2(err);
            if (cache(opts)) {
              exports2[name].render("", opts, cb2);
            } else {
              read(path2, opts, function(err2, str) {
                if (err2)
                  return cb2(err2);
                exports2[name].render(str, opts, cb2);
              });
            }
          });
        });
      };
    }
    exports2.velocityjs = fromStringRenderer("velocityjs");
    exports2.velocityjs.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.velocityjs || (requires.velocityjs = require("velocityjs"));
        try {
          options.locals = options;
          cb2(null, engine.render(str, options).trimLeft());
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.liquid = fromStringRenderer("liquid");
    function _renderTinyliquid(engine, str, options, cb) {
      var context = engine.newContext();
      var k;
      if (options.locals) {
        for (k in options.locals) {
          context.setLocals(k, options.locals[k]);
        }
        delete options.locals;
      }
      if (options.meta) {
        context.setLocals("page", options.meta);
        delete options.meta;
      }
      if (options.filters) {
        for (k in options.filters) {
          context.setFilter(k, options.filters[k]);
        }
        delete options.filters;
      }
      var includeDir = options.includeDir || process.cwd();
      context.onInclude(function(name, callback) {
        var extname2 = path.extname(name) ? "" : ".liquid";
        var filename = path.resolve(includeDir, name + extname2);
        fs2.readFile(filename, { encoding: "utf8" }, function(err, data) {
          if (err)
            return callback(err);
          callback(null, engine.parse(data));
        });
      });
      delete options.includeDir;
      var compileOptions = {
        customTags: {}
      };
      if (options.customTags) {
        var tagFunctions = options.customTags;
        for (k in options.customTags) {
          compileOptions.customTags[k] = function(context2, name, body) {
            var tpl = tagFunctions[name](body.trim());
            context2.astStack.push(engine.parse(tpl));
          };
        }
        delete options.customTags;
      }
      for (k in options) {
        context.setLocals(k, options[k]);
      }
      var tmpl = cache(context) || cache(context, engine.compile(str, compileOptions));
      tmpl(context, cb);
    }
    exports2.liquid.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.liquid;
        var Liquid;
        try {
          engine = requires.liquid = require("tinyliquid");
          _renderTinyliquid(engine, str, options, cb2);
          return;
        } catch (err) {
          try {
            Liquid = requires.liquid = require("liquid-node");
            engine = new Liquid.Engine();
          } catch (err2) {
            throw err2;
          }
        }
        try {
          var locals = options.locals || {};
          if (options.meta) {
            locals.pages = options.meta;
            delete options.meta;
          }
          if (options.filters) {
            engine.registerFilters(options.filters);
            delete options.filters;
          }
          var includeDir = options.includeDir || process.cwd();
          engine.fileSystem = new Liquid.LocalFileSystem(includeDir, "liquid");
          delete options.includeDir;
          if (options.customTags) {
            var tagFunctions = options.customTags;
            for (k in options.customTags) {
              engine.registerTag(k, tagFunctions[k]);
            }
            delete options.customTags;
          }
          for (var k in options) {
            locals[k] = options[k];
          }
          return engine.parseAndRender(str, locals).nodeify(function(err, result) {
            if (err) {
              throw new Error(err);
            } else {
              return cb2(null, result);
            }
          });
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.jade = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.jade;
        if (!engine) {
          try {
            engine = requires.jade = require("jade");
          } catch (err) {
            try {
              engine = requires.jade = require("then-jade");
            } catch (otherError) {
              throw err;
            }
          }
        }
        try {
          var tmpl = cache(options) || cache(options, engine.compileFile(path2, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.jade.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.jade;
        if (!engine) {
          try {
            engine = requires.jade = require("jade");
          } catch (err) {
            try {
              engine = requires.jade = require("then-jade");
            } catch (otherError) {
              throw err;
            }
          }
        }
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.dust = fromStringRenderer("dust");
    exports2.dust.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.dust;
        if (!engine) {
          try {
            engine = requires.dust = require("dust");
          } catch (err) {
            try {
              engine = requires.dust = require("dustjs-helpers");
            } catch (err2) {
              engine = requires.dust = require("dustjs-linkedin");
            }
          }
        }
        var ext = "dust";
        var views = ".";
        if (options) {
          if (options.ext)
            ext = options.ext;
          if (options.views)
            views = options.views;
          if (options.settings && options.settings.views)
            views = options.settings.views;
        }
        if (!options || options && !options.cache)
          engine.cache = {};
        engine.onLoad = function(path2, callback) {
          if (extname(path2) === "")
            path2 += "." + ext;
          if (path2[0] !== "/")
            path2 = views + "/" + path2;
          read(path2, options, callback);
        };
        try {
          var templateName;
          if (options.filename) {
            templateName = options.filename.replace(new RegExp("^" + views + "/"), "").replace(new RegExp("\\." + ext), "");
          }
          var tmpl = cache(options) || cache(options, engine.compileFn(str, templateName));
          tmpl(options, cb2);
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.swig = fromStringRenderer("swig");
    exports2.swig.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.swig;
        if (!engine) {
          try {
            engine = requires.swig = require("swig");
          } catch (err) {
            try {
              engine = requires.swig = require("swig-templates");
            } catch (otherError) {
              throw err;
            }
          }
        }
        try {
          if (options.cache === true)
            options.cache = "memory";
          engine.setDefaults({ cache: options.cache });
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.razor = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.razor;
        if (!engine) {
          try {
            engine = requires.razor = require("razor-tmpl");
          } catch (err) {
            throw err;
          }
        }
        try {
          var tmpl = cache(options) || cache(options, (locals) => {
            console.log("Rendering razor file", path2);
            return engine.renderFileSync(path2, locals);
          });
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.razor.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        try {
          var engine = requires.razor = require("razor-tmpl");
        } catch (err) {
          throw err;
        }
        try {
          var tf = engine.compile(str);
          var tmpl = cache(options) || cache(options, tf);
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.atpl = fromStringRenderer("atpl");
    exports2.atpl.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.atpl || (requires.atpl = require("atpl"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.liquor = fromStringRenderer("liquor");
    exports2.liquor.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.liquor || (requires.liquor = require("liquor"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.twig = fromStringRenderer("twig");
    exports2.twig.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.twig || (requires.twig = require("twig").twig);
        var templateData = {
          data: str,
          allowInlineIncludes: options.allowInlineIncludes,
          namespaces: options.namespaces,
          path: options.path
        };
        try {
          var tmpl = cache(templateData) || cache(templateData, engine(templateData));
          cb2(null, tmpl.render(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.ejs = fromStringRenderer("ejs");
    exports2.ejs.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.ejs || (requires.ejs = require("ejs"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.eco = fromStringRenderer("eco");
    exports2.eco.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.eco || (requires.eco = require("eco"));
        try {
          cb2(null, engine.render(str, options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.jazz = fromStringRenderer("jazz");
    exports2.jazz.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.jazz || (requires.jazz = require("jazz"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          tmpl.eval(options, function(str2) {
            cb2(null, str2);
          });
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.jqtpl = fromStringRenderer("jqtpl");
    exports2.jqtpl.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.jqtpl || (requires.jqtpl = require("jqtpl"));
        try {
          engine.template(str, str);
          cb2(null, engine.tmpl(str, options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.haml = fromStringRenderer("haml");
    exports2.haml.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.haml || (requires.haml = require("hamljs"));
        try {
          options.locals = options;
          cb2(null, engine.render(str, options).trimLeft());
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.hamlet = fromStringRenderer("hamlet");
    exports2.hamlet.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.hamlet || (requires.hamlet = require("hamlet"));
        try {
          options.locals = options;
          cb2(null, engine.render(str, options).trimLeft());
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.whiskers = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.whiskers || (requires.whiskers = require("whiskers"));
        engine.__express(path2, options, cb2);
      });
    };
    exports2.whiskers.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.whiskers || (requires.whiskers = require("whiskers"));
        try {
          cb2(null, engine.render(str, options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2["haml-coffee"] = fromStringRenderer("haml-coffee");
    exports2["haml-coffee"].render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires["haml-coffee"] || (requires["haml-coffee"] = require("haml-coffee"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.hogan = fromStringRenderer("hogan");
    exports2.hogan.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.hogan || (requires.hogan = require("hogan.js"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl.render(options, options.partials));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.templayed = fromStringRenderer("templayed");
    exports2.templayed.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.templayed || (requires.templayed = require("templayed"));
        try {
          var tmpl = cache(options) || cache(options, engine(str));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.handlebars = fromStringRenderer("handlebars");
    exports2.handlebars.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.handlebars || (requires.handlebars = require("handlebars"));
        try {
          for (var partial in options.partials) {
            engine.registerPartial(partial, options.partials[partial]);
          }
          for (var helper in options.helpers) {
            engine.registerHelper(helper, options.helpers[helper]);
          }
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.underscore = fromStringRenderer("underscore");
    exports2.underscore.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.underscore || (requires.underscore = require("underscore"));
        try {
          const partials = {};
          for (var partial in options.partials) {
            partials[partial] = engine.template(options.partials[partial]);
          }
          options.partials = partials;
          var tmpl = cache(options) || cache(options, engine.template(str, null, options));
          cb2(null, tmpl(options).replace(/\n$/, ""));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.lodash = fromStringRenderer("lodash");
    exports2.lodash.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.lodash || (requires.lodash = require("lodash"));
        try {
          var tmpl = cache(options) || cache(options, engine.template(str, options));
          cb2(null, tmpl(options).replace(/\n$/, ""));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.pug = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.pug;
        if (!engine) {
          try {
            engine = requires.pug = require("pug");
          } catch (err) {
            try {
              engine = requires.pug = require("then-pug");
            } catch (otherError) {
              throw err;
            }
          }
        }
        try {
          var tmpl = cache(options) || cache(options, engine.compileFile(path2, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.pug.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.pug;
        if (!engine) {
          try {
            engine = requires.pug = require("pug");
          } catch (err) {
            try {
              engine = requires.pug = require("then-pug");
            } catch (otherError) {
              throw err;
            }
          }
        }
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.qejs = fromStringRenderer("qejs");
    exports2.qejs.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        try {
          var engine = requires.qejs || (requires.qejs = require("qejs"));
          engine.render(str, options).then(function(result) {
            cb2(null, result);
          }, function(err) {
            cb2(err);
          }).done();
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.walrus = fromStringRenderer("walrus");
    exports2.walrus.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.walrus || (requires.walrus = require("walrus"));
        try {
          var tmpl = cache(options) || cache(options, engine.parse(str));
          cb2(null, tmpl.compile(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.mustache = fromStringRenderer("mustache");
    exports2.mustache.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.mustache || (requires.mustache = require("mustache"));
        try {
          cb2(null, engine.render(str, options, options.partials));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.just = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.just;
        if (!engine) {
          var JUST = require("just");
          engine = requires.just = new JUST();
        }
        engine.configure({ useCache: options.cache });
        engine.render(path2, options, cb2);
      });
    };
    exports2.just.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var JUST = require("just");
        var engine = new JUST({ root: { page: str } });
        engine.render("page", options, cb2);
      });
    };
    exports2.ect = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.ect;
        if (!engine) {
          var ECT = require("ect");
          engine = requires.ect = new ECT(options);
        }
        engine.configure({ cache: options.cache });
        engine.render(path2, options, cb2);
      });
    };
    exports2.ect.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var ECT = require("ect");
        var engine = new ECT({ root: { page: str } });
        engine.render("page", options, cb2);
      });
    };
    exports2.mote = fromStringRenderer("mote");
    exports2.mote.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.mote || (requires.mote = require("mote"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.toffee = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var toffee = requires.toffee || (requires.toffee = require("toffee"));
        toffee.__consolidate_engine_render(path2, options, cb2);
      });
    };
    exports2.toffee.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.toffee || (requires.toffee = require("toffee"));
        try {
          engine.str_render(str, options, cb2);
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.dot = fromStringRenderer("dot");
    exports2.dot.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.dot || (requires.dot = require("dot"));
        var extend = requires.extend || (requires.extend = require("util")._extend);
        try {
          var settings = {};
          settings = extend(settings, engine.templateSettings);
          settings = extend(settings, options ? options.dot : {});
          var tmpl = cache(options) || cache(options, engine.template(str, settings, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.bracket = fromStringRenderer("bracket");
    exports2.bracket.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.bracket || (requires.bracket = require("bracket-template"));
        try {
          var tmpl = cache(options) || cache(options, engine.default.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.ractive = fromStringRenderer("ractive");
    exports2.ractive.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var Engine = requires.ractive || (requires.ractive = require("ractive"));
        var template2 = cache(options) || cache(options, Engine.parse(str));
        options.template = template2;
        if (options.data === null || options.data === void 0) {
          var extend = requires.extend || (requires.extend = require("util")._extend);
          options.data = extend({}, options);
          var i;
          var length;
          var properties = ["template", "filename", "cache", "partials"];
          for (i = 0, length = properties.length; i < length; i++) {
            var property = properties[i];
            delete options.data[property];
          }
        }
        try {
          cb2(null, new Engine(options).toHTML());
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.nunjucks = fromStringRenderer("nunjucks");
    exports2.nunjucks.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        try {
          var engine = options.nunjucksEnv || requires.nunjucks || (requires.nunjucks = require("nunjucks"));
          var env2 = engine;
          if (options.settings && options.settings.views) {
            env2 = engine.configure(options.settings.views);
          } else if (options.nunjucks && options.nunjucks.configure) {
            env2 = engine.configure.apply(engine, options.nunjucks.configure);
          }
          if (options.loader) {
            env2 = new engine.Environment(options.loader);
          } else if (options.settings && options.settings.views) {
            env2 = new engine.Environment(new engine.FileSystemLoader(options.settings.views));
          } else if (options.nunjucks && options.nunjucks.loader) {
            if (typeof options.nunjucks.loader === "string") {
              env2 = new engine.Environment(new engine.FileSystemLoader(options.nunjucks.loader));
            } else {
              env2 = new engine.Environment(new engine.FileSystemLoader(options.nunjucks.loader[0], options.nunjucks.loader[1]));
            }
          }
          env2.renderString(str, options, cb2);
        } catch (err) {
          throw cb2(err);
        }
      });
    };
    exports2.htmling = fromStringRenderer("htmling");
    exports2.htmling.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.htmling || (requires.htmling = require("htmling"));
        try {
          var tmpl = cache(options) || cache(options, engine.string(str));
          cb2(null, tmpl.render(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    function requireReact(module3, filename) {
      var babel = requires.babel || (requires.babel = require("babel-core"));
      var compiled = babel.transformFileSync(filename, { presets: ["react"] }).code;
      return module3._compile(compiled, filename);
    }
    exports2.requireReact = requireReact;
    function requireReactString(src, filename) {
      var babel = requires.babel || (requires.babel = require("babel-core"));
      if (!filename)
        filename = "";
      var m = new module2.constructor();
      filename = filename || "";
      var compiled = babel.transform(src, { presets: ["react"] }).code;
      m.paths = module2.paths;
      m._compile(compiled, filename);
      return m.exports;
    }
    function reactBaseTmpl(data, options) {
      var exp;
      var regex;
      for (var k in options) {
        if (options.hasOwnProperty(k)) {
          exp = "{{" + k + "}}";
          regex = new RegExp(exp, "g");
          if (data.match(regex)) {
            data = data.replace(regex, options[k]);
          }
        }
      }
      return data;
    }
    exports2.plates = fromStringRenderer("plates");
    exports2.plates.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.plates || (requires.plates = require("plates"));
        var map = options.map || void 0;
        try {
          var tmpl = engine.bind(str, options, map);
          cb2(null, tmpl);
        } catch (err) {
          cb2(err);
        }
      });
    };
    function reactRenderer(type) {
      if (require.extensions) {
        if (!require.extensions[".jsx"]) {
          require.extensions[".jsx"] = requireReact;
        }
        if (!require.extensions[".react"]) {
          require.extensions[".react"] = requireReact;
        }
      }
      return function(str, options, cb) {
        return promisify(cb, function(cb2) {
          var ReactDOM = requires.ReactDOM || (requires.ReactDOM = require("react-dom/server"));
          var react = requires.react || (requires.react = require("react"));
          var base = options.base;
          delete options.base;
          var enableCache = options.cache;
          delete options.cache;
          var isNonStatic = options.isNonStatic;
          delete options.isNonStatic;
          try {
            var Code;
            var Factory;
            var baseStr;
            var content;
            var parsed;
            if (!cache(options)) {
              if (type === "path") {
                var path2 = resolve(str);
                delete require.cache[path2];
                Code = require(path2);
              } else {
                Code = requireReactString(str);
              }
              Factory = cache(options, react.createFactory(Code));
            } else {
              Factory = cache(options);
            }
            parsed = new Factory(options);
            content = isNonStatic ? ReactDOM.renderToString(parsed) : ReactDOM.renderToStaticMarkup(parsed);
            if (base) {
              baseStr = readCache[str] || fs2.readFileSync(resolve(base), "utf8");
              if (enableCache) {
                readCache[str] = baseStr;
              }
              options.content = content;
              content = reactBaseTmpl(baseStr, options);
            }
            cb2(null, content);
          } catch (err) {
            cb2(err);
          }
        });
      };
    }
    exports2.react = reactRenderer("path");
    exports2.react.render = reactRenderer("string");
    exports2["arc-templates"] = fromStringRenderer("arc-templates");
    exports2["arc-templates"].render = function(str, options, cb) {
      var readFileWithOptions = Promise2.promisify(read);
      var consolidateFileSystem = {};
      consolidateFileSystem.readFile = function(path2) {
        return readFileWithOptions(path2, options);
      };
      return promisify(cb, function(cb2) {
        try {
          var engine = requires["arc-templates"];
          if (!engine) {
            var Engine = require("arc-templates/dist/es5");
            engine = requires["arc-templates"] = new Engine({ filesystem: consolidateFileSystem });
          }
          var compiler = cache(options) || cache(options, engine.compileString(str, options.filename));
          compiler.then(function(func) {
            return func(options);
          }).then(function(result) {
            cb2(null, result.content);
          }).catch(cb2);
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.vash = fromStringRenderer("vash");
    exports2.vash.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.vash || (requires.vash = require("vash"));
        try {
          if (options.helpers) {
            for (var key in options.helpers) {
              if (!options.helpers.hasOwnProperty(key) || typeof options.helpers[key] !== "function") {
                continue;
              }
              engine.helpers[key] = options.helpers[key];
            }
          }
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          tmpl(options, function sealLayout(err, ctx) {
            if (err)
              cb2(err);
            ctx.finishLayout();
            cb2(null, ctx.toString().replace(/\n$/, ""));
          });
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.slm = fromStringRenderer("slm");
    exports2.slm.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.slm || (requires.slm = require("slm"));
        try {
          var tmpl = cache(options) || cache(options, engine.compile(str, options));
          cb2(null, tmpl(options));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.marko = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.marko || (requires.marko = require("marko"));
        options.writeToDisk = !!options.cache;
        try {
          var tmpl = cache(options) || cache(options, engine.load(path2, options));
          tmpl.renderToString(options, cb2);
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.marko.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.marko || (requires.marko = require("marko"));
        options.writeToDisk = !!options.cache;
        options.filename = options.filename || "string.marko";
        try {
          var tmpl = cache(options) || cache(options, engine.load(options.filename, str, options));
          tmpl.renderToString(options, cb2);
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.teacup = function(path2, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.teacup || (requires.teacup = require("teacup/lib/express"));
        require.extensions[".teacup"] = require.extensions[".coffee"];
        if (path2[0] !== "/") {
          path2 = join(process.cwd(), path2);
        }
        if (!options.cache) {
          var callback = cb2;
          cb2 = function() {
            delete require.cache[path2];
            callback.apply(this, arguments);
          };
        }
        engine.renderFile(path2, options, cb2);
      });
    };
    exports2.teacup.render = function(str, options, cb) {
      var coffee = require("coffee-script");
      var vm = require("vm");
      var sandbox = {
        module: { exports: {} },
        require
      };
      return promisify(cb, function(cb2) {
        vm.runInNewContext(coffee.compile(str), sandbox);
        var tmpl = sandbox.module.exports;
        cb2(null, tmpl(options));
      });
    };
    exports2.squirrelly = fromStringRenderer("squirrelly");
    exports2.squirrelly.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.squirrelly || (requires.squirrelly = require("squirrelly"));
        try {
          for (var partial in options.partials) {
            engine.definePartial(partial, options.partials[partial]);
          }
          for (var helper in options.helpers) {
            engine.defineHelper(helper, options.helpers[helper]);
          }
          var tmpl = cache(options) || cache(options, engine.Compile(str, options));
          cb2(null, tmpl(options, engine));
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.twing = fromStringRenderer("twing");
    exports2.twing.render = function(str, options, cb) {
      return promisify(cb, function(cb2) {
        var engine = requires.twing || (requires.twing = require("twing"));
        try {
          new engine.TwingEnvironment(new engine.TwingLoaderNull()).createTemplate(str).then((twingTemplate) => {
            twingTemplate.render(options).then((rendTmpl) => {
              var tmpl = cache(options) || cache(options, rendTmpl);
              cb2(null, tmpl);
            });
          });
        } catch (err) {
          cb2(err);
        }
      });
    };
    exports2.requires = requires;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/consolidate-virtual-2c5dfc8d8e/0/cache/consolidate-npm-0.16.0-1a9b3c81f9-f17164ffb2.zip/node_modules/consolidate/index.js
var require_consolidate2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/consolidate-virtual-2c5dfc8d8e/0/cache/consolidate-npm-0.16.0-1a9b3c81f9-f17164ffb2.zip/node_modules/consolidate/index.js"(exports2, module2) {
    module2.exports = require_consolidate();
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/lodash.camelcase-npm-4.3.0-bf268e3bf0-cb9227612f.zip/node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/lodash.camelcase-npm-4.3.0-bf268e3bf0-cb9227612f.zip/node_modules/lodash.camelcase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/unicode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Space_Separator = exports2.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    var ID_Start = exports2.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/;
    var ID_Continue = exports2.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/util.js
var require_util5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSpaceSeparator = isSpaceSeparator;
    exports2.isIdStartChar = isIdStartChar;
    exports2.isIdContinueChar = isIdContinueChar;
    exports2.isDigit = isDigit;
    exports2.isHexDigit = isHexDigit;
    var _unicode = require_unicode();
    var unicode = _interopRequireWildcard(_unicode);
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      } else {
        var newObj = {};
        if (obj2 != null) {
          for (var key in obj2) {
            if (Object.prototype.hasOwnProperty.call(obj2, key))
              newObj[key] = obj2[key];
          }
        }
        newObj.default = obj2;
        return newObj;
      }
    }
    function isSpaceSeparator(c) {
      return unicode.Space_Separator.test(c);
    }
    function isIdStartChar(c) {
      return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c);
    }
    function isIdContinueChar(c) {
      return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c);
    }
    function isDigit(c) {
      return /[0-9]/.test(c);
    }
    function isHexDigit(c) {
      return /[0-9A-Fa-f]/.test(c);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/parse.js
var require_parse4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/parse.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
    exports2.default = parse3;
    var _util = require_util5();
    var util = _interopRequireWildcard(_util);
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      } else {
        var newObj = {};
        if (obj2 != null) {
          for (var key2 in obj2) {
            if (Object.prototype.hasOwnProperty.call(obj2, key2))
              newObj[key2] = obj2[key2];
          }
        }
        newObj.default = obj2;
        return newObj;
      }
    }
    var source = void 0;
    var parseState = void 0;
    var stack = void 0;
    var pos = void 0;
    var line = void 0;
    var column = void 0;
    var token = void 0;
    var key = void 0;
    var root = void 0;
    function parse3(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    }
    function internalize(holder, name, reviver) {
      var value = holder[name];
      if (value != null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
        for (var _key in value) {
          var replacement = internalize(value, _key, reviver);
          if (replacement === void 0) {
            delete value[_key];
          } else {
            value[_key] = replacement;
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState = void 0;
    var buffer = void 0;
    var doubleQuote = void 0;
    var _sign = void 0;
    var c = void 0;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      _sign = 1;
      for (; ; ) {
        c = peek();
        var _token = lexStates[lexState]();
        if (_token) {
          return _token;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read() {
      var c2 = peek();
      if (c2 === "\n") {
        line++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = { default: function _default() {
      switch (c) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          read();
          return;
        case "/":
          read();
          lexState = "comment";
          return;
        case void 0:
          read();
          return newToken("eof");
      }
      if (util.isSpaceSeparator(c)) {
        read();
        return;
      }
      return lexStates[parseState]();
    }, comment: function comment() {
      switch (c) {
        case "*":
          read();
          lexState = "multiLineComment";
          return;
        case "/":
          read();
          lexState = "singleLineComment";
          return;
      }
      throw invalidChar(read());
    }, multiLineComment: function multiLineComment() {
      switch (c) {
        case "*":
          read();
          lexState = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw invalidChar(read());
      }
      read();
    }, multiLineCommentAsterisk: function multiLineCommentAsterisk() {
      switch (c) {
        case "*":
          read();
          return;
        case "/":
          read();
          lexState = "default";
          return;
        case void 0:
          throw invalidChar(read());
      }
      read();
      lexState = "multiLineComment";
    }, singleLineComment: function singleLineComment() {
      switch (c) {
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          read();
          lexState = "default";
          return;
        case void 0:
          read();
          return newToken("eof");
      }
      read();
    }, value: function value() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
        case "n":
          read();
          literal("ull");
          return newToken("null", null);
        case "t":
          read();
          literal("rue");
          return newToken("boolean", true);
        case "f":
          read();
          literal("alse");
          return newToken("boolean", false);
        case "-":
        case "+":
          if (read() === "-") {
            _sign = -1;
          }
          lexState = "sign";
          return;
        case ".":
          buffer = read();
          lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read();
          lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read();
          lexState = "decimalInteger";
          return;
        case "I":
          read();
          literal("nfinity");
          return newToken("numeric", Infinity);
        case "N":
          read();
          literal("aN");
          return newToken("numeric", NaN);
        case '"':
        case "'":
          doubleQuote = read() === '"';
          buffer = "";
          lexState = "string";
          return;
      }
      throw invalidChar(read());
    }, identifierNameStartEscape: function identifierNameStartEscape() {
      if (c !== "u") {
        throw invalidChar(read());
      }
      read();
      var u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
          break;
        default:
          if (!util.isIdStartChar(u)) {
            throw invalidIdentifier();
          }
          break;
      }
      buffer += u;
      lexState = "identifierName";
    }, identifierName: function identifierName() {
      switch (c) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          buffer += read();
          return;
        case "\\":
          read();
          lexState = "identifierNameEscape";
          return;
      }
      if (util.isIdContinueChar(c)) {
        buffer += read();
        return;
      }
      return newToken("identifier", buffer);
    }, identifierNameEscape: function identifierNameEscape() {
      if (c !== "u") {
        throw invalidChar(read());
      }
      read();
      var u = unicodeEscape();
      switch (u) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!util.isIdContinueChar(u)) {
            throw invalidIdentifier();
          }
          break;
      }
      buffer += u;
      lexState = "identifierName";
    }, sign: function sign() {
      switch (c) {
        case ".":
          buffer = read();
          lexState = "decimalPointLeading";
          return;
        case "0":
          buffer = read();
          lexState = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          buffer = read();
          lexState = "decimalInteger";
          return;
        case "I":
          read();
          literal("nfinity");
          return newToken("numeric", _sign * Infinity);
        case "N":
          read();
          literal("aN");
          return newToken("numeric", NaN);
      }
      throw invalidChar(read());
    }, zero: function zero() {
      switch (c) {
        case ".":
          buffer += read();
          lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
        case "x":
        case "X":
          buffer += read();
          lexState = "hexadecimal";
          return;
      }
      return newToken("numeric", _sign * 0);
    }, decimalInteger: function decimalInteger() {
      switch (c) {
        case ".":
          buffer += read();
          lexState = "decimalPoint";
          return;
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", _sign * Number(buffer));
    }, decimalPointLeading: function decimalPointLeading() {
      if (util.isDigit(c)) {
        buffer += read();
        lexState = "decimalFraction";
        return;
      }
      throw invalidChar(read());
    }, decimalPoint: function decimalPoint() {
      switch (c) {
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util.isDigit(c)) {
        buffer += read();
        lexState = "decimalFraction";
        return;
      }
      return newToken("numeric", _sign * Number(buffer));
    }, decimalFraction: function decimalFraction() {
      switch (c) {
        case "e":
        case "E":
          buffer += read();
          lexState = "decimalExponent";
          return;
      }
      if (util.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", _sign * Number(buffer));
    }, decimalExponent: function decimalExponent() {
      switch (c) {
        case "+":
        case "-":
          buffer += read();
          lexState = "decimalExponentSign";
          return;
      }
      if (util.isDigit(c)) {
        buffer += read();
        lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    }, decimalExponentSign: function decimalExponentSign() {
      if (util.isDigit(c)) {
        buffer += read();
        lexState = "decimalExponentInteger";
        return;
      }
      throw invalidChar(read());
    }, decimalExponentInteger: function decimalExponentInteger() {
      if (util.isDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", _sign * Number(buffer));
    }, hexadecimal: function hexadecimal() {
      if (util.isHexDigit(c)) {
        buffer += read();
        lexState = "hexadecimalInteger";
        return;
      }
      throw invalidChar(read());
    }, hexadecimalInteger: function hexadecimalInteger() {
      if (util.isHexDigit(c)) {
        buffer += read();
        return;
      }
      return newToken("numeric", _sign * Number(buffer));
    }, string: function string() {
      switch (c) {
        case "\\":
          read();
          buffer += escape();
          return;
        case '"':
          if (doubleQuote) {
            read();
            return newToken("string", buffer);
          }
          buffer += read();
          return;
        case "'":
          if (!doubleQuote) {
            read();
            return newToken("string", buffer);
          }
          buffer += read();
          return;
        case "\n":
        case "\r":
          throw invalidChar(read());
        case "\u2028":
        case "\u2029":
          separatorChar(c);
          break;
        case void 0:
          throw invalidChar(read());
      }
      buffer += read();
    }, start: function start() {
      switch (c) {
        case "{":
        case "[":
          return newToken("punctuator", read());
      }
      lexState = "value";
    }, beforePropertyName: function beforePropertyName() {
      switch (c) {
        case "$":
        case "_":
          buffer = read();
          lexState = "identifierName";
          return;
        case "\\":
          read();
          lexState = "identifierNameStartEscape";
          return;
        case "}":
          return newToken("punctuator", read());
        case '"':
        case "'":
          doubleQuote = read() === '"';
          lexState = "string";
          return;
      }
      if (util.isIdStartChar(c)) {
        buffer += read();
        lexState = "identifierName";
        return;
      }
      throw invalidChar(read());
    }, afterPropertyName: function afterPropertyName() {
      if (c === ":") {
        return newToken("punctuator", read());
      }
      throw invalidChar(read());
    }, beforePropertyValue: function beforePropertyValue() {
      lexState = "value";
    }, afterPropertyValue: function afterPropertyValue() {
      switch (c) {
        case ",":
        case "}":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    }, beforeArrayValue: function beforeArrayValue() {
      if (c === "]") {
        return newToken("punctuator", read());
      }
      lexState = "value";
    }, afterArrayValue: function afterArrayValue() {
      switch (c) {
        case ",":
        case "]":
          return newToken("punctuator", read());
      }
      throw invalidChar(read());
    }, end: function end() {
      throw invalidChar(read());
    } };
    function newToken(type, value) {
      return { type, value, line, column };
    }
    function literal(s) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = s[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _c = _step.value;
          var p = peek();
          if (p !== _c) {
            throw invalidChar(read());
          }
          read();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    function escape() {
      var c2 = peek();
      switch (c2) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util.isDigit(peek())) {
            throw invalidChar(read());
          }
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      var buffer2 = "";
      var c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      var buffer2 = "";
      var count = 4;
      while (count-- > 0) {
        var _c2 = peek();
        if (!util.isHexDigit(_c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = { start: function start() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      push();
    }, beforePropertyName: function beforePropertyName() {
      switch (token.type) {
        case "identifier":
        case "string":
          key = token.value;
          parseState = "afterPropertyName";
          return;
        case "punctuator":
          pop();
          return;
        case "eof":
          throw invalidEOF();
      }
    }, afterPropertyName: function afterPropertyName() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      parseState = "beforePropertyValue";
    }, beforePropertyValue: function beforePropertyValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      push();
    }, beforeArrayValue: function beforeArrayValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      if (token.type === "punctuator" && token.value === "]") {
        pop();
        return;
      }
      push();
    }, afterPropertyValue: function afterPropertyValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      switch (token.value) {
        case ",":
          parseState = "beforePropertyName";
          return;
        case "}":
          pop();
      }
    }, afterArrayValue: function afterArrayValue() {
      if (token.type === "eof") {
        throw invalidEOF();
      }
      switch (token.value) {
        case ",":
          parseState = "beforeArrayValue";
          return;
        case "]":
          pop();
      }
    }, end: function end() {
    } };
    function push() {
      var value = void 0;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        var parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          parent[key] = value;
        }
      }
      if (value !== null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        var current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      var current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
      }
      return syntaxError("JSON5: invalid character '" + formatChar(c2) + "' at " + line + ":" + column);
    }
    function invalidEOF() {
      return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
    }
    function separatorChar(c2) {
      console.warn("JSON5: '" + c2 + "' is not valid ECMAScript; consider escaping");
    }
    function formatChar(c2) {
      var replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        var hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      var err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
    module2.exports = exports2["default"];
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/stringify.js
var require_stringify3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/stringify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
    exports2.default = stringify2;
    var _util = require_util5();
    var util = _interopRequireWildcard(_util);
    function _interopRequireWildcard(obj2) {
      if (obj2 && obj2.__esModule) {
        return obj2;
      } else {
        var newObj = {};
        if (obj2 != null) {
          for (var key in obj2) {
            if (Object.prototype.hasOwnProperty.call(obj2, key))
              newObj[key] = obj2[key];
          }
        }
        newObj.default = obj2;
        return newObj;
      }
    }
    function stringify2(value, replacer, space) {
      var stack = [];
      var indent = "";
      var propertyList = void 0;
      var replacerFunc = void 0;
      var gap = "";
      var quote = void 0;
      if (replacer != null && (typeof replacer === "undefined" ? "undefined" : _typeof(replacer)) === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = replacer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var v = _step.value;
            var item = void 0;
            if (typeof v === "string") {
              item = v;
            } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
              item = String(v);
            }
            if (item !== void 0 && propertyList.indexOf(item) < 0) {
              propertyList.push(item);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", { "": value });
      function serializeProperty(key, holder) {
        var value2 = holder[key];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if ((typeof value2 === "undefined" ? "undefined" : _typeof(value2)) === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        var quotes = { "'": 0.1, '"': 0.2 };
        var replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
        var product = "";
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = value2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var c = _step2.value;
            switch (c) {
              case "'":
              case '"':
                quotes[c]++;
                product += c;
                continue;
            }
            if (replacements[c]) {
              product += replacements[c];
              continue;
            }
            if (c < " ") {
              var hexString = c.charCodeAt(0).toString(16);
              product += "\\x" + ("00" + hexString).substring(hexString.length);
              continue;
            }
            product += c;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var quoteChar = quote || Object.keys(quotes).reduce(function(a, b) {
          return quotes[a] < quotes[b] ? a : b;
        });
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        var stepback = indent;
        indent = indent + gap;
        var keys = propertyList || Object.keys(value2);
        var partial = [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var key = _step3.value;
            var propertyString = serializeProperty(key, value2);
            if (propertyString !== void 0) {
              var member = serializeKey(key) + ":";
              if (gap !== "") {
                member += " ";
              }
              member += propertyString;
              partial.push(member);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        var final = void 0;
        if (partial.length === 0) {
          final = "{}";
        } else {
          var properties = void 0;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            var separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key) {
        if (key.length === 0) {
          return quoteString(key, true);
        }
        var firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key, true);
        }
        for (var i = firstChar.length; i < key.length; i++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
            return quoteString(key, true);
          }
        }
        return key;
      }
      function serializeArray(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        var stepback = indent;
        indent = indent + gap;
        var partial = [];
        for (var i = 0; i < value2.length; i++) {
          var propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        var final = void 0;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            var properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            var separator = ",\n" + indent;
            var _properties = partial.join(separator);
            final = "[\n" + indent + _properties + ",\n" + stepback + "]";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
    }
    module2.exports = exports2["default"];
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/index.js
var require_lib2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/json5-npm-1.0.1-647fc8794b-e76ea23dbb.zip/node_modules/json5/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _parse = require_parse4();
    var _parse2 = _interopRequireDefault(_parse);
    var _stringify = require_stringify3();
    var _stringify2 = _interopRequireDefault(_stringify);
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    exports2.default = { parse: _parse2.default, stringify: _stringify2.default };
    module2.exports = exports2["default"];
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/parseQuery.js
var require_parseQuery = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/parseQuery.js"(exports2, module2) {
    "use strict";
    var JSON5 = require_lib2();
    var specialValues = {
      null: null,
      true: true,
      false: false
    };
    function parseQuery(query) {
      if (query.substr(0, 1) !== "?") {
        throw new Error("A valid query string passed to parseQuery should begin with '?'");
      }
      query = query.substr(1);
      if (!query) {
        return {};
      }
      if (query.substr(0, 1) === "{" && query.substr(-1) === "}") {
        return JSON5.parse(query);
      }
      const queryArgs = query.split(/[,&]/g);
      const result = {};
      queryArgs.forEach((arg) => {
        const idx = arg.indexOf("=");
        if (idx >= 0) {
          let name = arg.substr(0, idx);
          let value = decodeURIComponent(arg.substr(idx + 1));
          if (specialValues.hasOwnProperty(value)) {
            value = specialValues[value];
          }
          if (name.substr(-2) === "[]") {
            name = decodeURIComponent(name.substr(0, name.length - 2));
            if (!Array.isArray(result[name])) {
              result[name] = [];
            }
            result[name].push(value);
          } else {
            name = decodeURIComponent(name);
            result[name] = value;
          }
        } else {
          if (arg.substr(0, 1) === "-") {
            result[decodeURIComponent(arg.substr(1))] = false;
          } else if (arg.substr(0, 1) === "+") {
            result[decodeURIComponent(arg.substr(1))] = true;
          } else {
            result[decodeURIComponent(arg)] = true;
          }
        }
      });
      return result;
    }
    module2.exports = parseQuery;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getOptions.js
var require_getOptions = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getOptions.js"(exports2, module2) {
    "use strict";
    var parseQuery = require_parseQuery();
    function getOptions(loaderContext) {
      const query = loaderContext.query;
      if (typeof query === "string" && query !== "") {
        return parseQuery(loaderContext.query);
      }
      if (!query || typeof query !== "object") {
        return null;
      }
      return query;
    }
    module2.exports = getOptions;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/stringifyRequest.js
var require_stringifyRequest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/stringifyRequest.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var matchRelativePath = /^\.\.?[/\\]/;
    function isAbsolutePath(str) {
      return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);
    }
    function isRelativePath(str) {
      return matchRelativePath.test(str);
    }
    function stringifyRequest(loaderContext, request) {
      const splitted = request.split("!");
      const context = loaderContext.context || loaderContext.options && loaderContext.options.context;
      return JSON.stringify(splitted.map((part) => {
        const splittedPart = part.match(/^(.*?)(\?.*)/);
        const query = splittedPart ? splittedPart[2] : "";
        let singlePath = splittedPart ? splittedPart[1] : part;
        if (isAbsolutePath(singlePath) && context) {
          singlePath = path.relative(context, singlePath);
          if (isAbsolutePath(singlePath)) {
            return singlePath + query;
          }
          if (isRelativePath(singlePath) === false) {
            singlePath = "./" + singlePath;
          }
        }
        return singlePath.replace(/\\/g, "/") + query;
      }).join("!"));
    }
    module2.exports = stringifyRequest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getRemainingRequest.js
var require_getRemainingRequest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getRemainingRequest.js"(exports2, module2) {
    "use strict";
    function getRemainingRequest(loaderContext) {
      if (loaderContext.remainingRequest) {
        return loaderContext.remainingRequest;
      }
      const request = loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((obj2) => obj2.request).concat([loaderContext.resource]);
      return request.join("!");
    }
    module2.exports = getRemainingRequest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getCurrentRequest.js
var require_getCurrentRequest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getCurrentRequest.js"(exports2, module2) {
    "use strict";
    function getCurrentRequest(loaderContext) {
      if (loaderContext.currentRequest) {
        return loaderContext.currentRequest;
      }
      const request = loaderContext.loaders.slice(loaderContext.loaderIndex).map((obj2) => obj2.request).concat([loaderContext.resource]);
      return request.join("!");
    }
    module2.exports = getCurrentRequest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/isUrlRequest.js
var require_isUrlRequest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/isUrlRequest.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    function isUrlRequest(url, root) {
      if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !path.win32.isAbsolute(url)) {
        return false;
      }
      if (/^\/\//.test(url)) {
        return false;
      }
      if (/^[{}[\]#*;,'$%&(=?`^<>]/.test(url)) {
        return false;
      }
      if ((root === void 0 || root === false) && /^\//.test(url)) {
        return false;
      }
      return true;
    }
    module2.exports = isUrlRequest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/urlToRequest.js
var require_urlToRequest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/urlToRequest.js"(exports2, module2) {
    "use strict";
    var matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
    function urlToRequest(url, root) {
      if (url === "") {
        return "";
      }
      const moduleRequestRegex = /^[^?]*~/;
      let request;
      if (matchNativeWin32Path.test(url)) {
        request = url;
      } else if (root !== void 0 && root !== false && /^\//.test(url)) {
        switch (typeof root) {
          case "string":
            if (moduleRequestRegex.test(root)) {
              request = root.replace(/([^~/])$/, "$1/") + url.slice(1);
            } else {
              request = root + url;
            }
            break;
          case "boolean":
            request = url;
            break;
          default:
            throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url + ", root = " + root + ".");
        }
      } else if (/^\.\.?\//.test(url)) {
        request = url;
      } else {
        request = "./" + url;
      }
      if (moduleRequestRegex.test(request)) {
        request = request.replace(moduleRequestRegex, "");
      }
      return request;
    }
    module2.exports = urlToRequest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/parseString.js
var require_parseString = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/parseString.js"(exports2, module2) {
    "use strict";
    function parseString(str) {
      try {
        if (str[0] === '"') {
          return JSON.parse(str);
        }
        if (str[0] === "'" && str.substr(str.length - 1) === "'") {
          return parseString(str.replace(/\\.|"/g, (x) => x === '"' ? '\\"' : x).replace(/^'|'$/g, '"'));
        }
        return JSON.parse('"' + str + '"');
      } catch (e) {
        return str;
      }
    }
    module2.exports = parseString;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/big.js-npm-5.2.2-e147c30820-b89b6e8419.zip/node_modules/big.js/big.mjs
var big_exports = {};
__export(big_exports, {
  Big: () => Big,
  default: () => big_default
});
function _Big_() {
  function Big2(n) {
    var x = this;
    if (!(x instanceof Big2))
      return n === UNDEFINED ? _Big_() : new Big2(n);
    if (n instanceof Big2) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }
    x.constructor = Big2;
  }
  Big2.prototype = P;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.version = "5.2.2";
  return Big2;
}
function parse(x, n) {
  var e, i, nl;
  if (n === 0 && 1 / n < 0)
    n = "-0";
  else if (!NUMERIC.test(n += ""))
    throw Error(INVALID + "number");
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1)
    n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; )
    ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; )
      ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; )
      x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round(x, dp, rm, more) {
  var xc = x.c, i = x.e + dp + 1;
  if (i < xc.length) {
    if (rm === 1) {
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0)
        throw Error(INVALID_RM);
    }
    if (i < 1) {
      xc.length = 1;
      if (more) {
        x.e = -dp;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else {
      xc.length = i--;
      if (more) {
        for (; ++xc[i] > 9; ) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }
      for (i = xc.length; !xc[--i]; )
        xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x;
}
function stringify(x, id, n, k) {
  var e, s, Big2 = x.constructor, z = !x.c[0];
  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
    }
    x = new Big2(x);
    n = k - x.e;
    if (x.c.length > ++k)
      round(x, n, Big2.RM);
    if (id == 2)
      k = x.e + n + 1;
    for (; x.c.length < k; )
      x.c.push(0);
  }
  e = x.e;
  s = x.c.join("");
  n = s.length;
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big2.NE || e >= Big2.PE)) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; )
      s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n)
      for (e -= n; e--; )
        s += "0";
    else if (e < n)
      s = s.slice(0, e) + "." + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && (!z || id == 4) ? "-" + s : s;
}
var DP, RM, MAX_DP, MAX_POWER, NE, PE, NAME, INVALID, INVALID_DP, INVALID_RM, DIV_BY_ZERO, P, UNDEFINED, NUMERIC, Big, big_default;
var init_big = __esm({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/big.js-npm-5.2.2-e147c30820-b89b6e8419.zip/node_modules/big.js/big.mjs"() {
    DP = 20;
    RM = 1;
    MAX_DP = 1e6;
    MAX_POWER = 1e6;
    NE = -7;
    PE = 21;
    NAME = "[big.js] ";
    INVALID = NAME + "Invalid ";
    INVALID_DP = INVALID + "decimal places";
    INVALID_RM = INVALID + "rounding mode";
    DIV_BY_ZERO = NAME + "Division by zero";
    P = {};
    UNDEFINED = void 0;
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    P.abs = function() {
      var x = new this.constructor(this);
      x.s = 1;
      return x;
    };
    P.cmp = function(y) {
      var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!xc[0] || !yc[0])
        return !xc[0] ? !yc[0] ? 0 : -j : i;
      if (i != j)
        return i;
      isneg = i < 0;
      if (k != l)
        return k > l ^ isneg ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = -1; ++i < j; ) {
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ isneg ? 1 : -1;
      }
      return k == l ? 0 : k > l ^ isneg ? 1 : -1;
    };
    P.div = function(y) {
      var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
        throw Error(INVALID_DP);
      if (!b[0])
        throw Error(DIV_BY_ZERO);
      if (!a[0])
        return new Big2(k * 0);
      var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
      q.s = k;
      k = d < 0 ? 0 : d;
      bz.unshift(0);
      for (; rl++ < bl; )
        r.push(0);
      do {
        for (n = 0; n < 10; n++) {
          if (bl != (rl = r.length)) {
            cmp = bl > rl ? 1 : -1;
          } else {
            for (ri = -1, cmp = 0; ++ri < bl; ) {
              if (b[ri] != r[ri]) {
                cmp = b[ri] > r[ri] ? 1 : -1;
                break;
              }
            }
          }
          if (cmp < 0) {
            for (bt = rl == bl ? b : bz; rl; ) {
              if (r[--rl] < bt[rl]) {
                ri = rl;
                for (; ri && !r[--ri]; )
                  r[ri] = 9;
                --r[ri];
                r[rl] += 10;
              }
              r[rl] -= bt[rl];
            }
            for (; !r[0]; )
              r.shift();
          } else {
            break;
          }
        }
        qc[qi++] = cmp ? n : ++n;
        if (r[0] && cmp)
          r[rl] = a[ai] || 0;
        else
          r = [a[ai]];
      } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
      if (!qc[0] && qi != 1) {
        qc.shift();
        q.e--;
      }
      if (qi > d)
        round(q, dp, Big2.RM, r[0] !== UNDEFINED);
      return q;
    };
    P.eq = function(y) {
      return !this.cmp(y);
    };
    P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.gte = function(y) {
      return this.cmp(y) > -1;
    };
    P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.minus = P.sub = function(y) {
      var i, j, t2, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new Big2(xc[0] ? x : 0);
      }
      if (a = xe - ye) {
        if (xlty = a < 0) {
          a = -a;
          t2 = xc;
        } else {
          ye = xe;
          t2 = yc;
        }
        t2.reverse();
        for (b = a; b--; )
          t2.push(0);
        t2.reverse();
      } else {
        j = ((xlty = xc.length < yc.length) ? xc : yc).length;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xlty = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xlty) {
        t2 = xc;
        xc = yc;
        yc = t2;
        y.s = -y.s;
      }
      if ((b = (j = yc.length) - (i = xc.length)) > 0)
        for (; b--; )
          xc[i++] = 0;
      for (b = i; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; )
            xc[i] = 9;
          --xc[i];
          xc[j] += 10;
        }
        xc[j] -= yc[j];
      }
      for (; xc[--b] === 0; )
        xc.pop();
      for (; xc[0] === 0; ) {
        xc.shift();
        --ye;
      }
      if (!xc[0]) {
        y.s = 1;
        xc = [ye = 0];
      }
      y.c = xc;
      y.e = ye;
      return y;
    };
    P.mod = function(y) {
      var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
      if (!y.c[0])
        throw Error(DIV_BY_ZERO);
      x.s = y.s = 1;
      ygtx = y.cmp(x) == 1;
      x.s = a;
      y.s = b;
      if (ygtx)
        return new Big2(x);
      a = Big2.DP;
      b = Big2.RM;
      Big2.DP = Big2.RM = 0;
      x = x.div(y);
      Big2.DP = a;
      Big2.RM = b;
      return this.minus(x.times(y));
    };
    P.plus = P.add = function(y) {
      var t2, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new Big2(xc[0] ? x : a * 0);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t2 = yc;
        } else {
          a = -a;
          t2 = xc;
        }
        t2.reverse();
        for (; a--; )
          t2.push(0);
        t2.reverse();
      }
      if (xc.length - yc.length < 0) {
        t2 = yc;
        yc = xc;
        xc = t2;
      }
      a = yc.length;
      for (b = 0; a; xc[a] %= 10)
        b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
      if (b) {
        xc.unshift(b);
        ++ye;
      }
      for (a = xc.length; xc[--a] === 0; )
        xc.pop();
      y.c = xc;
      y.e = ye;
      return y;
    };
    P.pow = function(n) {
      var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
      if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER)
        throw Error(INVALID + "exponent");
      if (isneg)
        n = -n;
      for (; ; ) {
        if (n & 1)
          y = y.times(x);
        n >>= 1;
        if (!n)
          break;
        x = x.times(x);
      }
      return isneg ? one.div(y) : y;
    };
    P.round = function(dp, rm) {
      var Big2 = this.constructor;
      if (dp === UNDEFINED)
        dp = 0;
      else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
        throw Error(INVALID_DP);
      return round(new Big2(this), dp, rm === UNDEFINED ? Big2.RM : rm);
    };
    P.sqrt = function() {
      var r, c, t2, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2(0.5);
      if (!x.c[0])
        return new Big2(x);
      if (s < 0)
        throw Error(NAME + "No square root");
      s = Math.sqrt(x + "");
      if (s === 0 || s === 1 / 0) {
        c = x.c.join("");
        if (!(c.length + e & 1))
          c += "0";
        s = Math.sqrt(c);
        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
        r = new Big2((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
      } else {
        r = new Big2(s);
      }
      e = r.e + (Big2.DP += 4);
      do {
        t2 = r;
        r = half.times(t2.plus(x.div(t2)));
      } while (t2.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
      return round(r, Big2.DP -= 4, Big2.RM);
    };
    P.times = P.mul = function(y) {
      var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
      y.s = x.s == y.s ? 1 : -1;
      if (!xc[0] || !yc[0])
        return new Big2(y.s * 0);
      y.e = i + j;
      if (a < b) {
        c = xc;
        xc = yc;
        yc = c;
        j = a;
        a = b;
        b = j;
      }
      for (c = new Array(j = a + b); j--; )
        c[j] = 0;
      for (i = b; i--; ) {
        b = 0;
        for (j = a + i; j > i; ) {
          b = c[j] + yc[i] * xc[j - i - 1] + b;
          c[j--] = b % 10;
          b = b / 10 | 0;
        }
        c[j] = (c[j] + b) % 10;
      }
      if (b)
        ++y.e;
      else
        c.shift();
      for (i = c.length; !c[--i]; )
        c.pop();
      y.c = c;
      return y;
    };
    P.toExponential = function(dp) {
      return stringify(this, 1, dp, dp);
    };
    P.toFixed = function(dp) {
      return stringify(this, 2, dp, this.e + dp);
    };
    P.toPrecision = function(sd) {
      return stringify(this, 3, sd, sd - 1);
    };
    P.toString = function() {
      return stringify(this);
    };
    P.valueOf = P.toJSON = function() {
      return stringify(this, 4);
    };
    Big = _Big_();
    big_default = Big;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getHashDigest.js
var require_getHashDigest = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/getHashDigest.js"(exports2, module2) {
    "use strict";
    var baseEncodeTables = {
      26: "abcdefghijklmnopqrstuvwxyz",
      32: "123456789abcdefghjkmnpqrstuvwxyz",
      36: "0123456789abcdefghijklmnopqrstuvwxyz",
      49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
    };
    function encodeBufferToBase(buffer, base) {
      const encodeTable = baseEncodeTables[base];
      if (!encodeTable) {
        throw new Error("Unknown encoding base" + base);
      }
      const readLength = buffer.length;
      const Big2 = (init_big(), big_exports);
      Big2.RM = Big2.DP = 0;
      let b = new Big2(0);
      for (let i = readLength - 1; i >= 0; i--) {
        b = b.times(256).plus(buffer[i]);
      }
      let output = "";
      while (b.gt(0)) {
        output = encodeTable[b.mod(base)] + output;
        b = b.div(base);
      }
      Big2.DP = 20;
      Big2.RM = 1;
      return output;
    }
    function getHashDigest(buffer, hashType, digestType, maxLength) {
      hashType = hashType || "md5";
      maxLength = maxLength || 9999;
      const hash = require("crypto").createHash(hashType);
      hash.update(buffer);
      if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62" || digestType === "base64") {
        return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(0, maxLength);
      } else {
        return hash.digest(digestType || "hex").substr(0, maxLength);
      }
    }
    module2.exports = getHashDigest;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/emojis-list-npm-3.0.0-7faa48e6fd-ddaaa02542.zip/node_modules/emojis-list/index.js
var require_emojis_list = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/emojis-list-npm-3.0.0-7faa48e6fd-ddaaa02542.zip/node_modules/emojis-list/index.js"(exports2, module2) {
    module2.exports = [
      "\u{1F004}\uFE0F",
      "\u{1F0CF}",
      "\u{1F170}\uFE0F",
      "\u{1F171}\uFE0F",
      "\u{1F17E}\uFE0F",
      "\u{1F17F}\uFE0F",
      "\u{1F18E}",
      "\u{1F191}",
      "\u{1F192}",
      "\u{1F193}",
      "\u{1F194}",
      "\u{1F195}",
      "\u{1F196}",
      "\u{1F197}",
      "\u{1F198}",
      "\u{1F199}",
      "\u{1F19A}",
      "\u{1F1E6}\u{1F1E8}",
      "\u{1F1E6}\u{1F1E9}",
      "\u{1F1E6}\u{1F1EA}",
      "\u{1F1E6}\u{1F1EB}",
      "\u{1F1E6}\u{1F1EC}",
      "\u{1F1E6}\u{1F1EE}",
      "\u{1F1E6}\u{1F1F1}",
      "\u{1F1E6}\u{1F1F2}",
      "\u{1F1E6}\u{1F1F4}",
      "\u{1F1E6}\u{1F1F6}",
      "\u{1F1E6}\u{1F1F7}",
      "\u{1F1E6}\u{1F1F8}",
      "\u{1F1E6}\u{1F1F9}",
      "\u{1F1E6}\u{1F1FA}",
      "\u{1F1E6}\u{1F1FC}",
      "\u{1F1E6}\u{1F1FD}",
      "\u{1F1E6}\u{1F1FF}",
      "\u{1F1E6}",
      "\u{1F1E7}\u{1F1E6}",
      "\u{1F1E7}\u{1F1E7}",
      "\u{1F1E7}\u{1F1E9}",
      "\u{1F1E7}\u{1F1EA}",
      "\u{1F1E7}\u{1F1EB}",
      "\u{1F1E7}\u{1F1EC}",
      "\u{1F1E7}\u{1F1ED}",
      "\u{1F1E7}\u{1F1EE}",
      "\u{1F1E7}\u{1F1EF}",
      "\u{1F1E7}\u{1F1F1}",
      "\u{1F1E7}\u{1F1F2}",
      "\u{1F1E7}\u{1F1F3}",
      "\u{1F1E7}\u{1F1F4}",
      "\u{1F1E7}\u{1F1F6}",
      "\u{1F1E7}\u{1F1F7}",
      "\u{1F1E7}\u{1F1F8}",
      "\u{1F1E7}\u{1F1F9}",
      "\u{1F1E7}\u{1F1FB}",
      "\u{1F1E7}\u{1F1FC}",
      "\u{1F1E7}\u{1F1FE}",
      "\u{1F1E7}\u{1F1FF}",
      "\u{1F1E7}",
      "\u{1F1E8}\u{1F1E6}",
      "\u{1F1E8}\u{1F1E8}",
      "\u{1F1E8}\u{1F1E9}",
      "\u{1F1E8}\u{1F1EB}",
      "\u{1F1E8}\u{1F1EC}",
      "\u{1F1E8}\u{1F1ED}",
      "\u{1F1E8}\u{1F1EE}",
      "\u{1F1E8}\u{1F1F0}",
      "\u{1F1E8}\u{1F1F1}",
      "\u{1F1E8}\u{1F1F2}",
      "\u{1F1E8}\u{1F1F3}",
      "\u{1F1E8}\u{1F1F4}",
      "\u{1F1E8}\u{1F1F5}",
      "\u{1F1E8}\u{1F1F7}",
      "\u{1F1E8}\u{1F1FA}",
      "\u{1F1E8}\u{1F1FB}",
      "\u{1F1E8}\u{1F1FC}",
      "\u{1F1E8}\u{1F1FD}",
      "\u{1F1E8}\u{1F1FE}",
      "\u{1F1E8}\u{1F1FF}",
      "\u{1F1E8}",
      "\u{1F1E9}\u{1F1EA}",
      "\u{1F1E9}\u{1F1EC}",
      "\u{1F1E9}\u{1F1EF}",
      "\u{1F1E9}\u{1F1F0}",
      "\u{1F1E9}\u{1F1F2}",
      "\u{1F1E9}\u{1F1F4}",
      "\u{1F1E9}\u{1F1FF}",
      "\u{1F1E9}",
      "\u{1F1EA}\u{1F1E6}",
      "\u{1F1EA}\u{1F1E8}",
      "\u{1F1EA}\u{1F1EA}",
      "\u{1F1EA}\u{1F1EC}",
      "\u{1F1EA}\u{1F1ED}",
      "\u{1F1EA}\u{1F1F7}",
      "\u{1F1EA}\u{1F1F8}",
      "\u{1F1EA}\u{1F1F9}",
      "\u{1F1EA}\u{1F1FA}",
      "\u{1F1EA}",
      "\u{1F1EB}\u{1F1EE}",
      "\u{1F1EB}\u{1F1EF}",
      "\u{1F1EB}\u{1F1F0}",
      "\u{1F1EB}\u{1F1F2}",
      "\u{1F1EB}\u{1F1F4}",
      "\u{1F1EB}\u{1F1F7}",
      "\u{1F1EB}",
      "\u{1F1EC}\u{1F1E6}",
      "\u{1F1EC}\u{1F1E7}",
      "\u{1F1EC}\u{1F1E9}",
      "\u{1F1EC}\u{1F1EA}",
      "\u{1F1EC}\u{1F1EB}",
      "\u{1F1EC}\u{1F1EC}",
      "\u{1F1EC}\u{1F1ED}",
      "\u{1F1EC}\u{1F1EE}",
      "\u{1F1EC}\u{1F1F1}",
      "\u{1F1EC}\u{1F1F2}",
      "\u{1F1EC}\u{1F1F3}",
      "\u{1F1EC}\u{1F1F5}",
      "\u{1F1EC}\u{1F1F6}",
      "\u{1F1EC}\u{1F1F7}",
      "\u{1F1EC}\u{1F1F8}",
      "\u{1F1EC}\u{1F1F9}",
      "\u{1F1EC}\u{1F1FA}",
      "\u{1F1EC}\u{1F1FC}",
      "\u{1F1EC}\u{1F1FE}",
      "\u{1F1EC}",
      "\u{1F1ED}\u{1F1F0}",
      "\u{1F1ED}\u{1F1F2}",
      "\u{1F1ED}\u{1F1F3}",
      "\u{1F1ED}\u{1F1F7}",
      "\u{1F1ED}\u{1F1F9}",
      "\u{1F1ED}\u{1F1FA}",
      "\u{1F1ED}",
      "\u{1F1EE}\u{1F1E8}",
      "\u{1F1EE}\u{1F1E9}",
      "\u{1F1EE}\u{1F1EA}",
      "\u{1F1EE}\u{1F1F1}",
      "\u{1F1EE}\u{1F1F2}",
      "\u{1F1EE}\u{1F1F3}",
      "\u{1F1EE}\u{1F1F4}",
      "\u{1F1EE}\u{1F1F6}",
      "\u{1F1EE}\u{1F1F7}",
      "\u{1F1EE}\u{1F1F8}",
      "\u{1F1EE}\u{1F1F9}",
      "\u{1F1EE}",
      "\u{1F1EF}\u{1F1EA}",
      "\u{1F1EF}\u{1F1F2}",
      "\u{1F1EF}\u{1F1F4}",
      "\u{1F1EF}\u{1F1F5}",
      "\u{1F1EF}",
      "\u{1F1F0}\u{1F1EA}",
      "\u{1F1F0}\u{1F1EC}",
      "\u{1F1F0}\u{1F1ED}",
      "\u{1F1F0}\u{1F1EE}",
      "\u{1F1F0}\u{1F1F2}",
      "\u{1F1F0}\u{1F1F3}",
      "\u{1F1F0}\u{1F1F5}",
      "\u{1F1F0}\u{1F1F7}",
      "\u{1F1F0}\u{1F1FC}",
      "\u{1F1F0}\u{1F1FE}",
      "\u{1F1F0}\u{1F1FF}",
      "\u{1F1F0}",
      "\u{1F1F1}\u{1F1E6}",
      "\u{1F1F1}\u{1F1E7}",
      "\u{1F1F1}\u{1F1E8}",
      "\u{1F1F1}\u{1F1EE}",
      "\u{1F1F1}\u{1F1F0}",
      "\u{1F1F1}\u{1F1F7}",
      "\u{1F1F1}\u{1F1F8}",
      "\u{1F1F1}\u{1F1F9}",
      "\u{1F1F1}\u{1F1FA}",
      "\u{1F1F1}\u{1F1FB}",
      "\u{1F1F1}\u{1F1FE}",
      "\u{1F1F1}",
      "\u{1F1F2}\u{1F1E6}",
      "\u{1F1F2}\u{1F1E8}",
      "\u{1F1F2}\u{1F1E9}",
      "\u{1F1F2}\u{1F1EA}",
      "\u{1F1F2}\u{1F1EB}",
      "\u{1F1F2}\u{1F1EC}",
      "\u{1F1F2}\u{1F1ED}",
      "\u{1F1F2}\u{1F1F0}",
      "\u{1F1F2}\u{1F1F1}",
      "\u{1F1F2}\u{1F1F2}",
      "\u{1F1F2}\u{1F1F3}",
      "\u{1F1F2}\u{1F1F4}",
      "\u{1F1F2}\u{1F1F5}",
      "\u{1F1F2}\u{1F1F6}",
      "\u{1F1F2}\u{1F1F7}",
      "\u{1F1F2}\u{1F1F8}",
      "\u{1F1F2}\u{1F1F9}",
      "\u{1F1F2}\u{1F1FA}",
      "\u{1F1F2}\u{1F1FB}",
      "\u{1F1F2}\u{1F1FC}",
      "\u{1F1F2}\u{1F1FD}",
      "\u{1F1F2}\u{1F1FE}",
      "\u{1F1F2}\u{1F1FF}",
      "\u{1F1F2}",
      "\u{1F1F3}\u{1F1E6}",
      "\u{1F1F3}\u{1F1E8}",
      "\u{1F1F3}\u{1F1EA}",
      "\u{1F1F3}\u{1F1EB}",
      "\u{1F1F3}\u{1F1EC}",
      "\u{1F1F3}\u{1F1EE}",
      "\u{1F1F3}\u{1F1F1}",
      "\u{1F1F3}\u{1F1F4}",
      "\u{1F1F3}\u{1F1F5}",
      "\u{1F1F3}\u{1F1F7}",
      "\u{1F1F3}\u{1F1FA}",
      "\u{1F1F3}\u{1F1FF}",
      "\u{1F1F3}",
      "\u{1F1F4}\u{1F1F2}",
      "\u{1F1F4}",
      "\u{1F1F5}\u{1F1E6}",
      "\u{1F1F5}\u{1F1EA}",
      "\u{1F1F5}\u{1F1EB}",
      "\u{1F1F5}\u{1F1EC}",
      "\u{1F1F5}\u{1F1ED}",
      "\u{1F1F5}\u{1F1F0}",
      "\u{1F1F5}\u{1F1F1}",
      "\u{1F1F5}\u{1F1F2}",
      "\u{1F1F5}\u{1F1F3}",
      "\u{1F1F5}\u{1F1F7}",
      "\u{1F1F5}\u{1F1F8}",
      "\u{1F1F5}\u{1F1F9}",
      "\u{1F1F5}\u{1F1FC}",
      "\u{1F1F5}\u{1F1FE}",
      "\u{1F1F5}",
      "\u{1F1F6}\u{1F1E6}",
      "\u{1F1F6}",
      "\u{1F1F7}\u{1F1EA}",
      "\u{1F1F7}\u{1F1F4}",
      "\u{1F1F7}\u{1F1F8}",
      "\u{1F1F7}\u{1F1FA}",
      "\u{1F1F7}\u{1F1FC}",
      "\u{1F1F7}",
      "\u{1F1F8}\u{1F1E6}",
      "\u{1F1F8}\u{1F1E7}",
      "\u{1F1F8}\u{1F1E8}",
      "\u{1F1F8}\u{1F1E9}",
      "\u{1F1F8}\u{1F1EA}",
      "\u{1F1F8}\u{1F1EC}",
      "\u{1F1F8}\u{1F1ED}",
      "\u{1F1F8}\u{1F1EE}",
      "\u{1F1F8}\u{1F1EF}",
      "\u{1F1F8}\u{1F1F0}",
      "\u{1F1F8}\u{1F1F1}",
      "\u{1F1F8}\u{1F1F2}",
      "\u{1F1F8}\u{1F1F3}",
      "\u{1F1F8}\u{1F1F4}",
      "\u{1F1F8}\u{1F1F7}",
      "\u{1F1F8}\u{1F1F8}",
      "\u{1F1F8}\u{1F1F9}",
      "\u{1F1F8}\u{1F1FB}",
      "\u{1F1F8}\u{1F1FD}",
      "\u{1F1F8}\u{1F1FE}",
      "\u{1F1F8}\u{1F1FF}",
      "\u{1F1F8}",
      "\u{1F1F9}\u{1F1E6}",
      "\u{1F1F9}\u{1F1E8}",
      "\u{1F1F9}\u{1F1E9}",
      "\u{1F1F9}\u{1F1EB}",
      "\u{1F1F9}\u{1F1EC}",
      "\u{1F1F9}\u{1F1ED}",
      "\u{1F1F9}\u{1F1EF}",
      "\u{1F1F9}\u{1F1F0}",
      "\u{1F1F9}\u{1F1F1}",
      "\u{1F1F9}\u{1F1F2}",
      "\u{1F1F9}\u{1F1F3}",
      "\u{1F1F9}\u{1F1F4}",
      "\u{1F1F9}\u{1F1F7}",
      "\u{1F1F9}\u{1F1F9}",
      "\u{1F1F9}\u{1F1FB}",
      "\u{1F1F9}\u{1F1FC}",
      "\u{1F1F9}\u{1F1FF}",
      "\u{1F1F9}",
      "\u{1F1FA}\u{1F1E6}",
      "\u{1F1FA}\u{1F1EC}",
      "\u{1F1FA}\u{1F1F2}",
      "\u{1F1FA}\u{1F1F3}",
      "\u{1F1FA}\u{1F1F8}",
      "\u{1F1FA}\u{1F1FE}",
      "\u{1F1FA}\u{1F1FF}",
      "\u{1F1FA}",
      "\u{1F1FB}\u{1F1E6}",
      "\u{1F1FB}\u{1F1E8}",
      "\u{1F1FB}\u{1F1EA}",
      "\u{1F1FB}\u{1F1EC}",
      "\u{1F1FB}\u{1F1EE}",
      "\u{1F1FB}\u{1F1F3}",
      "\u{1F1FB}\u{1F1FA}",
      "\u{1F1FB}",
      "\u{1F1FC}\u{1F1EB}",
      "\u{1F1FC}\u{1F1F8}",
      "\u{1F1FC}",
      "\u{1F1FD}\u{1F1F0}",
      "\u{1F1FD}",
      "\u{1F1FE}\u{1F1EA}",
      "\u{1F1FE}\u{1F1F9}",
      "\u{1F1FE}",
      "\u{1F1FF}\u{1F1E6}",
      "\u{1F1FF}\u{1F1F2}",
      "\u{1F1FF}\u{1F1FC}",
      "\u{1F1FF}",
      "\u{1F201}",
      "\u{1F202}\uFE0F",
      "\u{1F21A}\uFE0F",
      "\u{1F22F}\uFE0F",
      "\u{1F232}",
      "\u{1F233}",
      "\u{1F234}",
      "\u{1F235}",
      "\u{1F236}",
      "\u{1F237}\uFE0F",
      "\u{1F238}",
      "\u{1F239}",
      "\u{1F23A}",
      "\u{1F250}",
      "\u{1F251}",
      "\u{1F300}",
      "\u{1F301}",
      "\u{1F302}",
      "\u{1F303}",
      "\u{1F304}",
      "\u{1F305}",
      "\u{1F306}",
      "\u{1F307}",
      "\u{1F308}",
      "\u{1F309}",
      "\u{1F30A}",
      "\u{1F30B}",
      "\u{1F30C}",
      "\u{1F30D}",
      "\u{1F30E}",
      "\u{1F30F}",
      "\u{1F310}",
      "\u{1F311}",
      "\u{1F312}",
      "\u{1F313}",
      "\u{1F314}",
      "\u{1F315}",
      "\u{1F316}",
      "\u{1F317}",
      "\u{1F318}",
      "\u{1F319}",
      "\u{1F31A}",
      "\u{1F31B}",
      "\u{1F31C}",
      "\u{1F31D}",
      "\u{1F31E}",
      "\u{1F31F}",
      "\u{1F320}",
      "\u{1F321}\uFE0F",
      "\u{1F324}\uFE0F",
      "\u{1F325}\uFE0F",
      "\u{1F326}\uFE0F",
      "\u{1F327}\uFE0F",
      "\u{1F328}\uFE0F",
      "\u{1F329}\uFE0F",
      "\u{1F32A}\uFE0F",
      "\u{1F32B}\uFE0F",
      "\u{1F32C}\uFE0F",
      "\u{1F32D}",
      "\u{1F32E}",
      "\u{1F32F}",
      "\u{1F330}",
      "\u{1F331}",
      "\u{1F332}",
      "\u{1F333}",
      "\u{1F334}",
      "\u{1F335}",
      "\u{1F336}\uFE0F",
      "\u{1F337}",
      "\u{1F338}",
      "\u{1F339}",
      "\u{1F33A}",
      "\u{1F33B}",
      "\u{1F33C}",
      "\u{1F33D}",
      "\u{1F33E}",
      "\u{1F33F}",
      "\u{1F340}",
      "\u{1F341}",
      "\u{1F342}",
      "\u{1F343}",
      "\u{1F344}",
      "\u{1F345}",
      "\u{1F346}",
      "\u{1F347}",
      "\u{1F348}",
      "\u{1F349}",
      "\u{1F34A}",
      "\u{1F34B}",
      "\u{1F34C}",
      "\u{1F34D}",
      "\u{1F34E}",
      "\u{1F34F}",
      "\u{1F350}",
      "\u{1F351}",
      "\u{1F352}",
      "\u{1F353}",
      "\u{1F354}",
      "\u{1F355}",
      "\u{1F356}",
      "\u{1F357}",
      "\u{1F358}",
      "\u{1F359}",
      "\u{1F35A}",
      "\u{1F35B}",
      "\u{1F35C}",
      "\u{1F35D}",
      "\u{1F35E}",
      "\u{1F35F}",
      "\u{1F360}",
      "\u{1F361}",
      "\u{1F362}",
      "\u{1F363}",
      "\u{1F364}",
      "\u{1F365}",
      "\u{1F366}",
      "\u{1F367}",
      "\u{1F368}",
      "\u{1F369}",
      "\u{1F36A}",
      "\u{1F36B}",
      "\u{1F36C}",
      "\u{1F36D}",
      "\u{1F36E}",
      "\u{1F36F}",
      "\u{1F370}",
      "\u{1F371}",
      "\u{1F372}",
      "\u{1F373}",
      "\u{1F374}",
      "\u{1F375}",
      "\u{1F376}",
      "\u{1F377}",
      "\u{1F378}",
      "\u{1F379}",
      "\u{1F37A}",
      "\u{1F37B}",
      "\u{1F37C}",
      "\u{1F37D}\uFE0F",
      "\u{1F37E}",
      "\u{1F37F}",
      "\u{1F380}",
      "\u{1F381}",
      "\u{1F382}",
      "\u{1F383}",
      "\u{1F384}",
      "\u{1F385}\u{1F3FB}",
      "\u{1F385}\u{1F3FC}",
      "\u{1F385}\u{1F3FD}",
      "\u{1F385}\u{1F3FE}",
      "\u{1F385}\u{1F3FF}",
      "\u{1F385}",
      "\u{1F386}",
      "\u{1F387}",
      "\u{1F388}",
      "\u{1F389}",
      "\u{1F38A}",
      "\u{1F38B}",
      "\u{1F38C}",
      "\u{1F38D}",
      "\u{1F38E}",
      "\u{1F38F}",
      "\u{1F390}",
      "\u{1F391}",
      "\u{1F392}",
      "\u{1F393}",
      "\u{1F396}\uFE0F",
      "\u{1F397}\uFE0F",
      "\u{1F399}\uFE0F",
      "\u{1F39A}\uFE0F",
      "\u{1F39B}\uFE0F",
      "\u{1F39E}\uFE0F",
      "\u{1F39F}\uFE0F",
      "\u{1F3A0}",
      "\u{1F3A1}",
      "\u{1F3A2}",
      "\u{1F3A3}",
      "\u{1F3A4}",
      "\u{1F3A5}",
      "\u{1F3A6}",
      "\u{1F3A7}",
      "\u{1F3A8}",
      "\u{1F3A9}",
      "\u{1F3AA}",
      "\u{1F3AB}",
      "\u{1F3AC}",
      "\u{1F3AD}",
      "\u{1F3AE}",
      "\u{1F3AF}",
      "\u{1F3B0}",
      "\u{1F3B1}",
      "\u{1F3B2}",
      "\u{1F3B3}",
      "\u{1F3B4}",
      "\u{1F3B5}",
      "\u{1F3B6}",
      "\u{1F3B7}",
      "\u{1F3B8}",
      "\u{1F3B9}",
      "\u{1F3BA}",
      "\u{1F3BB}",
      "\u{1F3BC}",
      "\u{1F3BD}",
      "\u{1F3BE}",
      "\u{1F3BF}",
      "\u{1F3C0}",
      "\u{1F3C1}",
      "\u{1F3C2}\u{1F3FB}",
      "\u{1F3C2}\u{1F3FC}",
      "\u{1F3C2}\u{1F3FD}",
      "\u{1F3C2}\u{1F3FE}",
      "\u{1F3C2}\u{1F3FF}",
      "\u{1F3C2}",
      "\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FB}",
      "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FC}",
      "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FD}",
      "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FE}",
      "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FF}",
      "\u{1F3C3}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u200D\u2642\uFE0F",
      "\u{1F3C3}",
      "\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FB}",
      "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FC}",
      "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FD}",
      "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FE}",
      "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FF}",
      "\u{1F3C4}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u200D\u2642\uFE0F",
      "\u{1F3C4}",
      "\u{1F3C5}",
      "\u{1F3C6}",
      "\u{1F3C7}\u{1F3FB}",
      "\u{1F3C7}\u{1F3FC}",
      "\u{1F3C7}\u{1F3FD}",
      "\u{1F3C7}\u{1F3FE}",
      "\u{1F3C7}\u{1F3FF}",
      "\u{1F3C7}",
      "\u{1F3C8}",
      "\u{1F3C9}",
      "\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FB}",
      "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FC}",
      "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FD}",
      "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FE}",
      "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FF}",
      "\u{1F3CA}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u200D\u2642\uFE0F",
      "\u{1F3CA}",
      "\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FB}",
      "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FC}",
      "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FD}",
      "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FE}",
      "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FF}",
      "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F3CB}\uFE0F",
      "\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FB}",
      "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FC}",
      "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FD}",
      "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FE}",
      "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FF}",
      "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F3CC}\uFE0F",
      "\u{1F3CD}\uFE0F",
      "\u{1F3CE}\uFE0F",
      "\u{1F3CF}",
      "\u{1F3D0}",
      "\u{1F3D1}",
      "\u{1F3D2}",
      "\u{1F3D3}",
      "\u{1F3D4}\uFE0F",
      "\u{1F3D5}\uFE0F",
      "\u{1F3D6}\uFE0F",
      "\u{1F3D7}\uFE0F",
      "\u{1F3D8}\uFE0F",
      "\u{1F3D9}\uFE0F",
      "\u{1F3DA}\uFE0F",
      "\u{1F3DB}\uFE0F",
      "\u{1F3DC}\uFE0F",
      "\u{1F3DD}\uFE0F",
      "\u{1F3DE}\uFE0F",
      "\u{1F3DF}\uFE0F",
      "\u{1F3E0}",
      "\u{1F3E1}",
      "\u{1F3E2}",
      "\u{1F3E3}",
      "\u{1F3E4}",
      "\u{1F3E5}",
      "\u{1F3E6}",
      "\u{1F3E7}",
      "\u{1F3E8}",
      "\u{1F3E9}",
      "\u{1F3EA}",
      "\u{1F3EB}",
      "\u{1F3EC}",
      "\u{1F3ED}",
      "\u{1F3EE}",
      "\u{1F3EF}",
      "\u{1F3F0}",
      "\u{1F3F3}\uFE0F\u200D\u{1F308}",
      "\u{1F3F3}\uFE0F",
      "\u{1F3F4}\u200D\u2620\uFE0F",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}",
      "\u{1F3F4}",
      "\u{1F3F5}\uFE0F",
      "\u{1F3F7}\uFE0F",
      "\u{1F3F8}",
      "\u{1F3F9}",
      "\u{1F3FA}",
      "\u{1F3FB}",
      "\u{1F3FC}",
      "\u{1F3FD}",
      "\u{1F3FE}",
      "\u{1F3FF}",
      "\u{1F400}",
      "\u{1F401}",
      "\u{1F402}",
      "\u{1F403}",
      "\u{1F404}",
      "\u{1F405}",
      "\u{1F406}",
      "\u{1F407}",
      "\u{1F408}",
      "\u{1F409}",
      "\u{1F40A}",
      "\u{1F40B}",
      "\u{1F40C}",
      "\u{1F40D}",
      "\u{1F40E}",
      "\u{1F40F}",
      "\u{1F410}",
      "\u{1F411}",
      "\u{1F412}",
      "\u{1F413}",
      "\u{1F414}",
      "\u{1F415}\u200D\u{1F9BA}",
      "\u{1F415}",
      "\u{1F416}",
      "\u{1F417}",
      "\u{1F418}",
      "\u{1F419}",
      "\u{1F41A}",
      "\u{1F41B}",
      "\u{1F41C}",
      "\u{1F41D}",
      "\u{1F41E}",
      "\u{1F41F}",
      "\u{1F420}",
      "\u{1F421}",
      "\u{1F422}",
      "\u{1F423}",
      "\u{1F424}",
      "\u{1F425}",
      "\u{1F426}",
      "\u{1F427}",
      "\u{1F428}",
      "\u{1F429}",
      "\u{1F42A}",
      "\u{1F42B}",
      "\u{1F42C}",
      "\u{1F42D}",
      "\u{1F42E}",
      "\u{1F42F}",
      "\u{1F430}",
      "\u{1F431}",
      "\u{1F432}",
      "\u{1F433}",
      "\u{1F434}",
      "\u{1F435}",
      "\u{1F436}",
      "\u{1F437}",
      "\u{1F438}",
      "\u{1F439}",
      "\u{1F43A}",
      "\u{1F43B}",
      "\u{1F43C}",
      "\u{1F43D}",
      "\u{1F43E}",
      "\u{1F43F}\uFE0F",
      "\u{1F440}",
      "\u{1F441}\u200D\u{1F5E8}",
      "\u{1F441}\uFE0F",
      "\u{1F442}\u{1F3FB}",
      "\u{1F442}\u{1F3FC}",
      "\u{1F442}\u{1F3FD}",
      "\u{1F442}\u{1F3FE}",
      "\u{1F442}\u{1F3FF}",
      "\u{1F442}",
      "\u{1F443}\u{1F3FB}",
      "\u{1F443}\u{1F3FC}",
      "\u{1F443}\u{1F3FD}",
      "\u{1F443}\u{1F3FE}",
      "\u{1F443}\u{1F3FF}",
      "\u{1F443}",
      "\u{1F444}",
      "\u{1F445}",
      "\u{1F446}\u{1F3FB}",
      "\u{1F446}\u{1F3FC}",
      "\u{1F446}\u{1F3FD}",
      "\u{1F446}\u{1F3FE}",
      "\u{1F446}\u{1F3FF}",
      "\u{1F446}",
      "\u{1F447}\u{1F3FB}",
      "\u{1F447}\u{1F3FC}",
      "\u{1F447}\u{1F3FD}",
      "\u{1F447}\u{1F3FE}",
      "\u{1F447}\u{1F3FF}",
      "\u{1F447}",
      "\u{1F448}\u{1F3FB}",
      "\u{1F448}\u{1F3FC}",
      "\u{1F448}\u{1F3FD}",
      "\u{1F448}\u{1F3FE}",
      "\u{1F448}\u{1F3FF}",
      "\u{1F448}",
      "\u{1F449}\u{1F3FB}",
      "\u{1F449}\u{1F3FC}",
      "\u{1F449}\u{1F3FD}",
      "\u{1F449}\u{1F3FE}",
      "\u{1F449}\u{1F3FF}",
      "\u{1F449}",
      "\u{1F44A}\u{1F3FB}",
      "\u{1F44A}\u{1F3FC}",
      "\u{1F44A}\u{1F3FD}",
      "\u{1F44A}\u{1F3FE}",
      "\u{1F44A}\u{1F3FF}",
      "\u{1F44A}",
      "\u{1F44B}\u{1F3FB}",
      "\u{1F44B}\u{1F3FC}",
      "\u{1F44B}\u{1F3FD}",
      "\u{1F44B}\u{1F3FE}",
      "\u{1F44B}\u{1F3FF}",
      "\u{1F44B}",
      "\u{1F44C}\u{1F3FB}",
      "\u{1F44C}\u{1F3FC}",
      "\u{1F44C}\u{1F3FD}",
      "\u{1F44C}\u{1F3FE}",
      "\u{1F44C}\u{1F3FF}",
      "\u{1F44C}",
      "\u{1F44D}\u{1F3FB}",
      "\u{1F44D}\u{1F3FC}",
      "\u{1F44D}\u{1F3FD}",
      "\u{1F44D}\u{1F3FE}",
      "\u{1F44D}\u{1F3FF}",
      "\u{1F44D}",
      "\u{1F44E}\u{1F3FB}",
      "\u{1F44E}\u{1F3FC}",
      "\u{1F44E}\u{1F3FD}",
      "\u{1F44E}\u{1F3FE}",
      "\u{1F44E}\u{1F3FF}",
      "\u{1F44E}",
      "\u{1F44F}\u{1F3FB}",
      "\u{1F44F}\u{1F3FC}",
      "\u{1F44F}\u{1F3FD}",
      "\u{1F44F}\u{1F3FE}",
      "\u{1F44F}\u{1F3FF}",
      "\u{1F44F}",
      "\u{1F450}\u{1F3FB}",
      "\u{1F450}\u{1F3FC}",
      "\u{1F450}\u{1F3FD}",
      "\u{1F450}\u{1F3FE}",
      "\u{1F450}\u{1F3FF}",
      "\u{1F450}",
      "\u{1F451}",
      "\u{1F452}",
      "\u{1F453}",
      "\u{1F454}",
      "\u{1F455}",
      "\u{1F456}",
      "\u{1F457}",
      "\u{1F458}",
      "\u{1F459}",
      "\u{1F45A}",
      "\u{1F45B}",
      "\u{1F45C}",
      "\u{1F45D}",
      "\u{1F45E}",
      "\u{1F45F}",
      "\u{1F460}",
      "\u{1F461}",
      "\u{1F462}",
      "\u{1F463}",
      "\u{1F464}",
      "\u{1F465}",
      "\u{1F466}\u{1F3FB}",
      "\u{1F466}\u{1F3FC}",
      "\u{1F466}\u{1F3FD}",
      "\u{1F466}\u{1F3FE}",
      "\u{1F466}\u{1F3FF}",
      "\u{1F466}",
      "\u{1F467}\u{1F3FB}",
      "\u{1F467}\u{1F3FC}",
      "\u{1F467}\u{1F3FD}",
      "\u{1F467}\u{1F3FE}",
      "\u{1F467}\u{1F3FF}",
      "\u{1F467}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FE}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FF}",
      "\u{1F468}\u200D\u{1F33E}",
      "\u{1F468}\u200D\u{1F373}",
      "\u{1F468}\u200D\u{1F393}",
      "\u{1F468}\u200D\u{1F3A4}",
      "\u{1F468}\u200D\u{1F3A8}",
      "\u{1F468}\u200D\u{1F3EB}",
      "\u{1F468}\u200D\u{1F3ED}",
      "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F4BB}",
      "\u{1F468}\u200D\u{1F4BC}",
      "\u{1F468}\u200D\u{1F527}",
      "\u{1F468}\u200D\u{1F52C}",
      "\u{1F468}\u200D\u{1F680}",
      "\u{1F468}\u200D\u{1F692}",
      "\u{1F468}\u200D\u{1F9AF}",
      "\u{1F468}\u200D\u{1F9B0}",
      "\u{1F468}\u200D\u{1F9B1}",
      "\u{1F468}\u200D\u{1F9B2}",
      "\u{1F468}\u200D\u{1F9B3}",
      "\u{1F468}\u200D\u{1F9BC}",
      "\u{1F468}\u200D\u{1F9BD}",
      "\u{1F468}\u200D\u2695\uFE0F",
      "\u{1F468}\u200D\u2696\uFE0F",
      "\u{1F468}\u200D\u2708\uFE0F",
      "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "\u{1F468}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FF}",
      "\u{1F469}\u200D\u{1F33E}",
      "\u{1F469}\u200D\u{1F373}",
      "\u{1F469}\u200D\u{1F393}",
      "\u{1F469}\u200D\u{1F3A4}",
      "\u{1F469}\u200D\u{1F3A8}",
      "\u{1F469}\u200D\u{1F3EB}",
      "\u{1F469}\u200D\u{1F3ED}",
      "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F4BB}",
      "\u{1F469}\u200D\u{1F4BC}",
      "\u{1F469}\u200D\u{1F527}",
      "\u{1F469}\u200D\u{1F52C}",
      "\u{1F469}\u200D\u{1F680}",
      "\u{1F469}\u200D\u{1F692}",
      "\u{1F469}\u200D\u{1F9AF}",
      "\u{1F469}\u200D\u{1F9B0}",
      "\u{1F469}\u200D\u{1F9B1}",
      "\u{1F469}\u200D\u{1F9B2}",
      "\u{1F469}\u200D\u{1F9B3}",
      "\u{1F469}\u200D\u{1F9BC}",
      "\u{1F469}\u200D\u{1F9BD}",
      "\u{1F469}\u200D\u2695\uFE0F",
      "\u{1F469}\u200D\u2696\uFE0F",
      "\u{1F469}\u200D\u2708\uFE0F",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
      "\u{1F469}",
      "\u{1F46A}",
      "\u{1F46B}\u{1F3FB}",
      "\u{1F46B}\u{1F3FC}",
      "\u{1F46B}\u{1F3FD}",
      "\u{1F46B}\u{1F3FE}",
      "\u{1F46B}\u{1F3FF}",
      "\u{1F46B}",
      "\u{1F46C}\u{1F3FB}",
      "\u{1F46C}\u{1F3FC}",
      "\u{1F46C}\u{1F3FD}",
      "\u{1F46C}\u{1F3FE}",
      "\u{1F46C}\u{1F3FF}",
      "\u{1F46C}",
      "\u{1F46D}\u{1F3FB}",
      "\u{1F46D}\u{1F3FC}",
      "\u{1F46D}\u{1F3FD}",
      "\u{1F46D}\u{1F3FE}",
      "\u{1F46D}\u{1F3FF}",
      "\u{1F46D}",
      "\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FB}",
      "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FC}",
      "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FD}",
      "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FE}",
      "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FF}",
      "\u{1F46E}\u200D\u2640\uFE0F",
      "\u{1F46E}\u200D\u2642\uFE0F",
      "\u{1F46E}",
      "\u{1F46F}\u200D\u2640\uFE0F",
      "\u{1F46F}\u200D\u2642\uFE0F",
      "\u{1F46F}",
      "\u{1F470}\u{1F3FB}",
      "\u{1F470}\u{1F3FC}",
      "\u{1F470}\u{1F3FD}",
      "\u{1F470}\u{1F3FE}",
      "\u{1F470}\u{1F3FF}",
      "\u{1F470}",
      "\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FB}",
      "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FC}",
      "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FD}",
      "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FE}",
      "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FF}",
      "\u{1F471}\u200D\u2640\uFE0F",
      "\u{1F471}\u200D\u2642\uFE0F",
      "\u{1F471}",
      "\u{1F472}\u{1F3FB}",
      "\u{1F472}\u{1F3FC}",
      "\u{1F472}\u{1F3FD}",
      "\u{1F472}\u{1F3FE}",
      "\u{1F472}\u{1F3FF}",
      "\u{1F472}",
      "\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FB}",
      "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FC}",
      "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FD}",
      "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FE}",
      "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FF}",
      "\u{1F473}\u200D\u2640\uFE0F",
      "\u{1F473}\u200D\u2642\uFE0F",
      "\u{1F473}",
      "\u{1F474}\u{1F3FB}",
      "\u{1F474}\u{1F3FC}",
      "\u{1F474}\u{1F3FD}",
      "\u{1F474}\u{1F3FE}",
      "\u{1F474}\u{1F3FF}",
      "\u{1F474}",
      "\u{1F475}\u{1F3FB}",
      "\u{1F475}\u{1F3FC}",
      "\u{1F475}\u{1F3FD}",
      "\u{1F475}\u{1F3FE}",
      "\u{1F475}\u{1F3FF}",
      "\u{1F475}",
      "\u{1F476}\u{1F3FB}",
      "\u{1F476}\u{1F3FC}",
      "\u{1F476}\u{1F3FD}",
      "\u{1F476}\u{1F3FE}",
      "\u{1F476}\u{1F3FF}",
      "\u{1F476}",
      "\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FB}",
      "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FC}",
      "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FD}",
      "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FE}",
      "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FF}",
      "\u{1F477}\u200D\u2640\uFE0F",
      "\u{1F477}\u200D\u2642\uFE0F",
      "\u{1F477}",
      "\u{1F478}\u{1F3FB}",
      "\u{1F478}\u{1F3FC}",
      "\u{1F478}\u{1F3FD}",
      "\u{1F478}\u{1F3FE}",
      "\u{1F478}\u{1F3FF}",
      "\u{1F478}",
      "\u{1F479}",
      "\u{1F47A}",
      "\u{1F47B}",
      "\u{1F47C}\u{1F3FB}",
      "\u{1F47C}\u{1F3FC}",
      "\u{1F47C}\u{1F3FD}",
      "\u{1F47C}\u{1F3FE}",
      "\u{1F47C}\u{1F3FF}",
      "\u{1F47C}",
      "\u{1F47D}",
      "\u{1F47E}",
      "\u{1F47F}",
      "\u{1F480}",
      "\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FB}",
      "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FC}",
      "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FD}",
      "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FE}",
      "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FF}",
      "\u{1F481}\u200D\u2640\uFE0F",
      "\u{1F481}\u200D\u2642\uFE0F",
      "\u{1F481}",
      "\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FB}",
      "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FC}",
      "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FD}",
      "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FE}",
      "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FF}",
      "\u{1F482}\u200D\u2640\uFE0F",
      "\u{1F482}\u200D\u2642\uFE0F",
      "\u{1F482}",
      "\u{1F483}\u{1F3FB}",
      "\u{1F483}\u{1F3FC}",
      "\u{1F483}\u{1F3FD}",
      "\u{1F483}\u{1F3FE}",
      "\u{1F483}\u{1F3FF}",
      "\u{1F483}",
      "\u{1F484}",
      "\u{1F485}\u{1F3FB}",
      "\u{1F485}\u{1F3FC}",
      "\u{1F485}\u{1F3FD}",
      "\u{1F485}\u{1F3FE}",
      "\u{1F485}\u{1F3FF}",
      "\u{1F485}",
      "\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FB}",
      "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FC}",
      "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FD}",
      "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FE}",
      "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FF}",
      "\u{1F486}\u200D\u2640\uFE0F",
      "\u{1F486}\u200D\u2642\uFE0F",
      "\u{1F486}",
      "\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FB}",
      "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FC}",
      "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FD}",
      "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FE}",
      "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FF}",
      "\u{1F487}\u200D\u2640\uFE0F",
      "\u{1F487}\u200D\u2642\uFE0F",
      "\u{1F487}",
      "\u{1F488}",
      "\u{1F489}",
      "\u{1F48A}",
      "\u{1F48B}",
      "\u{1F48C}",
      "\u{1F48D}",
      "\u{1F48E}",
      "\u{1F48F}",
      "\u{1F490}",
      "\u{1F491}",
      "\u{1F492}",
      "\u{1F493}",
      "\u{1F494}",
      "\u{1F495}",
      "\u{1F496}",
      "\u{1F497}",
      "\u{1F498}",
      "\u{1F499}",
      "\u{1F49A}",
      "\u{1F49B}",
      "\u{1F49C}",
      "\u{1F49D}",
      "\u{1F49E}",
      "\u{1F49F}",
      "\u{1F4A0}",
      "\u{1F4A1}",
      "\u{1F4A2}",
      "\u{1F4A3}",
      "\u{1F4A4}",
      "\u{1F4A5}",
      "\u{1F4A6}",
      "\u{1F4A7}",
      "\u{1F4A8}",
      "\u{1F4A9}",
      "\u{1F4AA}\u{1F3FB}",
      "\u{1F4AA}\u{1F3FC}",
      "\u{1F4AA}\u{1F3FD}",
      "\u{1F4AA}\u{1F3FE}",
      "\u{1F4AA}\u{1F3FF}",
      "\u{1F4AA}",
      "\u{1F4AB}",
      "\u{1F4AC}",
      "\u{1F4AD}",
      "\u{1F4AE}",
      "\u{1F4AF}",
      "\u{1F4B0}",
      "\u{1F4B1}",
      "\u{1F4B2}",
      "\u{1F4B3}",
      "\u{1F4B4}",
      "\u{1F4B5}",
      "\u{1F4B6}",
      "\u{1F4B7}",
      "\u{1F4B8}",
      "\u{1F4B9}",
      "\u{1F4BA}",
      "\u{1F4BB}",
      "\u{1F4BC}",
      "\u{1F4BD}",
      "\u{1F4BE}",
      "\u{1F4BF}",
      "\u{1F4C0}",
      "\u{1F4C1}",
      "\u{1F4C2}",
      "\u{1F4C3}",
      "\u{1F4C4}",
      "\u{1F4C5}",
      "\u{1F4C6}",
      "\u{1F4C7}",
      "\u{1F4C8}",
      "\u{1F4C9}",
      "\u{1F4CA}",
      "\u{1F4CB}",
      "\u{1F4CC}",
      "\u{1F4CD}",
      "\u{1F4CE}",
      "\u{1F4CF}",
      "\u{1F4D0}",
      "\u{1F4D1}",
      "\u{1F4D2}",
      "\u{1F4D3}",
      "\u{1F4D4}",
      "\u{1F4D5}",
      "\u{1F4D6}",
      "\u{1F4D7}",
      "\u{1F4D8}",
      "\u{1F4D9}",
      "\u{1F4DA}",
      "\u{1F4DB}",
      "\u{1F4DC}",
      "\u{1F4DD}",
      "\u{1F4DE}",
      "\u{1F4DF}",
      "\u{1F4E0}",
      "\u{1F4E1}",
      "\u{1F4E2}",
      "\u{1F4E3}",
      "\u{1F4E4}",
      "\u{1F4E5}",
      "\u{1F4E6}",
      "\u{1F4E7}",
      "\u{1F4E8}",
      "\u{1F4E9}",
      "\u{1F4EA}",
      "\u{1F4EB}",
      "\u{1F4EC}",
      "\u{1F4ED}",
      "\u{1F4EE}",
      "\u{1F4EF}",
      "\u{1F4F0}",
      "\u{1F4F1}",
      "\u{1F4F2}",
      "\u{1F4F3}",
      "\u{1F4F4}",
      "\u{1F4F5}",
      "\u{1F4F6}",
      "\u{1F4F7}",
      "\u{1F4F8}",
      "\u{1F4F9}",
      "\u{1F4FA}",
      "\u{1F4FB}",
      "\u{1F4FC}",
      "\u{1F4FD}\uFE0F",
      "\u{1F4FF}",
      "\u{1F500}",
      "\u{1F501}",
      "\u{1F502}",
      "\u{1F503}",
      "\u{1F504}",
      "\u{1F505}",
      "\u{1F506}",
      "\u{1F507}",
      "\u{1F508}",
      "\u{1F509}",
      "\u{1F50A}",
      "\u{1F50B}",
      "\u{1F50C}",
      "\u{1F50D}",
      "\u{1F50E}",
      "\u{1F50F}",
      "\u{1F510}",
      "\u{1F511}",
      "\u{1F512}",
      "\u{1F513}",
      "\u{1F514}",
      "\u{1F515}",
      "\u{1F516}",
      "\u{1F517}",
      "\u{1F518}",
      "\u{1F519}",
      "\u{1F51A}",
      "\u{1F51B}",
      "\u{1F51C}",
      "\u{1F51D}",
      "\u{1F51E}",
      "\u{1F51F}",
      "\u{1F520}",
      "\u{1F521}",
      "\u{1F522}",
      "\u{1F523}",
      "\u{1F524}",
      "\u{1F525}",
      "\u{1F526}",
      "\u{1F527}",
      "\u{1F528}",
      "\u{1F529}",
      "\u{1F52A}",
      "\u{1F52B}",
      "\u{1F52C}",
      "\u{1F52D}",
      "\u{1F52E}",
      "\u{1F52F}",
      "\u{1F530}",
      "\u{1F531}",
      "\u{1F532}",
      "\u{1F533}",
      "\u{1F534}",
      "\u{1F535}",
      "\u{1F536}",
      "\u{1F537}",
      "\u{1F538}",
      "\u{1F539}",
      "\u{1F53A}",
      "\u{1F53B}",
      "\u{1F53C}",
      "\u{1F53D}",
      "\u{1F549}\uFE0F",
      "\u{1F54A}\uFE0F",
      "\u{1F54B}",
      "\u{1F54C}",
      "\u{1F54D}",
      "\u{1F54E}",
      "\u{1F550}",
      "\u{1F551}",
      "\u{1F552}",
      "\u{1F553}",
      "\u{1F554}",
      "\u{1F555}",
      "\u{1F556}",
      "\u{1F557}",
      "\u{1F558}",
      "\u{1F559}",
      "\u{1F55A}",
      "\u{1F55B}",
      "\u{1F55C}",
      "\u{1F55D}",
      "\u{1F55E}",
      "\u{1F55F}",
      "\u{1F560}",
      "\u{1F561}",
      "\u{1F562}",
      "\u{1F563}",
      "\u{1F564}",
      "\u{1F565}",
      "\u{1F566}",
      "\u{1F567}",
      "\u{1F56F}\uFE0F",
      "\u{1F570}\uFE0F",
      "\u{1F573}\uFE0F",
      "\u{1F574}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FB}",
      "\u{1F574}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FC}",
      "\u{1F574}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FD}",
      "\u{1F574}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FE}",
      "\u{1F574}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FF}",
      "\u{1F574}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F574}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F574}\uFE0F",
      "\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FB}",
      "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FC}",
      "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FD}",
      "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FE}",
      "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FF}",
      "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F575}\uFE0F",
      "\u{1F576}\uFE0F",
      "\u{1F577}\uFE0F",
      "\u{1F578}\uFE0F",
      "\u{1F579}\uFE0F",
      "\u{1F57A}\u{1F3FB}",
      "\u{1F57A}\u{1F3FC}",
      "\u{1F57A}\u{1F3FD}",
      "\u{1F57A}\u{1F3FE}",
      "\u{1F57A}\u{1F3FF}",
      "\u{1F57A}",
      "\u{1F587}\uFE0F",
      "\u{1F58A}\uFE0F",
      "\u{1F58B}\uFE0F",
      "\u{1F58C}\uFE0F",
      "\u{1F58D}\uFE0F",
      "\u{1F590}\u{1F3FB}",
      "\u{1F590}\u{1F3FC}",
      "\u{1F590}\u{1F3FD}",
      "\u{1F590}\u{1F3FE}",
      "\u{1F590}\u{1F3FF}",
      "\u{1F590}\uFE0F",
      "\u{1F595}\u{1F3FB}",
      "\u{1F595}\u{1F3FC}",
      "\u{1F595}\u{1F3FD}",
      "\u{1F595}\u{1F3FE}",
      "\u{1F595}\u{1F3FF}",
      "\u{1F595}",
      "\u{1F596}\u{1F3FB}",
      "\u{1F596}\u{1F3FC}",
      "\u{1F596}\u{1F3FD}",
      "\u{1F596}\u{1F3FE}",
      "\u{1F596}\u{1F3FF}",
      "\u{1F596}",
      "\u{1F5A4}",
      "\u{1F5A5}\uFE0F",
      "\u{1F5A8}\uFE0F",
      "\u{1F5B1}\uFE0F",
      "\u{1F5B2}\uFE0F",
      "\u{1F5BC}\uFE0F",
      "\u{1F5C2}\uFE0F",
      "\u{1F5C3}\uFE0F",
      "\u{1F5C4}\uFE0F",
      "\u{1F5D1}\uFE0F",
      "\u{1F5D2}\uFE0F",
      "\u{1F5D3}\uFE0F",
      "\u{1F5DC}\uFE0F",
      "\u{1F5DD}\uFE0F",
      "\u{1F5DE}\uFE0F",
      "\u{1F5E1}\uFE0F",
      "\u{1F5E3}\uFE0F",
      "\u{1F5E8}\uFE0F",
      "\u{1F5EF}\uFE0F",
      "\u{1F5F3}\uFE0F",
      "\u{1F5FA}\uFE0F",
      "\u{1F5FB}",
      "\u{1F5FC}",
      "\u{1F5FD}",
      "\u{1F5FE}",
      "\u{1F5FF}",
      "\u{1F600}",
      "\u{1F601}",
      "\u{1F602}",
      "\u{1F603}",
      "\u{1F604}",
      "\u{1F605}",
      "\u{1F606}",
      "\u{1F607}",
      "\u{1F608}",
      "\u{1F609}",
      "\u{1F60A}",
      "\u{1F60B}",
      "\u{1F60C}",
      "\u{1F60D}",
      "\u{1F60E}",
      "\u{1F60F}",
      "\u{1F610}",
      "\u{1F611}",
      "\u{1F612}",
      "\u{1F613}",
      "\u{1F614}",
      "\u{1F615}",
      "\u{1F616}",
      "\u{1F617}",
      "\u{1F618}",
      "\u{1F619}",
      "\u{1F61A}",
      "\u{1F61B}",
      "\u{1F61C}",
      "\u{1F61D}",
      "\u{1F61E}",
      "\u{1F61F}",
      "\u{1F620}",
      "\u{1F621}",
      "\u{1F622}",
      "\u{1F623}",
      "\u{1F624}",
      "\u{1F625}",
      "\u{1F626}",
      "\u{1F627}",
      "\u{1F628}",
      "\u{1F629}",
      "\u{1F62A}",
      "\u{1F62B}",
      "\u{1F62C}",
      "\u{1F62D}",
      "\u{1F62E}",
      "\u{1F62F}",
      "\u{1F630}",
      "\u{1F631}",
      "\u{1F632}",
      "\u{1F633}",
      "\u{1F634}",
      "\u{1F635}",
      "\u{1F636}",
      "\u{1F637}",
      "\u{1F638}",
      "\u{1F639}",
      "\u{1F63A}",
      "\u{1F63B}",
      "\u{1F63C}",
      "\u{1F63D}",
      "\u{1F63E}",
      "\u{1F63F}",
      "\u{1F640}",
      "\u{1F641}",
      "\u{1F642}",
      "\u{1F643}",
      "\u{1F644}",
      "\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FB}",
      "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FC}",
      "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FD}",
      "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FE}",
      "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FF}",
      "\u{1F645}\u200D\u2640\uFE0F",
      "\u{1F645}\u200D\u2642\uFE0F",
      "\u{1F645}",
      "\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FB}",
      "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FC}",
      "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FD}",
      "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FE}",
      "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FF}",
      "\u{1F646}\u200D\u2640\uFE0F",
      "\u{1F646}\u200D\u2642\uFE0F",
      "\u{1F646}",
      "\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FB}",
      "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FC}",
      "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FD}",
      "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FE}",
      "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FF}",
      "\u{1F647}\u200D\u2640\uFE0F",
      "\u{1F647}\u200D\u2642\uFE0F",
      "\u{1F647}",
      "\u{1F648}",
      "\u{1F649}",
      "\u{1F64A}",
      "\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FB}",
      "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FC}",
      "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FD}",
      "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FE}",
      "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FF}",
      "\u{1F64B}\u200D\u2640\uFE0F",
      "\u{1F64B}\u200D\u2642\uFE0F",
      "\u{1F64B}",
      "\u{1F64C}\u{1F3FB}",
      "\u{1F64C}\u{1F3FC}",
      "\u{1F64C}\u{1F3FD}",
      "\u{1F64C}\u{1F3FE}",
      "\u{1F64C}\u{1F3FF}",
      "\u{1F64C}",
      "\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FB}",
      "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FC}",
      "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FD}",
      "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FE}",
      "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FF}",
      "\u{1F64D}\u200D\u2640\uFE0F",
      "\u{1F64D}\u200D\u2642\uFE0F",
      "\u{1F64D}",
      "\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FB}",
      "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FC}",
      "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FD}",
      "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FE}",
      "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FF}",
      "\u{1F64E}\u200D\u2640\uFE0F",
      "\u{1F64E}\u200D\u2642\uFE0F",
      "\u{1F64E}",
      "\u{1F64F}\u{1F3FB}",
      "\u{1F64F}\u{1F3FC}",
      "\u{1F64F}\u{1F3FD}",
      "\u{1F64F}\u{1F3FE}",
      "\u{1F64F}\u{1F3FF}",
      "\u{1F64F}",
      "\u{1F680}",
      "\u{1F681}",
      "\u{1F682}",
      "\u{1F683}",
      "\u{1F684}",
      "\u{1F685}",
      "\u{1F686}",
      "\u{1F687}",
      "\u{1F688}",
      "\u{1F689}",
      "\u{1F68A}",
      "\u{1F68B}",
      "\u{1F68C}",
      "\u{1F68D}",
      "\u{1F68E}",
      "\u{1F68F}",
      "\u{1F690}",
      "\u{1F691}",
      "\u{1F692}",
      "\u{1F693}",
      "\u{1F694}",
      "\u{1F695}",
      "\u{1F696}",
      "\u{1F697}",
      "\u{1F698}",
      "\u{1F699}",
      "\u{1F69A}",
      "\u{1F69B}",
      "\u{1F69C}",
      "\u{1F69D}",
      "\u{1F69E}",
      "\u{1F69F}",
      "\u{1F6A0}",
      "\u{1F6A1}",
      "\u{1F6A2}",
      "\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FB}",
      "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FC}",
      "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FD}",
      "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FE}",
      "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FF}",
      "\u{1F6A3}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u200D\u2642\uFE0F",
      "\u{1F6A3}",
      "\u{1F6A4}",
      "\u{1F6A5}",
      "\u{1F6A6}",
      "\u{1F6A7}",
      "\u{1F6A8}",
      "\u{1F6A9}",
      "\u{1F6AA}",
      "\u{1F6AB}",
      "\u{1F6AC}",
      "\u{1F6AD}",
      "\u{1F6AE}",
      "\u{1F6AF}",
      "\u{1F6B0}",
      "\u{1F6B1}",
      "\u{1F6B2}",
      "\u{1F6B3}",
      "\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FB}",
      "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FC}",
      "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FD}",
      "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FE}",
      "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FF}",
      "\u{1F6B4}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u200D\u2642\uFE0F",
      "\u{1F6B4}",
      "\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FB}",
      "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FC}",
      "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FD}",
      "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FE}",
      "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FF}",
      "\u{1F6B5}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u200D\u2642\uFE0F",
      "\u{1F6B5}",
      "\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FB}",
      "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FC}",
      "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FD}",
      "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FE}",
      "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FF}",
      "\u{1F6B6}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u200D\u2642\uFE0F",
      "\u{1F6B6}",
      "\u{1F6B7}",
      "\u{1F6B8}",
      "\u{1F6B9}",
      "\u{1F6BA}",
      "\u{1F6BB}",
      "\u{1F6BC}",
      "\u{1F6BD}",
      "\u{1F6BE}",
      "\u{1F6BF}",
      "\u{1F6C0}\u{1F3FB}",
      "\u{1F6C0}\u{1F3FC}",
      "\u{1F6C0}\u{1F3FD}",
      "\u{1F6C0}\u{1F3FE}",
      "\u{1F6C0}\u{1F3FF}",
      "\u{1F6C0}",
      "\u{1F6C1}",
      "\u{1F6C2}",
      "\u{1F6C3}",
      "\u{1F6C4}",
      "\u{1F6C5}",
      "\u{1F6CB}\uFE0F",
      "\u{1F6CC}\u{1F3FB}",
      "\u{1F6CC}\u{1F3FC}",
      "\u{1F6CC}\u{1F3FD}",
      "\u{1F6CC}\u{1F3FE}",
      "\u{1F6CC}\u{1F3FF}",
      "\u{1F6CC}",
      "\u{1F6CD}\uFE0F",
      "\u{1F6CE}\uFE0F",
      "\u{1F6CF}\uFE0F",
      "\u{1F6D0}",
      "\u{1F6D1}",
      "\u{1F6D2}",
      "\u{1F6D5}",
      "\u{1F6E0}\uFE0F",
      "\u{1F6E1}\uFE0F",
      "\u{1F6E2}\uFE0F",
      "\u{1F6E3}\uFE0F",
      "\u{1F6E4}\uFE0F",
      "\u{1F6E5}\uFE0F",
      "\u{1F6E9}\uFE0F",
      "\u{1F6EB}",
      "\u{1F6EC}",
      "\u{1F6F0}\uFE0F",
      "\u{1F6F3}\uFE0F",
      "\u{1F6F4}",
      "\u{1F6F5}",
      "\u{1F6F6}",
      "\u{1F6F7}",
      "\u{1F6F8}",
      "\u{1F6F9}",
      "\u{1F6FA}",
      "\u{1F7E0}",
      "\u{1F7E1}",
      "\u{1F7E2}",
      "\u{1F7E3}",
      "\u{1F7E4}",
      "\u{1F7E5}",
      "\u{1F7E6}",
      "\u{1F7E7}",
      "\u{1F7E8}",
      "\u{1F7E9}",
      "\u{1F7EA}",
      "\u{1F7EB}",
      "\u{1F90D}",
      "\u{1F90E}",
      "\u{1F90F}\u{1F3FB}",
      "\u{1F90F}\u{1F3FC}",
      "\u{1F90F}\u{1F3FD}",
      "\u{1F90F}\u{1F3FE}",
      "\u{1F90F}\u{1F3FF}",
      "\u{1F90F}",
      "\u{1F910}",
      "\u{1F911}",
      "\u{1F912}",
      "\u{1F913}",
      "\u{1F914}",
      "\u{1F915}",
      "\u{1F916}",
      "\u{1F917}",
      "\u{1F918}\u{1F3FB}",
      "\u{1F918}\u{1F3FC}",
      "\u{1F918}\u{1F3FD}",
      "\u{1F918}\u{1F3FE}",
      "\u{1F918}\u{1F3FF}",
      "\u{1F918}",
      "\u{1F919}\u{1F3FB}",
      "\u{1F919}\u{1F3FC}",
      "\u{1F919}\u{1F3FD}",
      "\u{1F919}\u{1F3FE}",
      "\u{1F919}\u{1F3FF}",
      "\u{1F919}",
      "\u{1F91A}\u{1F3FB}",
      "\u{1F91A}\u{1F3FC}",
      "\u{1F91A}\u{1F3FD}",
      "\u{1F91A}\u{1F3FE}",
      "\u{1F91A}\u{1F3FF}",
      "\u{1F91A}",
      "\u{1F91B}\u{1F3FB}",
      "\u{1F91B}\u{1F3FC}",
      "\u{1F91B}\u{1F3FD}",
      "\u{1F91B}\u{1F3FE}",
      "\u{1F91B}\u{1F3FF}",
      "\u{1F91B}",
      "\u{1F91C}\u{1F3FB}",
      "\u{1F91C}\u{1F3FC}",
      "\u{1F91C}\u{1F3FD}",
      "\u{1F91C}\u{1F3FE}",
      "\u{1F91C}\u{1F3FF}",
      "\u{1F91C}",
      "\u{1F91D}",
      "\u{1F91E}\u{1F3FB}",
      "\u{1F91E}\u{1F3FC}",
      "\u{1F91E}\u{1F3FD}",
      "\u{1F91E}\u{1F3FE}",
      "\u{1F91E}\u{1F3FF}",
      "\u{1F91E}",
      "\u{1F91F}\u{1F3FB}",
      "\u{1F91F}\u{1F3FC}",
      "\u{1F91F}\u{1F3FD}",
      "\u{1F91F}\u{1F3FE}",
      "\u{1F91F}\u{1F3FF}",
      "\u{1F91F}",
      "\u{1F920}",
      "\u{1F921}",
      "\u{1F922}",
      "\u{1F923}",
      "\u{1F924}",
      "\u{1F925}",
      "\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FB}",
      "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FC}",
      "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FD}",
      "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FE}",
      "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FF}",
      "\u{1F926}\u200D\u2640\uFE0F",
      "\u{1F926}\u200D\u2642\uFE0F",
      "\u{1F926}",
      "\u{1F927}",
      "\u{1F928}",
      "\u{1F929}",
      "\u{1F92A}",
      "\u{1F92B}",
      "\u{1F92C}",
      "\u{1F92D}",
      "\u{1F92E}",
      "\u{1F92F}",
      "\u{1F930}\u{1F3FB}",
      "\u{1F930}\u{1F3FC}",
      "\u{1F930}\u{1F3FD}",
      "\u{1F930}\u{1F3FE}",
      "\u{1F930}\u{1F3FF}",
      "\u{1F930}",
      "\u{1F931}\u{1F3FB}",
      "\u{1F931}\u{1F3FC}",
      "\u{1F931}\u{1F3FD}",
      "\u{1F931}\u{1F3FE}",
      "\u{1F931}\u{1F3FF}",
      "\u{1F931}",
      "\u{1F932}\u{1F3FB}",
      "\u{1F932}\u{1F3FC}",
      "\u{1F932}\u{1F3FD}",
      "\u{1F932}\u{1F3FE}",
      "\u{1F932}\u{1F3FF}",
      "\u{1F932}",
      "\u{1F933}\u{1F3FB}",
      "\u{1F933}\u{1F3FC}",
      "\u{1F933}\u{1F3FD}",
      "\u{1F933}\u{1F3FE}",
      "\u{1F933}\u{1F3FF}",
      "\u{1F933}",
      "\u{1F934}\u{1F3FB}",
      "\u{1F934}\u{1F3FC}",
      "\u{1F934}\u{1F3FD}",
      "\u{1F934}\u{1F3FE}",
      "\u{1F934}\u{1F3FF}",
      "\u{1F934}",
      "\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FB}",
      "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FC}",
      "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FD}",
      "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FE}",
      "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FF}",
      "\u{1F935}\u200D\u2640\uFE0F",
      "\u{1F935}\u200D\u2642\uFE0F",
      "\u{1F935}",
      "\u{1F936}\u{1F3FB}",
      "\u{1F936}\u{1F3FC}",
      "\u{1F936}\u{1F3FD}",
      "\u{1F936}\u{1F3FE}",
      "\u{1F936}\u{1F3FF}",
      "\u{1F936}",
      "\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FB}",
      "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FC}",
      "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FD}",
      "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FE}",
      "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FF}",
      "\u{1F937}\u200D\u2640\uFE0F",
      "\u{1F937}\u200D\u2642\uFE0F",
      "\u{1F937}",
      "\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FB}",
      "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FC}",
      "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FD}",
      "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FE}",
      "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FF}",
      "\u{1F938}\u200D\u2640\uFE0F",
      "\u{1F938}\u200D\u2642\uFE0F",
      "\u{1F938}",
      "\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FB}",
      "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FC}",
      "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FD}",
      "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FE}",
      "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FF}",
      "\u{1F939}\u200D\u2640\uFE0F",
      "\u{1F939}\u200D\u2642\uFE0F",
      "\u{1F939}",
      "\u{1F93A}",
      "\u{1F93C}\u200D\u2640\uFE0F",
      "\u{1F93C}\u200D\u2642\uFE0F",
      "\u{1F93C}",
      "\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FB}",
      "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FC}",
      "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FD}",
      "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FE}",
      "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FF}",
      "\u{1F93D}\u200D\u2640\uFE0F",
      "\u{1F93D}\u200D\u2642\uFE0F",
      "\u{1F93D}",
      "\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FB}",
      "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FC}",
      "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FD}",
      "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FE}",
      "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FF}",
      "\u{1F93E}\u200D\u2640\uFE0F",
      "\u{1F93E}\u200D\u2642\uFE0F",
      "\u{1F93E}",
      "\u{1F93F}",
      "\u{1F940}",
      "\u{1F941}",
      "\u{1F942}",
      "\u{1F943}",
      "\u{1F944}",
      "\u{1F945}",
      "\u{1F947}",
      "\u{1F948}",
      "\u{1F949}",
      "\u{1F94A}",
      "\u{1F94B}",
      "\u{1F94C}",
      "\u{1F94D}",
      "\u{1F94E}",
      "\u{1F94F}",
      "\u{1F950}",
      "\u{1F951}",
      "\u{1F952}",
      "\u{1F953}",
      "\u{1F954}",
      "\u{1F955}",
      "\u{1F956}",
      "\u{1F957}",
      "\u{1F958}",
      "\u{1F959}",
      "\u{1F95A}",
      "\u{1F95B}",
      "\u{1F95C}",
      "\u{1F95D}",
      "\u{1F95E}",
      "\u{1F95F}",
      "\u{1F960}",
      "\u{1F961}",
      "\u{1F962}",
      "\u{1F963}",
      "\u{1F964}",
      "\u{1F965}",
      "\u{1F966}",
      "\u{1F967}",
      "\u{1F968}",
      "\u{1F969}",
      "\u{1F96A}",
      "\u{1F96B}",
      "\u{1F96C}",
      "\u{1F96D}",
      "\u{1F96E}",
      "\u{1F96F}",
      "\u{1F970}",
      "\u{1F971}",
      "\u{1F973}",
      "\u{1F974}",
      "\u{1F975}",
      "\u{1F976}",
      "\u{1F97A}",
      "\u{1F97B}",
      "\u{1F97C}",
      "\u{1F97D}",
      "\u{1F97E}",
      "\u{1F97F}",
      "\u{1F980}",
      "\u{1F981}",
      "\u{1F982}",
      "\u{1F983}",
      "\u{1F984}",
      "\u{1F985}",
      "\u{1F986}",
      "\u{1F987}",
      "\u{1F988}",
      "\u{1F989}",
      "\u{1F98A}",
      "\u{1F98B}",
      "\u{1F98C}",
      "\u{1F98D}",
      "\u{1F98E}",
      "\u{1F98F}",
      "\u{1F990}",
      "\u{1F991}",
      "\u{1F992}",
      "\u{1F993}",
      "\u{1F994}",
      "\u{1F995}",
      "\u{1F996}",
      "\u{1F997}",
      "\u{1F998}",
      "\u{1F999}",
      "\u{1F99A}",
      "\u{1F99B}",
      "\u{1F99C}",
      "\u{1F99D}",
      "\u{1F99E}",
      "\u{1F99F}",
      "\u{1F9A0}",
      "\u{1F9A1}",
      "\u{1F9A2}",
      "\u{1F9A5}",
      "\u{1F9A6}",
      "\u{1F9A7}",
      "\u{1F9A8}",
      "\u{1F9A9}",
      "\u{1F9AA}",
      "\u{1F9AE}",
      "\u{1F9AF}",
      "\u{1F9B0}",
      "\u{1F9B1}",
      "\u{1F9B2}",
      "\u{1F9B3}",
      "\u{1F9B4}",
      "\u{1F9B5}\u{1F3FB}",
      "\u{1F9B5}\u{1F3FC}",
      "\u{1F9B5}\u{1F3FD}",
      "\u{1F9B5}\u{1F3FE}",
      "\u{1F9B5}\u{1F3FF}",
      "\u{1F9B5}",
      "\u{1F9B6}\u{1F3FB}",
      "\u{1F9B6}\u{1F3FC}",
      "\u{1F9B6}\u{1F3FD}",
      "\u{1F9B6}\u{1F3FE}",
      "\u{1F9B6}\u{1F3FF}",
      "\u{1F9B6}",
      "\u{1F9B7}",
      "\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FB}",
      "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FC}",
      "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FD}",
      "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FE}",
      "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FF}",
      "\u{1F9B8}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u200D\u2642\uFE0F",
      "\u{1F9B8}",
      "\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FB}",
      "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FC}",
      "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FD}",
      "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FE}",
      "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FF}",
      "\u{1F9B9}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u200D\u2642\uFE0F",
      "\u{1F9B9}",
      "\u{1F9BA}",
      "\u{1F9BB}\u{1F3FB}",
      "\u{1F9BB}\u{1F3FC}",
      "\u{1F9BB}\u{1F3FD}",
      "\u{1F9BB}\u{1F3FE}",
      "\u{1F9BB}\u{1F3FF}",
      "\u{1F9BB}",
      "\u{1F9BC}",
      "\u{1F9BD}",
      "\u{1F9BE}",
      "\u{1F9BF}",
      "\u{1F9C0}",
      "\u{1F9C1}",
      "\u{1F9C2}",
      "\u{1F9C3}",
      "\u{1F9C4}",
      "\u{1F9C5}",
      "\u{1F9C6}",
      "\u{1F9C7}",
      "\u{1F9C8}",
      "\u{1F9C9}",
      "\u{1F9CA}",
      "\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FB}",
      "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FC}",
      "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FD}",
      "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FE}",
      "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FF}",
      "\u{1F9CD}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u200D\u2642\uFE0F",
      "\u{1F9CD}",
      "\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FB}",
      "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FC}",
      "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FD}",
      "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FE}",
      "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FF}",
      "\u{1F9CE}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u200D\u2642\uFE0F",
      "\u{1F9CE}",
      "\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FB}",
      "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FC}",
      "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FD}",
      "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FE}",
      "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FF}",
      "\u{1F9CF}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u200D\u2642\uFE0F",
      "\u{1F9CF}",
      "\u{1F9D0}",
      "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}",
      "\u{1F9D1}\u{1F3FF}",
      "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}",
      "\u{1F9D1}",
      "\u{1F9D2}\u{1F3FB}",
      "\u{1F9D2}\u{1F3FC}",
      "\u{1F9D2}\u{1F3FD}",
      "\u{1F9D2}\u{1F3FE}",
      "\u{1F9D2}\u{1F3FF}",
      "\u{1F9D2}",
      "\u{1F9D3}\u{1F3FB}",
      "\u{1F9D3}\u{1F3FC}",
      "\u{1F9D3}\u{1F3FD}",
      "\u{1F9D3}\u{1F3FE}",
      "\u{1F9D3}\u{1F3FF}",
      "\u{1F9D3}",
      "\u{1F9D4}\u{1F3FB}",
      "\u{1F9D4}\u{1F3FC}",
      "\u{1F9D4}\u{1F3FD}",
      "\u{1F9D4}\u{1F3FE}",
      "\u{1F9D4}\u{1F3FF}",
      "\u{1F9D4}",
      "\u{1F9D5}\u{1F3FB}",
      "\u{1F9D5}\u{1F3FC}",
      "\u{1F9D5}\u{1F3FD}",
      "\u{1F9D5}\u{1F3FE}",
      "\u{1F9D5}\u{1F3FF}",
      "\u{1F9D5}",
      "\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FB}",
      "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FC}",
      "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FD}",
      "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FE}",
      "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FF}",
      "\u{1F9D6}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u200D\u2642\uFE0F",
      "\u{1F9D6}",
      "\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FB}",
      "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FC}",
      "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FD}",
      "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FE}",
      "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FF}",
      "\u{1F9D7}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u200D\u2642\uFE0F",
      "\u{1F9D7}",
      "\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FB}",
      "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FC}",
      "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FD}",
      "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FE}",
      "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FF}",
      "\u{1F9D8}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u200D\u2642\uFE0F",
      "\u{1F9D8}",
      "\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FB}",
      "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FC}",
      "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FD}",
      "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FE}",
      "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FF}",
      "\u{1F9D9}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u200D\u2642\uFE0F",
      "\u{1F9D9}",
      "\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FB}",
      "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FC}",
      "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FD}",
      "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FE}",
      "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FF}",
      "\u{1F9DA}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u200D\u2642\uFE0F",
      "\u{1F9DA}",
      "\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FB}",
      "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FC}",
      "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FD}",
      "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FE}",
      "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FF}",
      "\u{1F9DB}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u200D\u2642\uFE0F",
      "\u{1F9DB}",
      "\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FB}",
      "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FC}",
      "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FD}",
      "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FE}",
      "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FF}",
      "\u{1F9DC}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u200D\u2642\uFE0F",
      "\u{1F9DC}",
      "\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FB}",
      "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FC}",
      "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FD}",
      "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FE}",
      "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FF}",
      "\u{1F9DD}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u200D\u2642\uFE0F",
      "\u{1F9DD}",
      "\u{1F9DE}\u200D\u2640\uFE0F",
      "\u{1F9DE}\u200D\u2642\uFE0F",
      "\u{1F9DE}",
      "\u{1F9DF}\u200D\u2640\uFE0F",
      "\u{1F9DF}\u200D\u2642\uFE0F",
      "\u{1F9DF}",
      "\u{1F9E0}",
      "\u{1F9E1}",
      "\u{1F9E2}",
      "\u{1F9E3}",
      "\u{1F9E4}",
      "\u{1F9E5}",
      "\u{1F9E6}",
      "\u{1F9E7}",
      "\u{1F9E8}",
      "\u{1F9E9}",
      "\u{1F9EA}",
      "\u{1F9EB}",
      "\u{1F9EC}",
      "\u{1F9ED}",
      "\u{1F9EE}",
      "\u{1F9EF}",
      "\u{1F9F0}",
      "\u{1F9F1}",
      "\u{1F9F2}",
      "\u{1F9F3}",
      "\u{1F9F4}",
      "\u{1F9F5}",
      "\u{1F9F6}",
      "\u{1F9F7}",
      "\u{1F9F8}",
      "\u{1F9F9}",
      "\u{1F9FA}",
      "\u{1F9FB}",
      "\u{1F9FC}",
      "\u{1F9FD}",
      "\u{1F9FE}",
      "\u{1F9FF}",
      "\u{1FA70}",
      "\u{1FA71}",
      "\u{1FA72}",
      "\u{1FA73}",
      "\u{1FA78}",
      "\u{1FA79}",
      "\u{1FA7A}",
      "\u{1FA80}",
      "\u{1FA81}",
      "\u{1FA82}",
      "\u{1FA90}",
      "\u{1FA91}",
      "\u{1FA92}",
      "\u{1FA93}",
      "\u{1FA94}",
      "\u{1FA95}",
      "\u203C\uFE0F",
      "\u2049\uFE0F",
      "\u2122\uFE0F",
      "\u2139\uFE0F",
      "\u2194\uFE0F",
      "\u2195\uFE0F",
      "\u2196\uFE0F",
      "\u2197\uFE0F",
      "\u2198\uFE0F",
      "\u2199\uFE0F",
      "\u21A9\uFE0F",
      "\u21AA\uFE0F",
      "#\u20E3",
      "\u231A\uFE0F",
      "\u231B\uFE0F",
      "\u2328\uFE0F",
      "\u23CF\uFE0F",
      "\u23E9",
      "\u23EA",
      "\u23EB",
      "\u23EC",
      "\u23ED\uFE0F",
      "\u23EE\uFE0F",
      "\u23EF\uFE0F",
      "\u23F0",
      "\u23F1\uFE0F",
      "\u23F2\uFE0F",
      "\u23F3",
      "\u23F8\uFE0F",
      "\u23F9\uFE0F",
      "\u23FA\uFE0F",
      "\u24C2\uFE0F",
      "\u25AA\uFE0F",
      "\u25AB\uFE0F",
      "\u25B6\uFE0F",
      "\u25C0\uFE0F",
      "\u25FB\uFE0F",
      "\u25FC\uFE0F",
      "\u25FD\uFE0F",
      "\u25FE\uFE0F",
      "\u2600\uFE0F",
      "\u2601\uFE0F",
      "\u2602\uFE0F",
      "\u2603\uFE0F",
      "\u2604\uFE0F",
      "\u260E\uFE0F",
      "\u2611\uFE0F",
      "\u2614\uFE0F",
      "\u2615\uFE0F",
      "\u2618\uFE0F",
      "\u261D\u{1F3FB}",
      "\u261D\u{1F3FC}",
      "\u261D\u{1F3FD}",
      "\u261D\u{1F3FE}",
      "\u261D\u{1F3FF}",
      "\u261D\uFE0F",
      "\u2620\uFE0F",
      "\u2622\uFE0F",
      "\u2623\uFE0F",
      "\u2626\uFE0F",
      "\u262A\uFE0F",
      "\u262E\uFE0F",
      "\u262F\uFE0F",
      "\u2638\uFE0F",
      "\u2639\uFE0F",
      "\u263A\uFE0F",
      "\u2640\uFE0F",
      "\u2642\uFE0F",
      "\u2648\uFE0F",
      "\u2649\uFE0F",
      "\u264A\uFE0F",
      "\u264B\uFE0F",
      "\u264C\uFE0F",
      "\u264D\uFE0F",
      "\u264E\uFE0F",
      "\u264F\uFE0F",
      "\u2650\uFE0F",
      "\u2651\uFE0F",
      "\u2652\uFE0F",
      "\u2653\uFE0F",
      "\u265F\uFE0F",
      "\u2660\uFE0F",
      "\u2663\uFE0F",
      "\u2665\uFE0F",
      "\u2666\uFE0F",
      "\u2668\uFE0F",
      "\u267B\uFE0F",
      "\u267E",
      "\u267F\uFE0F",
      "\u2692\uFE0F",
      "\u2693\uFE0F",
      "\u2694\uFE0F",
      "\u2695\uFE0F",
      "\u2696\uFE0F",
      "\u2697\uFE0F",
      "\u2699\uFE0F",
      "\u269B\uFE0F",
      "\u269C\uFE0F",
      "\u26A0\uFE0F",
      "\u26A1\uFE0F",
      "\u26AA\uFE0F",
      "\u26AB\uFE0F",
      "\u26B0\uFE0F",
      "\u26B1\uFE0F",
      "\u26BD\uFE0F",
      "\u26BE\uFE0F",
      "\u26C4\uFE0F",
      "\u26C5\uFE0F",
      "\u26C8\uFE0F",
      "\u26CE",
      "\u26CF\uFE0F",
      "\u26D1\uFE0F",
      "\u26D3\uFE0F",
      "\u26D4\uFE0F",
      "\u26E9\uFE0F",
      "\u26EA\uFE0F",
      "\u26F0\uFE0F",
      "\u26F1\uFE0F",
      "\u26F2\uFE0F",
      "\u26F3\uFE0F",
      "\u26F4\uFE0F",
      "\u26F5\uFE0F",
      "\u26F7\u{1F3FB}",
      "\u26F7\u{1F3FC}",
      "\u26F7\u{1F3FD}",
      "\u26F7\u{1F3FE}",
      "\u26F7\u{1F3FF}",
      "\u26F7\uFE0F",
      "\u26F8\uFE0F",
      "\u26F9\u{1F3FB}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FB}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FB}",
      "\u26F9\u{1F3FC}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FC}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FC}",
      "\u26F9\u{1F3FD}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FD}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FD}",
      "\u26F9\u{1F3FE}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FE}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FE}",
      "\u26F9\u{1F3FF}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FF}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FF}",
      "\u26F9\uFE0F\u200D\u2640\uFE0F",
      "\u26F9\uFE0F\u200D\u2642\uFE0F",
      "\u26F9\uFE0F",
      "\u26FA\uFE0F",
      "\u26FD\uFE0F",
      "\u2702\uFE0F",
      "\u2705",
      "\u2708\uFE0F",
      "\u2709\uFE0F",
      "\u270A\u{1F3FB}",
      "\u270A\u{1F3FC}",
      "\u270A\u{1F3FD}",
      "\u270A\u{1F3FE}",
      "\u270A\u{1F3FF}",
      "\u270A",
      "\u270B\u{1F3FB}",
      "\u270B\u{1F3FC}",
      "\u270B\u{1F3FD}",
      "\u270B\u{1F3FE}",
      "\u270B\u{1F3FF}",
      "\u270B",
      "\u270C\u{1F3FB}",
      "\u270C\u{1F3FC}",
      "\u270C\u{1F3FD}",
      "\u270C\u{1F3FE}",
      "\u270C\u{1F3FF}",
      "\u270C\uFE0F",
      "\u270D\u{1F3FB}",
      "\u270D\u{1F3FC}",
      "\u270D\u{1F3FD}",
      "\u270D\u{1F3FE}",
      "\u270D\u{1F3FF}",
      "\u270D\uFE0F",
      "\u270F\uFE0F",
      "\u2712\uFE0F",
      "\u2714\uFE0F",
      "\u2716\uFE0F",
      "\u271D\uFE0F",
      "\u2721\uFE0F",
      "\u2728",
      "\u2733\uFE0F",
      "\u2734\uFE0F",
      "\u2744\uFE0F",
      "\u2747\uFE0F",
      "\u274C",
      "\u274E",
      "\u2753",
      "\u2754",
      "\u2755",
      "\u2757\uFE0F",
      "\u2763\uFE0F",
      "\u2764\uFE0F",
      "\u2795",
      "\u2796",
      "\u2797",
      "\u27A1\uFE0F",
      "\u27B0",
      "\u27BF",
      "\u2934\uFE0F",
      "\u2935\uFE0F",
      "*\u20E3",
      "\u2B05\uFE0F",
      "\u2B06\uFE0F",
      "\u2B07\uFE0F",
      "\u2B1B\uFE0F",
      "\u2B1C\uFE0F",
      "\u2B50\uFE0F",
      "\u2B55\uFE0F",
      "0\u20E3",
      "\u3030\uFE0F",
      "\u303D\uFE0F",
      "1\u20E3",
      "2\u20E3",
      "\u3297\uFE0F",
      "\u3299\uFE0F",
      "3\u20E3",
      "4\u20E3",
      "5\u20E3",
      "6\u20E3",
      "7\u20E3",
      "8\u20E3",
      "9\u20E3",
      "\xA9\uFE0F",
      "\xAE\uFE0F",
      "\uE50A"
    ];
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/interpolateName.js
var require_interpolateName = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/interpolateName.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var emojisList = require_emojis_list();
    var getHashDigest = require_getHashDigest();
    var emojiRegex = /[\uD800-\uDFFF]./;
    var emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));
    var emojiCache = {};
    function encodeStringToEmoji(content, length) {
      if (emojiCache[content]) {
        return emojiCache[content];
      }
      length = length || 1;
      const emojis = [];
      do {
        if (!emojiList.length) {
          throw new Error("Ran out of emoji");
        }
        const index = Math.floor(Math.random() * emojiList.length);
        emojis.push(emojiList[index]);
        emojiList.splice(index, 1);
      } while (--length > 0);
      const emojiEncoding = emojis.join("");
      emojiCache[content] = emojiEncoding;
      return emojiEncoding;
    }
    function interpolateName(loaderContext, name, options) {
      let filename;
      const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
      if (typeof name === "function") {
        filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : void 0);
      } else {
        filename = name || "[hash].[ext]";
      }
      const context = options.context;
      const content = options.content;
      const regExp = options.regExp;
      let ext = "bin";
      let basename = "file";
      let directory = "";
      let folder = "";
      let query = "";
      if (loaderContext.resourcePath) {
        const parsed = path.parse(loaderContext.resourcePath);
        let resourcePath = loaderContext.resourcePath;
        if (parsed.ext) {
          ext = parsed.ext.substr(1);
        }
        if (parsed.dir) {
          basename = parsed.name;
          resourcePath = parsed.dir + path.sep;
        }
        if (typeof context !== "undefined") {
          directory = path.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
          directory = directory.substr(0, directory.length - 1);
        } else {
          directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
        }
        if (directory.length === 1) {
          directory = "";
        } else if (directory.length > 1) {
          folder = path.basename(directory);
        }
      }
      if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
        query = loaderContext.resourceQuery;
        const hashIdx = query.indexOf("#");
        if (hashIdx >= 0) {
          query = query.substr(0, hashIdx);
        }
      }
      let url = filename;
      if (content) {
        url = url.replace(/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\[emoji(?::(\d+))?\]/gi, (all, length) => encodeStringToEmoji(content, parseInt(length, 10)));
      }
      url = url.replace(/\[ext\]/gi, () => ext).replace(/\[name\]/gi, () => basename).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
      if (regExp && loaderContext.resourcePath) {
        const match = loaderContext.resourcePath.match(new RegExp(regExp));
        match && match.forEach((matched, i) => {
          url = url.replace(new RegExp("\\[" + i + "\\]", "ig"), matched);
        });
      }
      if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
        url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);
      }
      return url;
    }
    module2.exports = interpolateName;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/index.js
var require_lib3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/loader-utils-npm-1.4.0-a56254a277-d150b15e7a.zip/node_modules/loader-utils/lib/index.js"(exports2) {
    "use strict";
    var getOptions = require_getOptions();
    var parseQuery = require_parseQuery();
    var stringifyRequest = require_stringifyRequest();
    var getRemainingRequest = require_getRemainingRequest();
    var getCurrentRequest = require_getCurrentRequest();
    var isUrlRequest = require_isUrlRequest();
    var urlToRequest = require_urlToRequest();
    var parseString = require_parseString();
    var getHashDigest = require_getHashDigest();
    var interpolateName = require_interpolateName();
    exports2.getOptions = getOptions;
    exports2.parseQuery = parseQuery;
    exports2.stringifyRequest = stringifyRequest;
    exports2.getRemainingRequest = getRemainingRequest;
    exports2.getCurrentRequest = getCurrentRequest;
    exports2.isUrlRequest = isUrlRequest;
    exports2.urlToRequest = urlToRequest;
    exports2.parseString = parseString;
    exports2.getHashDigest = getHashDigest;
    exports2.interpolateName = interpolateName;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/generic-names-npm-2.0.1-6ef8235104-5f2d6837dc.zip/node_modules/generic-names/index.js
var require_generic_names = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/generic-names-npm-2.0.1-6ef8235104-5f2d6837dc.zip/node_modules/generic-names/index.js"(exports2, module2) {
    "use strict";
    var interpolateName = require_lib3().interpolateName;
    var path = require("path");
    module2.exports = function createGenerator(pattern, options) {
      options = options || {};
      var context = options && typeof options.context === "string" ? options.context : process.cwd();
      var hashPrefix = options && typeof options.hashPrefix === "string" ? options.hashPrefix : "";
      return function generate2(localName, filepath) {
        var name = pattern.replace(/\[local\]/gi, localName);
        var loaderContext = {
          resourcePath: filepath
        };
        var loaderOptions = {
          content: hashPrefix + path.relative(context, filepath).replace(/\\/g, "/") + "+" + localName,
          context
        };
        var genericName = interpolateName(loaderContext, name, loaderOptions);
        return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/unquote/index.js
var require_unquote = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/unquote/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = unquote;
    var reg = /['"]/;
    function unquote(str) {
      if (!str) {
        return "";
      }
      if (reg.test(str.charAt(0))) {
        str = str.substr(1);
      }
      if (reg.test(str.charAt(str.length - 1))) {
        str = str.substr(0, str.length - 1);
      }
      return str;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/icss-replace-symbols-npm-1.1.0-bc11c612de-24575b2c2f.zip/node_modules/icss-replace-symbols/lib/index.js
var require_lib4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/icss-replace-symbols-npm-1.1.0-bc11c612de-24575b2c2f.zip/node_modules/icss-replace-symbols/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.replaceAll = replaceAll;
    var matchConstName = /[$#]?[\w-\.]+/g;
    function replaceAll(replacements, text) {
      var matches = void 0;
      while (matches = matchConstName.exec(text)) {
        var replacement = replacements[matches[0]];
        if (replacement) {
          text = text.slice(0, matches.index) + replacement + text.slice(matchConstName.lastIndex);
          matchConstName.lastIndex -= matches[0].length - replacement.length;
        }
      }
      return text;
    }
    exports2.default = function(css, translations) {
      css.walkDecls(function(decl) {
        return decl.value = replaceAll(translations, decl.value);
      });
      css.walkAtRules("media", function(atRule) {
        return atRule.params = replaceAll(translations, atRule.params);
      });
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/css-loader-core/parser.js
var require_parser3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/css-loader-core/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _icssReplaceSymbols = require_lib4();
    var _icssReplaceSymbols2 = _interopRequireDefault(_icssReplaceSymbols);
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    var importRegexp = /^:import\((.+)\)$/;
    var Parser = class {
      constructor(pathFetcher, trace) {
        this.pathFetcher = pathFetcher;
        this.plugin = this.plugin.bind(this);
        this.exportTokens = {};
        this.translations = {};
        this.trace = trace;
      }
      plugin() {
        const parser = this;
        return {
          postcssPlugin: "css-modules-parser",
          OnceExit(css) {
            return Promise.all(parser.fetchAllImports(css)).then(() => parser.linkImportedSymbols(css)).then(() => parser.extractExports(css));
          }
        };
      }
      fetchAllImports(css) {
        let imports = [];
        css.each((node) => {
          if (node.type == "rule" && node.selector.match(importRegexp)) {
            imports.push(this.fetchImport(node, css.source.input.from, imports.length));
          }
        });
        return imports;
      }
      linkImportedSymbols(css) {
        (0, _icssReplaceSymbols2.default)(css, this.translations);
      }
      extractExports(css) {
        css.each((node) => {
          if (node.type == "rule" && node.selector == ":export")
            this.handleExport(node);
        });
      }
      handleExport(exportNode) {
        exportNode.each((decl) => {
          if (decl.type == "decl") {
            Object.keys(this.translations).forEach((translation) => {
              decl.value = decl.value.replace(translation, this.translations[translation]);
            });
            this.exportTokens[decl.prop] = decl.value;
          }
        });
        exportNode.remove();
      }
      fetchImport(importNode, relativeTo, depNr) {
        let file = importNode.selector.match(importRegexp)[1], depTrace = this.trace + String.fromCharCode(depNr);
        return this.pathFetcher(file, relativeTo, depTrace).then((exports3) => {
          importNode.each((decl) => {
            if (decl.type == "decl") {
              this.translations[decl.prop] = exports3[decl.value];
            }
          });
          importNode.remove();
        }, (err) => console.log(err));
      }
    };
    exports2.default = Parser;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/css-loader-core/loader.js
var require_loader = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/css-loader-core/loader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _postcss = require_postcss();
    var _postcss2 = _interopRequireDefault(_postcss);
    var _fs = require("fs");
    var _fs2 = _interopRequireDefault(_fs);
    var _path = require("path");
    var _path2 = _interopRequireDefault(_path);
    var _parser = require_parser3();
    var _parser2 = _interopRequireDefault(_parser);
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    var Core = class {
      constructor(plugins) {
        this.plugins = plugins || Core.defaultPlugins;
      }
      load(sourceString, sourcePath, trace, pathFetcher) {
        let parser = new _parser2.default(pathFetcher, trace);
        return (0, _postcss2.default)(this.plugins.concat([parser.plugin()])).process(sourceString, { from: "/" + sourcePath }).then((result) => {
          return {
            injectableSource: result.css,
            exportTokens: parser.exportTokens
          };
        });
      }
    };
    var traceKeySorter = (a, b) => {
      if (a.length < b.length) {
        return a < b.substring(0, a.length) ? -1 : 1;
      } else if (a.length > b.length) {
        return a.substring(0, b.length) <= b ? -1 : 1;
      } else {
        return a < b ? -1 : 1;
      }
    };
    var FileSystemLoader = class {
      constructor(root, plugins) {
        this.root = root;
        this.sources = {};
        this.traces = {};
        this.importNr = 0;
        this.core = new Core(plugins);
        this.tokensByFile = {};
      }
      fetch(_newPath, relativeTo, _trace) {
        let newPath = _newPath.replace(/^["']|["']$/g, ""), trace = _trace || String.fromCharCode(this.importNr++);
        return new Promise((resolve, reject) => {
          let relativeDir = _path2.default.dirname(relativeTo), rootRelativePath = _path2.default.resolve(relativeDir, newPath), fileRelativePath = _path2.default.resolve(_path2.default.join(this.root, relativeDir), newPath);
          if (newPath[0] !== "." && newPath[0] !== "/") {
            try {
              fileRelativePath = require.resolve(newPath);
            } catch (e) {
            }
          }
          const tokens = this.tokensByFile[fileRelativePath];
          if (tokens) {
            return resolve(tokens);
          }
          _fs2.default.readFile(fileRelativePath, "utf-8", (err, source) => {
            if (err)
              reject(err);
            this.core.load(source, rootRelativePath, trace, this.fetch.bind(this)).then(({ injectableSource, exportTokens }) => {
              this.sources[fileRelativePath] = injectableSource;
              this.traces[trace] = fileRelativePath;
              this.tokensByFile[fileRelativePath] = exportTokens;
              resolve(exportTokens);
            }, reject);
          });
        });
      }
      get finalSource() {
        const traces = this.traces;
        const sources = this.sources;
        let written = new Set();
        return Object.keys(traces).sort(traceKeySorter).map((key) => {
          const filename = traces[key];
          if (written.has(filename)) {
            return null;
          }
          written.add(filename);
          return sources[filename];
        }).join("");
      }
    };
    exports2.default = FileSystemLoader;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/string-hash-npm-1.1.3-3cb8892e7c-104b8667a5.zip/node_modules/string-hash/index.js
var require_string_hash = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/string-hash-npm-1.1.3-3cb8892e7c-104b8667a5.zip/node_modules/string-hash/index.js"(exports2, module2) {
    "use strict";
    function hash(str) {
      var hash2 = 5381, i = str.length;
      while (i) {
        hash2 = hash2 * 33 ^ str.charCodeAt(--i);
      }
      return hash2 >>> 0;
    }
    module2.exports = hash;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/generateScopedName.js
var require_generateScopedName = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/generateScopedName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generateScopedName;
    var _stringHash = require_string_hash();
    var _stringHash2 = _interopRequireDefault(_stringHash);
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    function generateScopedName(name, filename, css) {
      const i = css.indexOf(`.${name}`);
      const lineNumber = css.substr(0, i).split(/[\r\n]/).length;
      const hash = (0, _stringHash2.default)(css).toString(36).substr(0, 5);
      return `_${name}_${hash}_${lineNumber}`;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/saveJSON.js
var require_saveJSON = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/saveJSON.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = saveJSON;
    var _fs = require("fs");
    function saveJSON(cssFile, json) {
      return new Promise((resolve, reject) => {
        (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json), (e) => e ? reject(e) : resolve(json));
      });
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/parse.js
var require_parse5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/parse.js"(exports2, module2) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module2.exports = function(input) {
      var tokens = [];
      var value = input;
      var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value.charCodeAt(pos);
      var max = value.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          token = value.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
          } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape = false;
            next = value.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += quote;
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          token.value = value.slice(pos + 1, next);
          tokens.push(token);
          pos = next + 1;
          code = value.charCodeAt(pos);
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
          token = {
            type: "comment",
            sourceIndex: pos
          };
          next = value.indexOf("*/", pos);
          if (next === -1) {
            token.unclosed = true;
            next = value.length;
          }
          token.value = value.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            value: token
          });
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape = false;
              next = value.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += ")";
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    value: value.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  value: value.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value.slice(whitespacePos + 1, next);
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            code = value.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value.charCodeAt(pos);
          parent.after = after;
          after = "";
          balanced -= 1;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
      }
      return stack[0].nodes;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/walk.js
var require_walk = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/walk.js"(exports2, module2) {
    module2.exports = function walk2(nodes, cb, bubble) {
      var i, max, node, result;
      for (i = 0, max = nodes.length; i < max; i += 1) {
        node = nodes[i];
        if (!bubble) {
          result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
          walk2(node.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node, i, nodes);
        }
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/stringify.js
var require_stringify4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/stringify.js"(exports2, module2) {
    function stringifyNode(node, custom) {
      var type = node.type;
      var value = node.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value;
      } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
      } else if (Array.isArray(node.nodes)) {
        buf = stringify2(node.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
      }
      return value;
    }
    function stringify2(nodes, custom) {
      var result, i;
      if (Array.isArray(nodes)) {
        result = "";
        for (i = nodes.length - 1; ~i; i -= 1) {
          result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
      }
      return stringifyNode(nodes, custom);
    }
    module2.exports = stringify2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/unit.js"(exports2, module2) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value) {
      var code = value.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module2.exports = function(value) {
      var pos = 0;
      var length = value.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length === 0 || !likeNumber(value)) {
        return false;
      }
      code = value.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      nextNextCode = value.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      };
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/index.js
var require_lib5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/postcss-value-parser-npm-4.1.0-4620e3e849-68a9ea27c7.zip/node_modules/postcss-value-parser/lib/index.js"(exports2, module2) {
    var parse3 = require_parse5();
    var walk2 = require_walk();
    var stringify2 = require_stringify4();
    function ValueParser(value) {
      if (this instanceof ValueParser) {
        this.nodes = parse3(value);
        return this;
      }
      return new ValueParser(value);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify2(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = require_unit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify2;
    module2.exports = ValueParser;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/replaceValueSymbols.js
var require_replaceValueSymbols = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/replaceValueSymbols.js"(exports2, module2) {
    var matchValueName = /[$]?[\w-]+/g;
    var replaceValueSymbols = (value, replacements) => {
      let matches;
      while (matches = matchValueName.exec(value)) {
        const replacement = replacements[matches[0]];
        if (replacement) {
          value = value.slice(0, matches.index) + replacement + value.slice(matchValueName.lastIndex);
          matchValueName.lastIndex -= matches[0].length - replacement.length;
        }
      }
      return value;
    };
    module2.exports = replaceValueSymbols;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/replaceSymbols.js
var require_replaceSymbols = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/replaceSymbols.js"(exports2, module2) {
    var replaceValueSymbols = require_replaceValueSymbols();
    var replaceSymbols = (css, replacements) => {
      css.walk((node) => {
        if (node.type === "decl" && node.value) {
          node.value = replaceValueSymbols(node.value.toString(), replacements);
        } else if (node.type === "rule" && node.selector) {
          node.selector = replaceValueSymbols(node.selector.toString(), replacements);
        } else if (node.type === "atrule" && node.params) {
          node.params = replaceValueSymbols(node.params.toString(), replacements);
        }
      });
    };
    module2.exports = replaceSymbols;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/extractICSS.js
var require_extractICSS = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/extractICSS.js"(exports2, module2) {
    var importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
    var balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
    var getDeclsObject = (rule) => {
      const object = {};
      rule.walkDecls((decl) => {
        const before = decl.raws.before ? decl.raws.before.trim() : "";
        object[before + decl.prop] = decl.value;
      });
      return object;
    };
    var extractICSS = (css, removeRules = true, mode = "auto") => {
      const icssImports = {};
      const icssExports = {};
      function addImports(node, path) {
        const unquoted = path.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(icssImports[unquoted] || {}, getDeclsObject(node));
        if (removeRules) {
          node.remove();
        }
      }
      function addExports(node) {
        Object.assign(icssExports, getDeclsObject(node));
        if (removeRules) {
          node.remove();
        }
      }
      css.each((node) => {
        if (node.type === "rule" && mode !== "at-rule") {
          if (node.selector.slice(0, 7) === ":import") {
            const matches = importPattern.exec(node.selector);
            if (matches) {
              addImports(node, matches[1]);
            }
          }
          if (node.selector === ":export") {
            addExports(node);
          }
        }
        if (node.type === "atrule" && mode !== "rule") {
          if (node.name === "icss-import") {
            const matches = balancedQuotes.exec(node.params);
            if (matches) {
              addImports(node, matches[1]);
            }
          }
          if (node.name === "icss-export") {
            addExports(node);
          }
        }
      });
      return { icssImports, icssExports };
    };
    module2.exports = extractICSS;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/createICSSRules.js
var require_createICSSRules = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/createICSSRules.js"(exports2, module2) {
    var createImports = (imports, postcss, mode = "rule") => {
      return Object.keys(imports).map((path) => {
        const aliases = imports[path];
        const declarations = Object.keys(aliases).map((key) => postcss.decl({
          prop: key,
          value: aliases[key],
          raws: { before: "\n  " }
        }));
        const hasDeclarations = declarations.length > 0;
        const rule = mode === "rule" ? postcss.rule({
          selector: `:import('${path}')`,
          raws: { after: hasDeclarations ? "\n" : "" }
        }) : postcss.atRule({
          name: "icss-import",
          params: `'${path}'`,
          raws: { after: hasDeclarations ? "\n" : "" }
        });
        if (hasDeclarations) {
          rule.append(declarations);
        }
        return rule;
      });
    };
    var createExports = (exports3, postcss, mode = "rule") => {
      const declarations = Object.keys(exports3).map((key) => postcss.decl({
        prop: key,
        value: exports3[key],
        raws: { before: "\n  " }
      }));
      if (declarations.length === 0) {
        return [];
      }
      const rule = mode === "rule" ? postcss.rule({
        selector: `:export`,
        raws: { after: "\n" }
      }) : postcss.atRule({
        name: "icss-export",
        raws: { after: "\n" }
      });
      rule.append(declarations);
      return [rule];
    };
    var createICSSRules = (imports, exports3, postcss, mode) => [
      ...createImports(imports, postcss, mode),
      ...createExports(exports3, postcss, mode)
    ];
    module2.exports = createICSSRules;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/index.js
var require_src2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/icss-utils-virtual-f00f392d0a/0/cache/icss-utils-npm-5.1.0-8d8c062d07-5c324d2835.zip/node_modules/icss-utils/src/index.js"(exports2, module2) {
    var replaceValueSymbols = require_replaceValueSymbols();
    var replaceSymbols = require_replaceSymbols();
    var extractICSS = require_extractICSS();
    var createICSSRules = require_createICSSRules();
    module2.exports = {
      replaceValueSymbols,
      replaceSymbols,
      extractICSS,
      createICSSRules
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-local-by-default-virtual-eae9292044/0/cache/postcss-modules-local-by-default-npm-4.0.0-794014f0a5-6cf570badc.zip/node_modules/postcss-modules-local-by-default/src/index.js
var require_src3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-local-by-default-virtual-eae9292044/0/cache/postcss-modules-local-by-default-npm-4.0.0-794014f0a5-6cf570badc.zip/node_modules/postcss-modules-local-by-default/src/index.js"(exports2, module2) {
    "use strict";
    var selectorParser = require_dist();
    var valueParser = require_lib5();
    var { extractICSS } = require_src2();
    var isSpacing = (node) => node.type === "combinator" && node.value === " ";
    function normalizeNodeArray(nodes) {
      const array = [];
      nodes.forEach((x) => {
        if (Array.isArray(x)) {
          normalizeNodeArray(x).forEach((item) => {
            array.push(item);
          });
        } else if (x) {
          array.push(x);
        }
      });
      if (array.length > 0 && isSpacing(array[array.length - 1])) {
        array.pop();
      }
      return array;
    }
    function localizeNode(rule, mode, localAliasMap) {
      const transform = (node, context) => {
        if (context.ignoreNextSpacing && !isSpacing(node)) {
          throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
        }
        if (context.enforceNoSpacing && isSpacing(node)) {
          throw new Error("Missing whitespace before " + context.enforceNoSpacing);
        }
        let newNodes;
        switch (node.type) {
          case "root": {
            let resultingGlobal;
            context.hasPureGlobals = false;
            newNodes = node.nodes.map((n) => {
              const nContext = {
                global: context.global,
                lastWasSpacing: true,
                hasLocals: false,
                explicit: false
              };
              n = transform(n, nContext);
              if (typeof resultingGlobal === "undefined") {
                resultingGlobal = nContext.global;
              } else if (resultingGlobal !== nContext.global) {
                throw new Error('Inconsistent rule global/local result in rule "' + node + '" (multiple selectors must result in the same mode for the rule)');
              }
              if (!nContext.hasLocals) {
                context.hasPureGlobals = true;
              }
              return n;
            });
            context.global = resultingGlobal;
            node.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "selector": {
            newNodes = node.map((childNode) => transform(childNode, context));
            node = node.clone();
            node.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "combinator": {
            if (isSpacing(node)) {
              if (context.ignoreNextSpacing) {
                context.ignoreNextSpacing = false;
                context.lastWasSpacing = false;
                context.enforceNoSpacing = false;
                return null;
              }
              context.lastWasSpacing = true;
              return node;
            }
            break;
          }
          case "pseudo": {
            let childContext;
            const isNested = !!node.length;
            const isScoped = node.value === ":local" || node.value === ":global";
            const isImportExport = node.value === ":import" || node.value === ":export";
            if (isImportExport) {
              context.hasLocals = true;
            } else if (isNested) {
              if (isScoped) {
                if (node.nodes.length === 0) {
                  throw new Error(`${node.value}() can't be empty`);
                }
                if (context.inside) {
                  throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
                }
                childContext = {
                  global: node.value === ":global",
                  inside: node.value,
                  hasLocals: false,
                  explicit: true
                };
                newNodes = node.map((childNode) => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
                if (newNodes.length) {
                  const { before, after } = node.spaces;
                  const first = newNodes[0];
                  const last = newNodes[newNodes.length - 1];
                  first.spaces = { before, after: first.spaces.after };
                  last.spaces = { before: last.spaces.before, after };
                }
                node = newNodes;
                break;
              } else {
                childContext = {
                  global: context.global,
                  inside: context.inside,
                  lastWasSpacing: true,
                  hasLocals: false,
                  explicit: context.explicit
                };
                newNodes = node.map((childNode) => transform(childNode, childContext));
                node = node.clone();
                node.nodes = normalizeNodeArray(newNodes);
                if (childContext.hasLocals) {
                  context.hasLocals = true;
                }
              }
              break;
            } else if (isScoped) {
              if (context.inside) {
                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
              }
              const addBackSpacing = !!node.spaces.before;
              context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;
              context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;
              context.global = node.value === ":global";
              context.explicit = true;
              return addBackSpacing ? selectorParser.combinator({ value: " " }) : null;
            }
            break;
          }
          case "id":
          case "class": {
            if (!node.value) {
              throw new Error("Invalid class or id selector syntax");
            }
            if (context.global) {
              break;
            }
            const isImportedValue = localAliasMap.has(node.value);
            const isImportedWithExplicitScope = isImportedValue && context.explicit;
            if (!isImportedValue || isImportedWithExplicitScope) {
              const innerNode = node.clone();
              innerNode.spaces = { before: "", after: "" };
              node = selectorParser.pseudo({
                value: ":local",
                nodes: [innerNode],
                spaces: node.spaces
              });
              context.hasLocals = true;
            }
            break;
          }
        }
        context.lastWasSpacing = false;
        context.ignoreNextSpacing = false;
        context.enforceNoSpacing = false;
        return node;
      };
      const rootContext = {
        global: mode === "global",
        hasPureGlobals: false
      };
      rootContext.selector = selectorParser((root) => {
        transform(root, rootContext);
      }).processSync(rule, { updateSelector: false, lossless: true });
      return rootContext;
    }
    function localizeDeclNode(node, context) {
      switch (node.type) {
        case "word":
          if (context.localizeNextItem) {
            if (!context.localAliasMap.has(node.value)) {
              node.value = ":local(" + node.value + ")";
              context.localizeNextItem = false;
            }
          }
          break;
        case "function":
          if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === "url") {
            node.nodes.map((nestedNode) => {
              if (nestedNode.type !== "string" && nestedNode.type !== "word") {
                return;
              }
              let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);
              switch (nestedNode.type) {
                case "string":
                  if (nestedNode.quote === "'") {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                  }
                  if (nestedNode.quote === '"') {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                  }
                  break;
                case "word":
                  newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                  break;
              }
              nestedNode.value = newUrl;
            });
          }
          break;
      }
      return node;
    }
    function isWordAFunctionArgument(wordNode, functionNode) {
      return functionNode ? functionNode.nodes.some((functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;
    }
    function localizeDeclarationValues(localize, declaration, context) {
      const valueNodes = valueParser(declaration.value);
      valueNodes.walk((node, index, nodes) => {
        const subContext = {
          options: context.options,
          global: context.global,
          localizeNextItem: localize && !context.global,
          localAliasMap: context.localAliasMap
        };
        nodes[index] = localizeDeclNode(node, subContext);
      });
      declaration.value = valueNodes.toString();
    }
    function localizeDeclaration(declaration, context) {
      const isAnimation = /animation$/i.test(declaration.prop);
      if (isAnimation) {
        const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
        const animationKeywords = {
          $alternate: 1,
          "$alternate-reverse": 1,
          $backwards: 1,
          $both: 1,
          $ease: 1,
          "$ease-in": 1,
          "$ease-in-out": 1,
          "$ease-out": 1,
          $forwards: 1,
          $infinite: 1,
          $linear: 1,
          $none: Infinity,
          $normal: 1,
          $paused: 1,
          $reverse: 1,
          $running: 1,
          "$step-end": 1,
          "$step-start": 1,
          $initial: Infinity,
          $inherit: Infinity,
          $unset: Infinity
        };
        const didParseAnimationName = false;
        let parsedAnimationKeywords = {};
        let stepsFunctionNode = null;
        const valueNodes = valueParser(declaration.value).walk((node) => {
          if (node.type === "div") {
            parsedAnimationKeywords = {};
          }
          if (node.type === "function" && node.value.toLowerCase() === "steps") {
            stepsFunctionNode = node;
          }
          const value = node.type === "word" && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;
          let shouldParseAnimationName = false;
          if (!didParseAnimationName && value && validIdent.test(value)) {
            if ("$" + value in animationKeywords) {
              parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
              shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
            } else {
              shouldParseAnimationName = true;
            }
          }
          const subContext = {
            options: context.options,
            global: context.global,
            localizeNextItem: shouldParseAnimationName && !context.global,
            localAliasMap: context.localAliasMap
          };
          return localizeDeclNode(node, subContext);
        });
        declaration.value = valueNodes.toString();
        return;
      }
      const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
      if (isAnimationName) {
        return localizeDeclarationValues(true, declaration, context);
      }
      const hasUrl = /url\(/i.test(declaration.value);
      if (hasUrl) {
        return localizeDeclarationValues(false, declaration, context);
      }
    }
    module2.exports = (options = {}) => {
      if (options && options.mode && options.mode !== "global" && options.mode !== "local" && options.mode !== "pure") {
        throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
      }
      const pureMode = options && options.mode === "pure";
      const globalMode = options && options.mode === "global";
      return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare() {
          const localAliasMap = new Map();
          return {
            Once(root) {
              const { icssImports } = extractICSS(root, false);
              Object.keys(icssImports).forEach((key) => {
                Object.keys(icssImports[key]).forEach((prop) => {
                  localAliasMap.set(prop, icssImports[key][prop]);
                });
              });
              root.walkAtRules((atRule) => {
                if (/keyframes$/i.test(atRule.name)) {
                  const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(atRule.params);
                  const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(atRule.params);
                  let globalKeyframes = globalMode;
                  if (globalMatch) {
                    if (pureMode) {
                      throw atRule.error("@keyframes :global(...) is not allowed in pure mode");
                    }
                    atRule.params = globalMatch[1];
                    globalKeyframes = true;
                  } else if (localMatch) {
                    atRule.params = localMatch[0];
                    globalKeyframes = false;
                  } else if (!globalMode) {
                    if (atRule.params && !localAliasMap.has(atRule.params)) {
                      atRule.params = ":local(" + atRule.params + ")";
                    }
                  }
                  atRule.walkDecls((declaration) => {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options,
                      global: globalKeyframes
                    });
                  });
                } else if (atRule.nodes) {
                  atRule.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options,
                        global: globalMode
                      });
                    }
                  });
                }
              });
              root.walkRules((rule) => {
                if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                  return;
                }
                const context = localizeNode(rule, options.mode, localAliasMap);
                context.options = options;
                context.localAliasMap = localAliasMap;
                if (pureMode && context.hasPureGlobals) {
                  throw rule.error('Selector "' + rule.selector + '" is not pure (pure selectors must contain at least one local class or id)');
                }
                rule.selector = context.selector;
                if (rule.nodes) {
                  rule.nodes.forEach((declaration) => localizeDeclaration(declaration, context));
                }
              });
            }
          };
        }
      };
    };
    module2.exports.postcss = true;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-extract-imports-virtual-ed8ac3bf09/0/cache/postcss-modules-extract-imports-npm-3.0.0-619311282d-4b65f2f138.zip/node_modules/postcss-modules-extract-imports/src/topologicalSort.js
var require_topologicalSort = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-extract-imports-virtual-ed8ac3bf09/0/cache/postcss-modules-extract-imports-npm-3.0.0-619311282d-4b65f2f138.zip/node_modules/postcss-modules-extract-imports/src/topologicalSort.js"(exports2, module2) {
    var PERMANENT_MARKER = 2;
    var TEMPORARY_MARKER = 1;
    function createError(node, graph) {
      const er = new Error("Nondeterministic import's order");
      const related = graph[node];
      const relatedNode = related.find((relatedNode2) => graph[relatedNode2].indexOf(node) > -1);
      er.nodes = [node, relatedNode];
      return er;
    }
    function walkGraph(node, graph, state, result, strict) {
      if (state[node] === PERMANENT_MARKER) {
        return;
      }
      if (state[node] === TEMPORARY_MARKER) {
        if (strict) {
          return createError(node, graph);
        }
        return;
      }
      state[node] = TEMPORARY_MARKER;
      const children = graph[node];
      const length = children.length;
      for (let i = 0; i < length; ++i) {
        const error = walkGraph(children[i], graph, state, result, strict);
        if (error instanceof Error) {
          return error;
        }
      }
      state[node] = PERMANENT_MARKER;
      result.push(node);
    }
    function topologicalSort(graph, strict) {
      const result = [];
      const state = {};
      const nodes = Object.keys(graph);
      const length = nodes.length;
      for (let i = 0; i < length; ++i) {
        const er = walkGraph(nodes[i], graph, state, result, strict);
        if (er instanceof Error) {
          return er;
        }
      }
      return result;
    }
    module2.exports = topologicalSort;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-extract-imports-virtual-ed8ac3bf09/0/cache/postcss-modules-extract-imports-npm-3.0.0-619311282d-4b65f2f138.zip/node_modules/postcss-modules-extract-imports/src/index.js
var require_src4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-extract-imports-virtual-ed8ac3bf09/0/cache/postcss-modules-extract-imports-npm-3.0.0-619311282d-4b65f2f138.zip/node_modules/postcss-modules-extract-imports/src/index.js"(exports2, module2) {
    var topologicalSort = require_topologicalSort();
    var matchImports = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
    var icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
    var VISITED_MARKER = 1;
    function addImportToGraph(importId, parentId, graph, visited) {
      const siblingsId = parentId + "_siblings";
      const visitedId = parentId + "_" + importId;
      if (visited[visitedId] !== VISITED_MARKER) {
        if (!Array.isArray(visited[siblingsId])) {
          visited[siblingsId] = [];
        }
        const siblings = visited[siblingsId];
        if (Array.isArray(graph[importId])) {
          graph[importId] = graph[importId].concat(siblings);
        } else {
          graph[importId] = siblings.slice();
        }
        visited[visitedId] = VISITED_MARKER;
        siblings.push(importId);
      }
    }
    module2.exports = (options = {}) => {
      let importIndex = 0;
      const createImportedName = typeof options.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options.createImportedName;
      const failOnWrongOrder = options.failOnWrongOrder;
      return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare() {
          const graph = {};
          const visited = {};
          const existingImports = {};
          const importDecls = {};
          const imports = {};
          return {
            Once(root, postcss) {
              root.walkRules((rule) => {
                const matches = icssImport.exec(rule.selector);
                if (matches) {
                  const [, doubleQuotePath, singleQuotePath] = matches;
                  const importPath = doubleQuotePath || singleQuotePath;
                  addImportToGraph(importPath, "root", graph, visited);
                  existingImports[importPath] = rule;
                }
              });
              root.walkDecls(/^composes$/, (declaration) => {
                const matches = declaration.value.match(matchImports);
                if (!matches) {
                  return;
                }
                let tmpSymbols;
                let [
                  ,
                  symbols,
                  doubleQuotePath,
                  singleQuotePath,
                  global2
                ] = matches;
                if (global2) {
                  tmpSymbols = symbols.split(/\s+/).map((s) => `global(${s})`);
                } else {
                  const importPath = doubleQuotePath || singleQuotePath;
                  let parent = declaration.parent;
                  let parentIndexes = "";
                  while (parent.type !== "root") {
                    parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                    parent = parent.parent;
                  }
                  const { selector } = declaration.parent;
                  const parentRule = `_${parentIndexes}${selector}`;
                  addImportToGraph(importPath, parentRule, graph, visited);
                  importDecls[importPath] = declaration;
                  imports[importPath] = imports[importPath] || {};
                  tmpSymbols = symbols.split(/\s+/).map((s) => {
                    if (!imports[importPath][s]) {
                      imports[importPath][s] = createImportedName(s, importPath);
                    }
                    return imports[importPath][s];
                  });
                }
                declaration.value = tmpSymbols.join(" ");
              });
              const importsOrder = topologicalSort(graph, failOnWrongOrder);
              if (importsOrder instanceof Error) {
                const importPath = importsOrder.nodes.find((importPath2) => importDecls.hasOwnProperty(importPath2));
                const decl = importDecls[importPath];
                throw decl.error("Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".", {
                  plugin: "postcss-modules-extract-imports",
                  word: "composes"
                });
              }
              let lastImportRule;
              importsOrder.forEach((path) => {
                const importedSymbols = imports[path];
                let rule = existingImports[path];
                if (!rule && importedSymbols) {
                  rule = postcss.rule({
                    selector: `:import("${path}")`,
                    raws: { after: "\n" }
                  });
                  if (lastImportRule) {
                    root.insertAfter(lastImportRule, rule);
                  } else {
                    root.prepend(rule);
                  }
                }
                lastImportRule = rule;
                if (!importedSymbols) {
                  return;
                }
                Object.keys(importedSymbols).forEach((importedSymbol) => {
                  rule.append(postcss.decl({
                    value: importedSymbol,
                    prop: importedSymbols[importedSymbol],
                    raws: { before: "\n  " }
                  }));
                });
              });
            }
          };
        }
      };
    };
    module2.exports.postcss = true;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-scope-virtual-23e05bded8/0/cache/postcss-modules-scope-npm-3.0.0-0678040a26-330b9398db.zip/node_modules/postcss-modules-scope/src/index.js
var require_src5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-scope-virtual-23e05bded8/0/cache/postcss-modules-scope-npm-3.0.0-0678040a26-330b9398db.zip/node_modules/postcss-modules-scope/src/index.js"(exports2, module2) {
    "use strict";
    var selectorParser = require_dist();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function getSingleLocalNamesForComposes(root) {
      return root.nodes.map((node) => {
        if (node.type !== "selector" || node.nodes.length !== 1) {
          throw new Error(`composition is only allowed when selector is single :local class name not in "${root}"`);
        }
        node = node.nodes[0];
        if (node.type !== "pseudo" || node.value !== ":local" || node.nodes.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        node = node.first;
        if (node.type !== "selector" || node.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        node = node.first;
        if (node.type !== "class") {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
        }
        return node.value;
      });
    }
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var unescapeRegExp = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig");
    function unescape2(str) {
      return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {
        const high = "0x" + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      });
    }
    var plugin = (options = {}) => {
      const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;
      const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;
      const exportGlobals = options && options.exportGlobals;
      return {
        postcssPlugin: "postcss-modules-scope",
        Once(root, { rule }) {
          const exports3 = Object.create(null);
          function exportScopedName(name, rawName) {
            const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css);
            const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css);
            const { key, value } = exportEntry;
            exports3[key] = exports3[key] || [];
            if (exports3[key].indexOf(value) < 0) {
              exports3[key].push(value);
            }
            return scopedName;
          }
          function localizeNode(node) {
            switch (node.type) {
              case "selector":
                node.nodes = node.map(localizeNode);
                return node;
              case "class":
                return selectorParser.className({
                  value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)
                });
              case "id": {
                return selectorParser.id({
                  value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)
                });
              }
            }
            throw new Error(`${node.type} ("${node}") is not allowed in a :local block`);
          }
          function traverseNode(node) {
            switch (node.type) {
              case "pseudo":
                if (node.value === ":local") {
                  if (node.nodes.length !== 1) {
                    throw new Error('Unexpected comma (",") in :local block');
                  }
                  const selector = localizeNode(node.first, node.spaces);
                  selector.first.spaces = node.spaces;
                  const nextNode = node.next();
                  if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector.last.value)) {
                    selector.last.spaces.after = " ";
                  }
                  node.replaceWith(selector);
                  return;
                }
              case "root":
              case "selector": {
                node.each(traverseNode);
                break;
              }
              case "id":
              case "class":
                if (exportGlobals) {
                  exports3[node.value] = [node.value];
                }
                break;
            }
            return node;
          }
          const importedNames = {};
          root.walkRules(/^:import\(.+\)$/, (rule2) => {
            rule2.walkDecls((decl) => {
              importedNames[decl.prop] = true;
            });
          });
          root.walkRules((rule2) => {
            let parsedSelector = selectorParser().astSync(rule2);
            rule2.selector = traverseNode(parsedSelector.clone()).toString();
            rule2.walkDecls(/composes|compose-with/i, (decl) => {
              const localNames = getSingleLocalNamesForComposes(parsedSelector);
              const classes = decl.value.split(/\s+/);
              classes.forEach((className) => {
                const global2 = /^global\(([^)]+)\)$/.exec(className);
                if (global2) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(global2[1]);
                  });
                } else if (hasOwnProperty.call(importedNames, className)) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(className);
                  });
                } else if (hasOwnProperty.call(exports3, className)) {
                  localNames.forEach((exportedName) => {
                    exports3[className].forEach((item) => {
                      exports3[exportedName].push(item);
                    });
                  });
                } else {
                  throw decl.error(`referenced class name "${className}" in ${decl.prop} not found`);
                }
              });
              decl.remove();
            });
            rule2.walkDecls((decl) => {
              if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                return;
              }
              let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
              tokens = tokens.map((token, idx) => {
                if (idx === 0 || tokens[idx - 1] === ",") {
                  let result = token;
                  const localMatch = /:local\s*\((.+?)\)/.exec(token);
                  if (localMatch) {
                    const input = localMatch.input;
                    const matchPattern = localMatch[0];
                    const matchVal = localMatch[1];
                    const newVal = exportScopedName(matchVal);
                    result = input.replace(matchPattern, newVal);
                  } else {
                    return token;
                  }
                  return result;
                } else {
                  return token;
                }
              });
              decl.value = tokens.join("");
            });
          });
          root.walkAtRules(/keyframes$/i, (atRule) => {
            const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
            if (!localMatch) {
              return;
            }
            atRule.params = exportScopedName(localMatch[1]);
          });
          const exportedNames = Object.keys(exports3);
          if (exportedNames.length > 0) {
            const exportRule = rule({ selector: ":export" });
            exportedNames.forEach((exportedName) => exportRule.append({
              prop: exportedName,
              value: exports3[exportedName].join(" "),
              raws: { before: "\n  " }
            }));
            root.append(exportRule);
          }
        }
      };
    };
    plugin.postcss = true;
    plugin.generateScopedName = function(name, path) {
      const sanitisedPath = path.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
      return `_${sanitisedPath}__${name}`.trim();
    };
    plugin.generateExportEntry = function(name, scopedName) {
      return {
        key: unescape2(name),
        value: unescape2(scopedName)
      };
    };
    module2.exports = plugin;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-values-virtual-23c39cdcef/0/cache/postcss-modules-values-npm-4.0.0-63d7ec543a-f7f2cdf14a.zip/node_modules/postcss-modules-values/src/index.js
var require_src6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-values-virtual-23c39cdcef/0/cache/postcss-modules-values-npm-4.0.0-63d7ec543a-f7f2cdf14a.zip/node_modules/postcss-modules-values/src/index.js"(exports2, module2) {
    "use strict";
    var ICSSUtils = require_src2();
    var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
    var matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
    var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
    module2.exports = (options) => {
      let importIndex = 0;
      const createImportedName = options && options.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
      return {
        postcssPlugin: "postcss-modules-values",
        prepare(result) {
          const importAliases = [];
          const definitions = {};
          return {
            Once(root, postcss) {
              root.walkAtRules(/value/i, (atRule) => {
                const matches = atRule.params.match(matchImports);
                if (matches) {
                  let [, aliases, path] = matches;
                  if (definitions[path]) {
                    path = definitions[path];
                  }
                  const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias) => {
                    const tokens = matchImport.exec(alias);
                    if (tokens) {
                      const [, theirName, myName = theirName] = tokens;
                      const importedName = createImportedName(myName);
                      definitions[myName] = importedName;
                      return { theirName, importedName };
                    } else {
                      throw new Error(`@import statement "${alias}" is invalid!`);
                    }
                  });
                  importAliases.push({ path, imports });
                  atRule.remove();
                  return;
                }
                if (atRule.params.indexOf("@value") !== -1) {
                  result.warn("Invalid value definition: " + atRule.params);
                }
                let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);
                const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                if (normalizedValue.length === 0) {
                  result.warn("Invalid value definition: " + atRule.params);
                  atRule.remove();
                  return;
                }
                let isOnlySpace = /^\s+$/.test(normalizedValue);
                if (!isOnlySpace) {
                  value = value.trim();
                }
                definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);
                atRule.remove();
              });
              if (!Object.keys(definitions).length) {
                return;
              }
              ICSSUtils.replaceSymbols(root, definitions);
              const exportDeclarations = Object.keys(definitions).map((key) => postcss.decl({
                value: definitions[key],
                prop: key,
                raws: { before: "\n  " }
              }));
              if (exportDeclarations.length > 0) {
                const exportRule = postcss.rule({
                  selector: ":export",
                  raws: { after: "\n" }
                });
                exportRule.append(exportDeclarations);
                root.prepend(exportRule);
              }
              importAliases.reverse().forEach(({ path, imports }) => {
                const importRule = postcss.rule({
                  selector: `:import(${path})`,
                  raws: { after: "\n" }
                });
                imports.forEach(({ theirName, importedName }) => {
                  importRule.append({
                    value: theirName,
                    prop: importedName,
                    raws: { before: "\n  " }
                  });
                });
                root.prepend(importRule);
              });
            }
          };
        }
      };
    };
    module2.exports.postcss = true;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/behaviours.js
var require_behaviours = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/behaviours.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.behaviours = void 0;
    exports2.getDefaultPlugins = getDefaultPlugins;
    exports2.isValidBehaviour = isValidBehaviour;
    var _postcssModulesLocalByDefault = require_src3();
    var _postcssModulesLocalByDefault2 = _interopRequireDefault(_postcssModulesLocalByDefault);
    var _postcssModulesExtractImports = require_src4();
    var _postcssModulesExtractImports2 = _interopRequireDefault(_postcssModulesExtractImports);
    var _postcssModulesScope = require_src5();
    var _postcssModulesScope2 = _interopRequireDefault(_postcssModulesScope);
    var _postcssModulesValues = require_src6();
    var _postcssModulesValues2 = _interopRequireDefault(_postcssModulesValues);
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    var behaviours = exports2.behaviours = {
      LOCAL: "local",
      GLOBAL: "global"
    };
    function getDefaultPlugins({
      behaviour,
      generateScopedName,
      exportGlobals
    }) {
      const scope = (0, _postcssModulesScope2.default)({ generateScopedName, exportGlobals });
      const plugins = {
        [behaviours.LOCAL]: [_postcssModulesValues2.default, _postcssModulesLocalByDefault2.default, _postcssModulesExtractImports2.default, scope],
        [behaviours.GLOBAL]: [_postcssModulesValues2.default, _postcssModulesExtractImports2.default, scope]
      };
      return plugins[behaviour];
    }
    function isValidBehaviour(behaviour) {
      return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/index.js
var require_build = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/__virtual__/postcss-modules-virtual-2abbadce33/0/cache/postcss-modules-npm-4.2.2-ff2872c012-9e8444dfb4.zip/node_modules/postcss-modules/build/index.js"(exports2, module2) {
    "use strict";
    var _postcss = require_postcss();
    var _postcss2 = _interopRequireDefault(_postcss);
    var _lodash = require_lodash();
    var _lodash2 = _interopRequireDefault(_lodash);
    var _genericNames = require_generic_names();
    var _genericNames2 = _interopRequireDefault(_genericNames);
    var _unquote = require_unquote();
    var _unquote2 = _interopRequireDefault(_unquote);
    var _parser = require_parser3();
    var _parser2 = _interopRequireDefault(_parser);
    var _loader = require_loader();
    var _loader2 = _interopRequireDefault(_loader);
    var _generateScopedName = require_generateScopedName();
    var _generateScopedName2 = _interopRequireDefault(_generateScopedName);
    var _saveJSON = require_saveJSON();
    var _saveJSON2 = _interopRequireDefault(_saveJSON);
    var _behaviours = require_behaviours();
    function _interopRequireDefault(obj2) {
      return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
    }
    function _asyncToGenerator(fn) {
      return function() {
        var gen = fn.apply(this, arguments);
        return new Promise(function(resolve, reject) {
          function step(key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              return Promise.resolve(value).then(function(value2) {
                step("next", value2);
              }, function(err) {
                step("throw", err);
              });
            }
          }
          return step("next");
        });
      };
    }
    var PLUGIN_NAME = "postcss-modules";
    function getDefaultScopeBehaviour(opts) {
      if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {
        return opts.scopeBehaviour;
      }
      return _behaviours.behaviours.LOCAL;
    }
    function getScopedNameGenerator(opts) {
      const scopedNameGenerator = opts.generateScopedName || _generateScopedName2.default;
      if (typeof scopedNameGenerator === "function")
        return scopedNameGenerator;
      return (0, _genericNames2.default)(scopedNameGenerator, {
        context: process.cwd(),
        hashPrefix: opts.hashPrefix
      });
    }
    function getLoader(opts, plugins) {
      const root = typeof opts.root === "undefined" ? "/" : opts.root;
      return typeof opts.Loader === "function" ? new opts.Loader(root, plugins) : new _loader2.default(root, plugins);
    }
    function isGlobalModule(globalModules, inputFile) {
      return globalModules.some((regex) => inputFile.match(regex));
    }
    function getDefaultPluginsList(opts, inputFile) {
      const globalModulesList = opts.globalModulePaths || null;
      const exportGlobals = opts.exportGlobals || false;
      const defaultBehaviour = getDefaultScopeBehaviour(opts);
      const generateScopedName = getScopedNameGenerator(opts);
      if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
        return (0, _behaviours.getDefaultPlugins)({
          behaviour: _behaviours.behaviours.GLOBAL,
          generateScopedName,
          exportGlobals
        });
      }
      return (0, _behaviours.getDefaultPlugins)({
        behaviour: defaultBehaviour,
        generateScopedName,
        exportGlobals
      });
    }
    function isOurPlugin(plugin) {
      return plugin.postcssPlugin === PLUGIN_NAME;
    }
    function dashesCamelCase(string) {
      return string.replace(/-+(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
    }
    module2.exports = (opts = {}) => {
      return {
        postcssPlugin: PLUGIN_NAME,
        OnceExit(css, { result }) {
          return _asyncToGenerator(function* () {
            const getJSON = opts.getJSON || _saveJSON2.default;
            const inputFile = css.source.input.file;
            const pluginList = getDefaultPluginsList(opts, inputFile);
            const resultPluginIndex = result.processor.plugins.findIndex(function(plugin) {
              return isOurPlugin(plugin);
            });
            if (resultPluginIndex === -1) {
              throw new Error("Plugin missing from options.");
            }
            const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);
            const loaderPlugins = [...earlierPlugins, ...pluginList];
            const loader = getLoader(opts, loaderPlugins);
            const fetcher = function fetcher2(file, relativeTo, depTrace) {
              const unquoteFile = (0, _unquote2.default)(file);
              const resolvedResult = typeof opts.resolve === "function" && opts.resolve(unquoteFile);
              const resolvedFile = resolvedResult instanceof Promise ? resolvedResult : Promise.resolve(resolvedResult);
              return resolvedFile.then(function(f) {
                return loader.fetch.call(loader, `"${f || unquoteFile}"`, relativeTo, depTrace);
              });
            };
            const parser = new _parser2.default(fetcher);
            yield (0, _postcss2.default)([...pluginList, parser.plugin()]).process(css, {
              from: inputFile
            });
            const out = loader.finalSource;
            if (out)
              css.prepend(out);
            if (opts.localsConvention) {
              const isFunc = typeof opts.localsConvention === "function";
              parser.exportTokens = Object.entries(parser.exportTokens).reduce(function(tokens, [className, value]) {
                if (isFunc) {
                  tokens[opts.localsConvention(className, value, inputFile)] = value;
                  return tokens;
                }
                switch (opts.localsConvention) {
                  case "camelCase":
                    tokens[className] = value;
                    tokens[(0, _lodash2.default)(className)] = value;
                    break;
                  case "camelCaseOnly":
                    tokens[(0, _lodash2.default)(className)] = value;
                    break;
                  case "dashes":
                    tokens[className] = value;
                    tokens[dashesCamelCase(className)] = value;
                    break;
                  case "dashesOnly":
                    tokens[dashesCamelCase(className)] = value;
                    break;
                }
                return tokens;
              }, {});
            }
            result.messages.push({
              type: "export",
              plugin: "postcss-modules",
              exportTokens: parser.exportTokens
            });
            return getJSON(css.source.input.file, parser.exportTokens, result.opts.to);
          })();
        }
      };
    };
    module2.exports.postcss = true;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-sfc-npm-3.2.4-e733ea4442-ca81b6ae51.zip/node_modules/@vue/compiler-sfc/dist/compiler-sfc.cjs.js
var require_compiler_sfc_cjs = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@vue-compiler-sfc-npm-3.2.4-e733ea4442-ca81b6ae51.zip/node_modules/@vue/compiler-sfc/dist/compiler-sfc.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CompilerDOM = require_compiler_dom();
    var sourceMap = require_source_map();
    var hash = require_hash_sum();
    var path = require("path");
    var compilerCore = require_compiler_core();
    var url = require("url");
    var shared = require_shared();
    var CompilerSSR = require_compiler_ssr_cjs();
    var postcss = require_postcss();
    var selectorParser = require_dist();
    var merge = require_merge_source_map();
    var MagicString = require_magic_string_cjs();
    var parser = require_lib();
    var estreeWalker = require_estree_walker();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var CompilerDOM__namespace = /* @__PURE__ */ _interopNamespace(CompilerDOM);
    var hash__default = /* @__PURE__ */ _interopDefaultLegacy(hash);
    var path__default = /* @__PURE__ */ _interopDefaultLegacy(path);
    var CompilerSSR__namespace = /* @__PURE__ */ _interopNamespace(CompilerSSR);
    var postcss__default = /* @__PURE__ */ _interopDefaultLegacy(postcss);
    var selectorParser__default = /* @__PURE__ */ _interopDefaultLegacy(selectorParser);
    var merge__default = /* @__PURE__ */ _interopDefaultLegacy(merge);
    var MagicString__default = /* @__PURE__ */ _interopDefaultLegacy(MagicString);
    var CSS_VARS_HELPER = `useCssVars`;
    var cssVarRE = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([^'"][^)]*))\s*\)/g;
    function genCssVarsFromList(vars, id, isProd) {
      return `{
  ${vars.map((key) => `"${genVarName(id, key, isProd)}": (${key})`).join(",\n  ")}
}`;
    }
    function genVarName(id, raw, isProd) {
      if (isProd) {
        return hash__default(id + raw);
      } else {
        return `${id}-${raw.replace(/([^\w-])/g, "_")}`;
      }
    }
    function parseCssVars(sfc) {
      const vars = [];
      sfc.styles.forEach((style) => {
        let match;
        const content = style.content.replace(/\/\*([\s\S]*?)\*\//g, "");
        while (match = cssVarRE.exec(content)) {
          const variable = match[1] || match[2] || match[3];
          if (!vars.includes(variable)) {
            vars.push(variable);
          }
        }
      });
      return vars;
    }
    var cssVarsPlugin = (opts) => {
      const { id, isProd } = opts;
      return {
        postcssPlugin: "vue-sfc-vars",
        Declaration(decl) {
          if (cssVarRE.test(decl.value)) {
            decl.value = decl.value.replace(cssVarRE, (_, $1, $2, $3) => {
              return `var(--${genVarName(id, $1 || $2 || $3, isProd)})`;
            });
          }
        }
      };
    };
    cssVarsPlugin.postcss = true;
    function genCssVarsCode(vars, bindings, id, isProd) {
      const varsExp = genCssVarsFromList(vars, id, isProd);
      const exp = CompilerDOM.createSimpleExpression(varsExp, false);
      const context = CompilerDOM.createTransformContext(CompilerDOM.createRoot([]), {
        prefixIdentifiers: true,
        inline: true,
        bindingMetadata: bindings.__isScriptSetup === false ? void 0 : bindings
      });
      const transformed = CompilerDOM.processExpression(exp, context);
      const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c) => {
        return typeof c === "string" ? c : c.content;
      }).join("");
      return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
    }
    function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd) {
      return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(cssVars, bindings, id, isProd)}}
const __setup__ = __default__.setup
__default__.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
    }
    function createCache(size = 500) {
      return new (require_lru_cache())(size);
    }
    var sourceToSFC = createCache();
    function parse3(source, { sourceMap: sourceMap2 = true, filename = "anonymous.vue", sourceRoot = "", pad = false, ignoreEmpty = true, compiler = CompilerDOM__namespace } = {}) {
      const sourceKey = source + sourceMap2 + filename + sourceRoot + pad + compiler.parse;
      const cache = sourceToSFC.get(sourceKey);
      if (cache) {
        return cache;
      }
      const descriptor = {
        filename,
        source,
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
        cssVars: [],
        slotted: false
      };
      const errors = [];
      const ast = compiler.parse(source, {
        isNativeTag: () => true,
        isPreTag: () => true,
        getTextMode: ({ tag, props }, parent) => {
          if (!parent && tag !== "template" || tag === "template" && props.some((p) => p.type === 6 && p.name === "lang" && p.value && p.value.content && p.value.content !== "html")) {
            return 2;
          } else {
            return 0;
          }
        },
        onError: (e) => {
          errors.push(e);
        }
      });
      ast.children.forEach((node) => {
        if (node.type !== 1) {
          return;
        }
        if (ignoreEmpty && node.tag !== "template" && isEmpty(node) && !hasSrc(node)) {
          return;
        }
        switch (node.tag) {
          case "template":
            if (!descriptor.template) {
              const templateBlock = descriptor.template = createBlock(node, source, false);
              templateBlock.ast = node;
              if (templateBlock.attrs.functional) {
                const err = new SyntaxError(`<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.`);
                err.loc = node.props.find((p) => p.name === "functional").loc;
                errors.push(err);
              }
            } else {
              errors.push(createDuplicateBlockError(node));
            }
            break;
          case "script":
            const scriptBlock = createBlock(node, source, pad);
            const isSetup = !!scriptBlock.attrs.setup;
            if (isSetup && !descriptor.scriptSetup) {
              descriptor.scriptSetup = scriptBlock;
              break;
            }
            if (!isSetup && !descriptor.script) {
              descriptor.script = scriptBlock;
              break;
            }
            errors.push(createDuplicateBlockError(node, isSetup));
            break;
          case "style":
            const styleBlock = createBlock(node, source, pad);
            if (styleBlock.attrs.vars) {
              errors.push(new SyntaxError(`<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`));
            }
            descriptor.styles.push(styleBlock);
            break;
          default:
            descriptor.customBlocks.push(createBlock(node, source, pad));
            break;
        }
      });
      if (descriptor.scriptSetup) {
        if (descriptor.scriptSetup.src) {
          errors.push(new SyntaxError(`<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`));
          descriptor.scriptSetup = null;
        }
        if (descriptor.script && descriptor.script.src) {
          errors.push(new SyntaxError(`<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`));
          descriptor.script = null;
        }
      }
      if (sourceMap2) {
        const genMap = (block) => {
          if (block && !block.src) {
            block.map = generateSourceMap(filename, source, block.content, sourceRoot, !pad || block.type === "template" ? block.loc.start.line - 1 : 0);
          }
        };
        genMap(descriptor.template);
        genMap(descriptor.script);
        descriptor.styles.forEach(genMap);
        descriptor.customBlocks.forEach(genMap);
      }
      descriptor.cssVars = parseCssVars(descriptor);
      const slottedRE = /(?:::v-|:)slotted\(/;
      descriptor.slotted = descriptor.styles.some((s) => s.scoped && slottedRE.test(s.content));
      const result = {
        descriptor,
        errors
      };
      sourceToSFC.set(sourceKey, result);
      return result;
    }
    function createDuplicateBlockError(node, isScriptSetup = false) {
      const err = new SyntaxError(`Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`);
      err.loc = node.loc;
      return err;
    }
    function createBlock(node, source, pad) {
      const type = node.tag;
      let { start, end } = node.loc;
      let content = "";
      if (node.children.length) {
        start = node.children[0].loc.start;
        end = node.children[node.children.length - 1].loc.end;
        content = source.slice(start.offset, end.offset);
      } else {
        const offset = node.loc.source.indexOf(`</`);
        if (offset > -1) {
          start = {
            line: start.line,
            column: start.column + offset,
            offset: start.offset + offset
          };
        }
        end = Object.assign({}, start);
      }
      const loc = {
        source: content,
        start,
        end
      };
      const attrs = {};
      const block = {
        type,
        content,
        loc,
        attrs
      };
      if (pad) {
        block.content = padContent(source, block, pad) + block.content;
      }
      node.props.forEach((p) => {
        if (p.type === 6) {
          attrs[p.name] = p.value ? p.value.content || true : true;
          if (p.name === "lang") {
            block.lang = p.value && p.value.content;
          } else if (p.name === "src") {
            block.src = p.value && p.value.content;
          } else if (type === "style") {
            if (p.name === "scoped") {
              block.scoped = true;
            } else if (p.name === "module") {
              block.module = attrs[p.name];
            }
          } else if (type === "script" && p.name === "setup") {
            block.setup = attrs.setup;
          }
        }
      });
      return block;
    }
    var splitRE = /\r?\n/g;
    var emptyRE = /^(?:\/\/)?\s*$/;
    var replaceRE = /./g;
    function generateSourceMap(filename, source, generated, sourceRoot, lineOffset) {
      const map = new sourceMap.SourceMapGenerator({
        file: filename.replace(/\\/g, "/"),
        sourceRoot: sourceRoot.replace(/\\/g, "/")
      });
      map.setSourceContent(filename, source);
      generated.split(splitRE).forEach((line, index) => {
        if (!emptyRE.test(line)) {
          const originalLine = index + 1 + lineOffset;
          const generatedLine = index + 1;
          for (let i = 0; i < line.length; i++) {
            if (!/\s/.test(line[i])) {
              map.addMapping({
                source: filename,
                original: {
                  line: originalLine,
                  column: i
                },
                generated: {
                  line: generatedLine,
                  column: i
                }
              });
            }
          }
        }
      });
      return JSON.parse(map.toString());
    }
    function padContent(content, block, pad) {
      content = content.slice(0, block.loc.start.offset);
      if (pad === "space") {
        return content.replace(replaceRE, " ");
      } else {
        const offset = content.split(splitRE).length;
        const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
        return Array(offset).join(padChar);
      }
    }
    function hasSrc(node) {
      return node.props.some((p) => {
        if (p.type !== 6) {
          return false;
        }
        return p.name === "src";
      });
    }
    function isEmpty(node) {
      return node.children.filter((child) => child.type !== 2 || child.content.trim() !== "").length === 0;
    }
    function isRelativeUrl(url2) {
      const firstChar = url2.charAt(0);
      return firstChar === "." || firstChar === "~" || firstChar === "@";
    }
    var externalRE = /^https?:\/\//;
    function isExternalUrl(url2) {
      return externalRE.test(url2);
    }
    var dataUrlRE = /^\s*data:/i;
    function isDataUrl(url2) {
      return dataUrlRE.test(url2);
    }
    function parseUrl(url2) {
      const firstChar = url2.charAt(0);
      if (firstChar === "~") {
        const secondChar = url2.charAt(1);
        url2 = url2.slice(secondChar === "/" ? 2 : 1);
      }
      return parseUriParts(url2);
    }
    function parseUriParts(urlString) {
      return url.parse(shared.isString(urlString) ? urlString : "", false, true);
    }
    var defaultAssetUrlOptions = {
      base: null,
      includeAbsolute: false,
      tags: {
        video: ["src", "poster"],
        source: ["src"],
        img: ["src"],
        image: ["xlink:href", "href"],
        use: ["xlink:href", "href"]
      }
    };
    var normalizeOptions = (options) => {
      if (Object.keys(options).some((key) => shared.isArray(options[key]))) {
        return Object.assign(Object.assign({}, defaultAssetUrlOptions), { tags: options });
      }
      return Object.assign(Object.assign({}, defaultAssetUrlOptions), options);
    };
    var createAssetUrlTransformWithOptions = (options) => {
      return (node, context) => transformAssetUrl(node, context, options);
    };
    var transformAssetUrl = (node, context, options = defaultAssetUrlOptions) => {
      if (node.type === 1) {
        if (!node.props.length) {
          return;
        }
        const tags = options.tags || defaultAssetUrlOptions.tags;
        const attrs = tags[node.tag];
        const wildCardAttrs = tags["*"];
        if (!attrs && !wildCardAttrs) {
          return;
        }
        const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
        node.props.forEach((attr, index) => {
          if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options.includeAbsolute && !isRelativeUrl(attr.value.content)) {
            return;
          }
          const url2 = parseUrl(attr.value.content);
          if (options.base && attr.value.content[0] === ".") {
            const base = parseUrl(options.base);
            const protocol = base.protocol || "";
            const host = base.host ? protocol + "//" + base.host : "";
            const basePath = base.path || "/";
            attr.value.content = host + (path__default.posix || path__default).join(basePath, url2.path + (url2.hash || ""));
            return;
          }
          const exp = getImportsExpressionExp(url2.path, url2.hash, attr.loc, context);
          node.props[index] = {
            type: 7,
            name: "bind",
            arg: compilerCore.createSimpleExpression(attr.name, true, attr.loc),
            exp,
            modifiers: [],
            loc: attr.loc
          };
        });
      }
    };
    function getImportsExpressionExp(path2, hash2, loc, context) {
      if (path2) {
        const existing = context.imports.find((i) => i.path === path2);
        if (existing) {
          return existing.exp;
        }
        const name = `_imports_${context.imports.length}`;
        const exp = compilerCore.createSimpleExpression(name, false, loc, 2);
        context.imports.push({ exp, path: path2 });
        if (hash2 && path2) {
          return context.hoist(compilerCore.createSimpleExpression(`${name} + '${hash2}'`, false, loc, 2));
        } else {
          return exp;
        }
      } else {
        return compilerCore.createSimpleExpression(`''`, false, loc, 2);
      }
    }
    var srcsetTags = ["img", "source"];
    var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
    var createSrcsetTransformWithOptions = (options) => {
      return (node, context) => transformSrcset(node, context, options);
    };
    var transformSrcset = (node, context, options = defaultAssetUrlOptions) => {
      if (node.type === 1) {
        if (srcsetTags.includes(node.tag) && node.props.length) {
          node.props.forEach((attr, index) => {
            if (attr.name === "srcset" && attr.type === 6) {
              if (!attr.value)
                return;
              const value = attr.value.content;
              if (!value)
                return;
              const imageCandidates = value.split(",").map((s) => {
                const [url2, descriptor] = s.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
                return { url: url2, descriptor };
              });
              for (let i = 0; i < imageCandidates.length; i++) {
                const { url: url2 } = imageCandidates[i];
                if (isDataUrl(url2)) {
                  imageCandidates[i + 1].url = url2 + "," + imageCandidates[i + 1].url;
                  imageCandidates.splice(i, 1);
                }
              }
              const hasQualifiedUrl = imageCandidates.some(({ url: url2 }) => {
                return !isExternalUrl(url2) && !isDataUrl(url2) && (options.includeAbsolute || isRelativeUrl(url2));
              });
              if (!hasQualifiedUrl) {
                return;
              }
              if (options.base) {
                const base = options.base;
                const set = [];
                imageCandidates.forEach(({ url: url2, descriptor }) => {
                  descriptor = descriptor ? ` ${descriptor}` : ``;
                  if (isRelativeUrl(url2)) {
                    set.push((path__default.posix || path__default).join(base, url2) + descriptor);
                  } else {
                    set.push(url2 + descriptor);
                  }
                });
                attr.value.content = set.join(", ");
                return;
              }
              const compoundExpression = compilerCore.createCompoundExpression([], attr.loc);
              imageCandidates.forEach(({ url: url2, descriptor }, index2) => {
                if (!isExternalUrl(url2) && !isDataUrl(url2) && (options.includeAbsolute || isRelativeUrl(url2))) {
                  const { path: path2 } = parseUrl(url2);
                  let exp;
                  if (path2) {
                    const existingImportsIndex = context.imports.findIndex((i) => i.path === path2);
                    if (existingImportsIndex > -1) {
                      exp = compilerCore.createSimpleExpression(`_imports_${existingImportsIndex}`, false, attr.loc, 2);
                    } else {
                      exp = compilerCore.createSimpleExpression(`_imports_${context.imports.length}`, false, attr.loc, 2);
                      context.imports.push({ exp, path: path2 });
                    }
                    compoundExpression.children.push(exp);
                  }
                } else {
                  const exp = compilerCore.createSimpleExpression(`"${url2}"`, false, attr.loc, 2);
                  compoundExpression.children.push(exp);
                }
                const isNotLast = imageCandidates.length - 1 > index2;
                if (descriptor && isNotLast) {
                  compoundExpression.children.push(` + ' ${descriptor}, ' + `);
                } else if (descriptor) {
                  compoundExpression.children.push(` + ' ${descriptor}'`);
                } else if (isNotLast) {
                  compoundExpression.children.push(` + ', ' + `);
                }
              });
              const hoisted = context.hoist(compoundExpression);
              hoisted.constType = 2;
              node.props[index] = {
                type: 7,
                name: "bind",
                arg: compilerCore.createSimpleExpression("srcset", true, attr.loc),
                exp: hoisted,
                modifiers: [],
                loc: attr.loc
              };
            }
          });
        }
      }
    };
    var hasWarned = {};
    function warnOnce(msg) {
      const isNodeProd = typeof process !== "undefined" && false;
      if (!isNodeProd && true && !hasWarned[msg]) {
        hasWarned[msg] = true;
        warn(msg);
      }
    }
    function warn(msg) {
      console.warn(`[1m[33m[@vue/compiler-sfc][0m[33m ${msg}[0m
`);
    }
    function warnExperimental(feature, url2) {
      if (typeof window !== "undefined") {
        return;
      }
      warnOnce(`${feature} is still an experimental proposal.
Follow its status at ${url2}.`);
      warnOnce(`When using experimental features,
it is recommended to pin your vue dependencies to exact versions to avoid breakage.`);
    }
    function preprocess({ source, filename, preprocessOptions }, preprocessor) {
      let res = "";
      let err = null;
      preprocessor.render(source, Object.assign({ filename }, preprocessOptions), (_err, _res) => {
        if (_err)
          err = _err;
        res = _res;
      });
      if (err)
        throw err;
      return res;
    }
    function compileTemplate(options) {
      const { preprocessLang, preprocessCustomRequire } = options;
      const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : require_consolidate2()[preprocessLang] : false;
      if (preprocessor) {
        try {
          return doCompileTemplate(Object.assign(Object.assign({}, options), { source: preprocess(options, preprocessor) }));
        } catch (e) {
          return {
            code: `export default function render() {}`,
            source: options.source,
            tips: [],
            errors: [e]
          };
        }
      } else if (preprocessLang) {
        return {
          code: `export default function render() {}`,
          source: options.source,
          tips: [
            `Component ${options.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
          ],
          errors: [
            `Component ${options.filename} uses lang ${preprocessLang} for template, however it is not installed.`
          ]
        };
      } else {
        return doCompileTemplate(options);
      }
    }
    function doCompileTemplate({ filename, id, scoped, slotted, inMap, source, ssr = false, ssrCssVars, isProd = false, compiler = ssr ? CompilerSSR__namespace : CompilerDOM__namespace, compilerOptions = {}, transformAssetUrls }) {
      const errors = [];
      const warnings = [];
      let nodeTransforms = [];
      if (shared.isObject(transformAssetUrls)) {
        const assetOptions = normalizeOptions(transformAssetUrls);
        nodeTransforms = [
          createAssetUrlTransformWithOptions(assetOptions),
          createSrcsetTransformWithOptions(assetOptions)
        ];
      } else if (transformAssetUrls !== false) {
        nodeTransforms = [transformAssetUrl, transformSrcset];
      }
      if (ssr && !ssrCssVars) {
        warnOnce(`compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.\`.`);
      }
      if (!id) {
        warnOnce(`compileTemplate now requires the \`id\` option.\`.`);
        id = "";
      }
      const shortId = id.replace(/^data-v-/, "");
      const longId = `data-v-${shortId}`;
      let { code, ast, preamble, map } = compiler.compile(source, Object.assign(Object.assign({ mode: "module", prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd) : "", scopeId: scoped ? longId : void 0, slotted }, compilerOptions), { nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []), filename, sourceMap: true, onError: (e) => errors.push(e), onWarn: (w) => warnings.push(w) }));
      if (inMap) {
        if (map) {
          map = mapLines(inMap, map);
        }
        if (errors.length) {
          patchErrors(errors, source, inMap);
        }
      }
      const tips = warnings.map((w) => {
        let msg = w.message;
        if (w.loc) {
          msg += `
${shared.generateCodeFrame(source, w.loc.start.offset, w.loc.end.offset)}`;
        }
        return msg;
      });
      return { code, ast, preamble, source, errors, tips, map };
    }
    function mapLines(oldMap, newMap) {
      if (!oldMap)
        return newMap;
      if (!newMap)
        return oldMap;
      const oldMapConsumer = new sourceMap.SourceMapConsumer(oldMap);
      const newMapConsumer = new sourceMap.SourceMapConsumer(newMap);
      const mergedMapGenerator = new sourceMap.SourceMapGenerator();
      newMapConsumer.eachMapping((m) => {
        if (m.originalLine == null) {
          return;
        }
        const origPosInOldMap = oldMapConsumer.originalPositionFor({
          line: m.originalLine,
          column: m.originalColumn
        });
        if (origPosInOldMap.source == null) {
          return;
        }
        mergedMapGenerator.addMapping({
          generated: {
            line: m.generatedLine,
            column: m.generatedColumn
          },
          original: {
            line: origPosInOldMap.line,
            column: m.originalColumn
          },
          source: origPosInOldMap.source,
          name: origPosInOldMap.name
        });
      });
      const generator = mergedMapGenerator;
      oldMapConsumer.sources.forEach((sourceFile) => {
        generator._sources.add(sourceFile);
        const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
        if (sourceContent != null) {
          mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
        }
      });
      generator._sourceRoot = oldMap.sourceRoot;
      generator._file = oldMap.file;
      return generator.toJSON();
    }
    function patchErrors(errors, source, inMap) {
      const originalSource = inMap.sourcesContent[0];
      const offset = originalSource.indexOf(source);
      const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
      errors.forEach((err) => {
        if (err.loc) {
          err.loc.start.line += lineOffset;
          err.loc.start.offset += offset;
          if (err.loc.end !== err.loc.start) {
            err.loc.end.line += lineOffset;
            err.loc.end.offset += offset;
          }
        }
      });
    }
    var trimPlugin = () => {
      return {
        postcssPlugin: "vue-sfc-trim",
        Once(root) {
          root.walk(({ type, raws }) => {
            if (type === "rule" || type === "atrule") {
              if (raws.before)
                raws.before = "\n";
              if ("after" in raws && raws.after)
                raws.after = "\n";
            }
          });
        }
      };
    };
    trimPlugin.postcss = true;
    var animationNameRE = /^(-\w+-)?animation-name$/;
    var animationRE = /^(-\w+-)?animation$/;
    var scopedPlugin = (id = "") => {
      const keyframes = Object.create(null);
      const shortId = id.replace(/^data-v-/, "");
      return {
        postcssPlugin: "vue-sfc-scoped",
        Rule(rule) {
          processRule(id, rule);
        },
        AtRule(node) {
          if (/-?keyframes$/.test(node.name) && !node.params.endsWith(`-${shortId}`)) {
            keyframes[node.params] = node.params = node.params + "-" + shortId;
          }
        },
        OnceExit(root) {
          if (Object.keys(keyframes).length) {
            root.walkDecls((decl) => {
              if (animationNameRE.test(decl.prop)) {
                decl.value = decl.value.split(",").map((v) => keyframes[v.trim()] || v.trim()).join(",");
              }
              if (animationRE.test(decl.prop)) {
                decl.value = decl.value.split(",").map((v) => {
                  const vals = v.trim().split(/\s+/);
                  const i = vals.findIndex((val) => keyframes[val]);
                  if (i !== -1) {
                    vals.splice(i, 1, keyframes[vals[i]]);
                    return vals.join(" ");
                  } else {
                    return v;
                  }
                }).join(",");
              }
            });
          }
        }
      };
    };
    var processedRules = new WeakSet();
    function processRule(id, rule) {
      if (processedRules.has(rule) || rule.parent && rule.parent.type === "atrule" && /-?keyframes$/.test(rule.parent.name)) {
        return;
      }
      processedRules.add(rule);
      rule.selector = selectorParser__default((selectorRoot) => {
        selectorRoot.each((selector) => {
          rewriteSelector(id, selector, selectorRoot);
        });
      }).processSync(rule.selector);
    }
    function rewriteSelector(id, selector, selectorRoot, slotted = false) {
      let node = null;
      let shouldInject = true;
      selector.each((n) => {
        if (n.type === "combinator" && (n.value === ">>>" || n.value === "/deep/")) {
          n.value = " ";
          n.spaces.before = n.spaces.after = "";
          warn(`the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`);
          return false;
        }
        if (n.type === "pseudo") {
          const { value } = n;
          if (value === ":deep" || value === "::v-deep") {
            if (n.nodes.length) {
              let last = n;
              n.nodes[0].each((ss) => {
                selector.insertAfter(last, ss);
                last = ss;
              });
              const prev = selector.at(selector.index(n) - 1);
              if (!prev || !isSpaceCombinator(prev)) {
                selector.insertAfter(n, selectorParser__default.combinator({
                  value: " "
                }));
              }
              selector.removeChild(n);
            } else {
              warn(`::v-deep usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead.`);
              const prev = selector.at(selector.index(n) - 1);
              if (prev && isSpaceCombinator(prev)) {
                selector.removeChild(prev);
              }
              selector.removeChild(n);
            }
            return false;
          }
          if (value === ":slotted" || value === "::v-slotted") {
            rewriteSelector(id, n.nodes[0], selectorRoot, true);
            let last = n;
            n.nodes[0].each((ss) => {
              selector.insertAfter(last, ss);
              last = ss;
            });
            selector.removeChild(n);
            shouldInject = false;
            return false;
          }
          if (value === ":global" || value === "::v-global") {
            selectorRoot.insertAfter(selector, n.nodes[0]);
            selectorRoot.removeChild(selector);
            return false;
          }
        }
        if (n.type !== "pseudo" && n.type !== "combinator") {
          node = n;
        }
      });
      if (node) {
        node.spaces.after = "";
      } else {
        selector.first.spaces.before = "";
      }
      if (shouldInject) {
        const idToAdd = slotted ? id + "-s" : id;
        selector.insertAfter(node, selectorParser__default.attribute({
          attribute: idToAdd,
          value: idToAdd,
          raws: {},
          quoteMark: `"`
        }));
      }
    }
    function isSpaceCombinator(node) {
      return node.type === "combinator" && /^\s+$/.test(node.value);
    }
    scopedPlugin.postcss = true;
    var scss = (source, map, options, load = require) => {
      const nodeSass = load("sass");
      const finalOptions = Object.assign(Object.assign({}, options), { data: getSource(source, options.filename, options.additionalData), file: options.filename, outFile: options.filename, sourceMap: !!map });
      try {
        const result = nodeSass.renderSync(finalOptions);
        const dependencies = result.stats.includedFiles;
        if (map) {
          return {
            code: result.css.toString(),
            map: merge__default(map, JSON.parse(result.map.toString())),
            errors: [],
            dependencies
          };
        }
        return { code: result.css.toString(), errors: [], dependencies };
      } catch (e) {
        return { code: "", errors: [e], dependencies: [] };
      }
    };
    var sass = (source, map, options, load) => scss(source, map, Object.assign(Object.assign({}, options), { indentedSyntax: true }), load);
    var less = (source, map, options, load = require) => {
      const nodeLess = load("less");
      let result;
      let error = null;
      nodeLess.render(getSource(source, options.filename, options.additionalData), Object.assign(Object.assign({}, options), { syncImport: true }), (err, output) => {
        error = err;
        result = output;
      });
      if (error)
        return { code: "", errors: [error], dependencies: [] };
      const dependencies = result.imports;
      if (map) {
        return {
          code: result.css.toString(),
          map: merge__default(map, result.map),
          errors: [],
          dependencies
        };
      }
      return {
        code: result.css.toString(),
        errors: [],
        dependencies
      };
    };
    var styl = (source, map, options, load = require) => {
      const nodeStylus = load("stylus");
      try {
        const ref = nodeStylus(source);
        Object.keys(options).forEach((key) => ref.set(key, options[key]));
        if (map)
          ref.set("sourcemap", { inline: false, comment: false });
        const result = ref.render();
        const dependencies = ref.deps();
        if (map) {
          return {
            code: result,
            map: merge__default(map, ref.sourcemap),
            errors: [],
            dependencies
          };
        }
        return { code: result, errors: [], dependencies };
      } catch (e) {
        return { code: "", errors: [e], dependencies: [] };
      }
    };
    function getSource(source, filename, additionalData) {
      if (!additionalData)
        return source;
      if (shared.isFunction(additionalData)) {
        return additionalData(source, filename);
      }
      return additionalData + source;
    }
    var processors = {
      less,
      sass,
      scss,
      styl,
      stylus: styl
    };
    function compileStyle(options) {
      return doCompileStyle(Object.assign(Object.assign({}, options), { isAsync: false }));
    }
    function compileStyleAsync(options) {
      return doCompileStyle(Object.assign(Object.assign({}, options), { isAsync: true }));
    }
    function doCompileStyle(options) {
      const { filename, id, scoped = false, trim = true, isProd = false, modules = false, modulesOptions = {}, preprocessLang, postcssOptions, postcssPlugins } = options;
      const preprocessor = preprocessLang && processors[preprocessLang];
      const preProcessedSource = preprocessor && preprocess$1(options, preprocessor);
      const map = preProcessedSource ? preProcessedSource.map : options.inMap || options.map;
      const source = preProcessedSource ? preProcessedSource.code : options.source;
      const shortId = id.replace(/^data-v-/, "");
      const longId = `data-v-${shortId}`;
      const plugins = (postcssPlugins || []).slice();
      plugins.unshift(cssVarsPlugin({ id: shortId, isProd }));
      if (trim) {
        plugins.push(trimPlugin());
      }
      if (scoped) {
        plugins.push(scopedPlugin(longId));
      }
      let cssModules;
      if (modules) {
        if (!options.isAsync) {
          throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
        }
        plugins.push(require_build()(Object.assign(Object.assign({}, modulesOptions), { getJSON: (_cssFileName, json) => {
          cssModules = json;
        } })));
      }
      const postCSSOptions = Object.assign(Object.assign({}, postcssOptions), { to: filename, from: filename });
      if (map) {
        postCSSOptions.map = {
          inline: false,
          annotation: false,
          prev: map
        };
      }
      let result;
      let code;
      let outMap;
      const dependencies = new Set(preProcessedSource ? preProcessedSource.dependencies : []);
      dependencies.delete(filename);
      const errors = [];
      if (preProcessedSource && preProcessedSource.errors.length) {
        errors.push(...preProcessedSource.errors);
      }
      const recordPlainCssDependencies = (messages) => {
        messages.forEach((msg) => {
          if (msg.type === "dependency") {
            dependencies.add(msg.file);
          }
        });
        return dependencies;
      };
      try {
        result = postcss__default(plugins).process(source, postCSSOptions);
        if (options.isAsync) {
          return result.then((result2) => ({
            code: result2.css || "",
            map: result2.map && result2.map.toJSON(),
            errors,
            modules: cssModules,
            rawResult: result2,
            dependencies: recordPlainCssDependencies(result2.messages)
          })).catch((error) => ({
            code: "",
            map: void 0,
            errors: [...errors, error],
            rawResult: void 0,
            dependencies
          }));
        }
        recordPlainCssDependencies(result.messages);
        code = result.css;
        outMap = result.map;
      } catch (e) {
        errors.push(e);
      }
      return {
        code: code || ``,
        map: outMap && outMap.toJSON(),
        errors,
        rawResult: result,
        dependencies
      };
    }
    function preprocess$1(options, preprocessor) {
      return preprocessor(options.source, options.inMap || options.map, Object.assign({ filename: options.filename }, options.preprocessOptions), options.preprocessCustomRequire);
    }
    var defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/;
    var namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/s;
    var exportDefaultClassRE = /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/;
    function rewriteDefault(input, as, parserPlugins) {
      if (!hasDefaultExport(input)) {
        return input + `
const ${as} = {}`;
      }
      let replaced;
      const classMatch = input.match(exportDefaultClassRE);
      if (classMatch) {
        replaced = input.replace(exportDefaultClassRE, "$1class $2") + `
const ${as} = ${classMatch[2]}`;
      } else {
        replaced = input.replace(defaultExportRE, `$1const ${as} =`);
      }
      if (!hasDefaultExport(replaced)) {
        return replaced;
      }
      const s = new MagicString__default(input);
      const ast = parser.parse(input, {
        sourceType: "module",
        plugins: parserPlugins
      }).program.body;
      ast.forEach((node) => {
        if (node.type === "ExportDefaultDeclaration") {
          s.overwrite(node.start, node.declaration.start, `const ${as} = `);
        }
        if (node.type === "ExportNamedDeclaration") {
          node.specifiers.forEach((specifier) => {
            if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === "default") {
              const end = specifier.end;
              s.overwrite(specifier.start, input.charAt(end) === "," ? end + 1 : end, ``);
              s.append(`
const ${as} = ${specifier.local.name}`);
            }
          });
        }
      });
      return s.toString();
    }
    function hasDefaultExport(input) {
      return defaultExportRE.test(input) || namedDefaultExportRE.test(input);
    }
    var DEFINE_PROPS = "defineProps";
    var DEFINE_EMITS = "defineEmits";
    var DEFINE_EXPOSE = "defineExpose";
    var WITH_DEFAULTS = "withDefaults";
    var $REF = `$ref`;
    var $SHALLOW_REF = "$shallowRef";
    var $COMPUTED = `$computed`;
    var $FROM_REFS = `$fromRefs`;
    var $RAW = `$raw`;
    var isBuiltInDir = shared.makeMap(`once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`);
    function compileScript(sfc, options) {
      let { script, scriptSetup, source, filename } = sfc;
      const enableRefSugar = !!options.refSugar;
      const parseOnly = !!options.parseOnly;
      if (parseOnly && !scriptSetup) {
        scriptSetup = {
          type: "script",
          content: "",
          attrs: {},
          loc: CompilerDOM.locStub
        };
      }
      if (!options) {
        options = { id: "" };
      }
      if (!options.id) {
        warnOnce(`compileScript now requires passing the \`id\` option.
Upgrade your vite or vue-loader version for compatibility with the latest experimental proposals.`);
      }
      const scopeId = options.id ? options.id.replace(/^data-v-/, "") : "";
      const cssVars = sfc.cssVars;
      const scriptLang = script && script.lang;
      const scriptSetupLang = scriptSetup && scriptSetup.lang;
      const isTS = scriptLang === "ts" || scriptLang === "tsx" || scriptSetupLang === "ts" || scriptSetupLang === "tsx";
      const plugins = [...shared.babelParserDefaultPlugins];
      if (!isTS || scriptLang === "tsx" || scriptSetupLang === "tsx") {
        plugins.push("jsx");
      }
      if (options.babelParserPlugins)
        plugins.push(...options.babelParserPlugins);
      if (isTS)
        plugins.push("typescript", "decorators-legacy");
      if (!scriptSetup) {
        if (!script) {
          throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);
        }
        if (scriptLang && !isTS && scriptLang !== "jsx") {
          return script;
        }
        try {
          const scriptAst2 = parser.parse(script.content, {
            plugins,
            sourceType: "module",
            errorRecovery: parseOnly
          }).program.body;
          const bindings = analyzeScriptBindings(scriptAst2);
          let content = script.content;
          if (cssVars.length) {
            content = rewriteDefault(content, `__default__`, plugins);
            content += genNormalScriptCssVarsCode(cssVars, bindings, scopeId, !!options.isProd);
            content += `
export default __default__`;
          }
          return Object.assign(Object.assign({}, script), {
            content,
            bindings,
            scriptAst: scriptAst2
          });
        } catch (e) {
          return script;
        }
      }
      if (script && scriptLang !== scriptSetupLang) {
        throw new Error(`[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`);
      }
      if (scriptSetupLang && !isTS && scriptSetupLang !== "jsx") {
        return scriptSetup;
      }
      const bindingMetadata = {};
      const ranges = parseOnly ? {
        scriptBindings: [],
        scriptSetupBindings: []
      } : void 0;
      const defaultTempVar = `__default__`;
      const helperImports = new Set();
      const userImports = Object.create(null);
      const userImportAlias = Object.create(null);
      const setupBindings = Object.create(null);
      const refBindings = Object.create(null);
      const refIdentifiers = new Set();
      let defaultExport;
      let hasDefinePropsCall = false;
      let hasDefineEmitCall = false;
      let hasDefineExposeCall = false;
      let propsRuntimeDecl;
      let propsRuntimeDefaults;
      let propsTypeDecl;
      let propsTypeDeclRaw;
      let propsIdentifier;
      let emitsRuntimeDecl;
      let emitsTypeDecl;
      let emitsTypeDeclRaw;
      let emitIdentifier;
      let hasAwait = false;
      let hasInlinedSsrRenderFn = false;
      const typeDeclaredProps = {};
      const typeDeclaredEmits = new Set();
      const declaredTypes = {};
      const s = new MagicString__default(source);
      const startOffset = scriptSetup.loc.start.offset;
      const endOffset = scriptSetup.loc.end.offset;
      const scriptStartOffset = script && script.loc.start.offset;
      const scriptEndOffset = script && script.loc.end.offset;
      function helper(key) {
        helperImports.add(key);
        return `_${key}`;
      }
      function parse4(input, options2, offset) {
        try {
          options2.errorRecovery = parseOnly;
          return parser.parse(input, options2).program.body;
        } catch (e) {
          e.message = `[@vue/compiler-sfc] ${e.message}

${sfc.filename}
${shared.generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`;
          throw e;
        }
      }
      function error(msg, node, end = node.end + startOffset) {
        throw new Error(`[@vue/compiler-sfc] ${msg}

${sfc.filename}
${shared.generateCodeFrame(source, node.start + startOffset, end)}`);
      }
      function registerUserImport(source2, local, imported, isType, isFromSetup, rangeNode) {
        if (source2 === "vue" && imported) {
          userImportAlias[imported] = local;
        }
        let isUsedInTemplate = true;
        if (isTS && sfc.template && !sfc.template.src && !sfc.template.lang) {
          isUsedInTemplate = new RegExp(`[^\\w$_]${local.replace(/\$/g, "\\$")}[^\\w$_]`).test(resolveTemplateUsageCheckString(sfc));
        }
        userImports[local] = {
          isType,
          imported: imported || "default",
          source: source2,
          rangeNode,
          isFromSetup,
          isUsedInTemplate
        };
      }
      function processDefineProps(node) {
        if (!isCallOf(node, DEFINE_PROPS)) {
          return false;
        }
        if (hasDefinePropsCall) {
          error(`duplicate ${DEFINE_PROPS}() call`, node);
        }
        hasDefinePropsCall = true;
        propsRuntimeDecl = node.arguments[0];
        if (node.typeParameters) {
          if (propsRuntimeDecl) {
            error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
          }
          propsTypeDeclRaw = node.typeParameters.params[0];
          propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, (node2) => node2.type === "TSTypeLiteral");
          if (!propsTypeDecl) {
            error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, or a reference to an interface or literal type.`, propsTypeDeclRaw);
          }
        }
        return true;
      }
      function processWithDefaults(node) {
        if (!isCallOf(node, WITH_DEFAULTS)) {
          return false;
        }
        if (processDefineProps(node.arguments[0])) {
          if (propsRuntimeDecl) {
            error(`${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`, node);
          }
          propsRuntimeDefaults = node.arguments[1];
        } else {
          error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
        }
        return true;
      }
      function processDefineEmits(node) {
        if (!isCallOf(node, DEFINE_EMITS)) {
          return false;
        }
        if (hasDefineEmitCall) {
          error(`duplicate ${DEFINE_EMITS}() call`, node);
        }
        hasDefineEmitCall = true;
        emitsRuntimeDecl = node.arguments[0];
        if (node.typeParameters) {
          if (emitsRuntimeDecl) {
            error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
          }
          emitsTypeDeclRaw = node.typeParameters.params[0];
          emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, (node2) => node2.type === "TSFunctionType" || node2.type === "TSTypeLiteral");
          if (!emitsTypeDecl) {
            error(`type argument passed to ${DEFINE_EMITS}() must be a function type, a literal type with call signatures, or a reference to the above types.`, emitsTypeDeclRaw);
          }
        }
        return true;
      }
      function resolveQualifiedType(node, qualifier) {
        if (qualifier(node)) {
          return node;
        }
        if (node.type === "TSTypeReference" && node.typeName.type === "Identifier") {
          const refName = node.typeName.name;
          const isQualifiedType = (node2) => {
            if (node2.type === "TSInterfaceDeclaration" && node2.id.name === refName) {
              return node2.body;
            } else if (node2.type === "TSTypeAliasDeclaration" && node2.id.name === refName && qualifier(node2.typeAnnotation)) {
              return node2.typeAnnotation;
            } else if (node2.type === "ExportNamedDeclaration" && node2.declaration) {
              return isQualifiedType(node2.declaration);
            }
          };
          for (const node2 of scriptSetupAst) {
            const qualified = isQualifiedType(node2);
            if (qualified) {
              return qualified;
            }
          }
        }
      }
      function processDefineExpose(node) {
        if (isCallOf(node, DEFINE_EXPOSE)) {
          if (hasDefineExposeCall) {
            error(`duplicate ${DEFINE_EXPOSE}() call`, node);
          }
          hasDefineExposeCall = true;
          return true;
        }
        return false;
      }
      function checkInvalidScopeReference(node, method) {
        if (!node)
          return;
        walkIdentifiers(node, (id) => {
          if (setupBindings[id.name]) {
            error(`\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options requires initialization in the module scope, use a separate normal <script> to export the options instead.`, id);
          }
        });
      }
      function processAwait(node, isStatement) {
        s.overwrite(node.start + startOffset, node.argument.start + startOffset, `${isStatement ? `;` : ``}(([__temp,__restore]=${helper(`withAsyncContext`)}(()=>(`);
        s.appendLeft(node.end + startOffset, `))),__temp=await __temp,__restore()${isStatement ? `` : `,__temp`})`);
      }
      function isRefSugarCall(callee) {
        return callee === $REF || callee === $COMPUTED || callee === $FROM_REFS || callee === $SHALLOW_REF;
      }
      function processRefSugar(decl, statement) {
        if (!isCallOf(decl.init, isRefSugarCall)) {
          return;
        }
        if (!enableRefSugar) {
          error(`ref sugar is an experimental proposal and must be explicitly enabled via @vue/compiler-sfc options.`, decl.init);
        } else {
          warnExperimental(`ref sugar`, `https://github.com/vuejs/rfcs/discussions/369`);
        }
        const callee = decl.init.callee.name;
        const start = decl.init.start + startOffset;
        if (callee === $REF || callee === $SHALLOW_REF) {
          if (statement.kind !== "let") {
            error(`${callee}() bindings can only be declared with let.`, decl);
          }
          if (decl.id.type !== "Identifier") {
            error(`${callee}() bindings cannot be used with destructuring. If you are trying to destructure from an object of refs, use \`let { x } = $fromRefs(obj)\`.`, decl.id);
          }
          registerRefBinding(decl.id);
          s.overwrite(start, start + callee.length, helper(callee === $REF ? "ref" : "shallowRef"));
        } else if (callee === $COMPUTED) {
          if (decl.id.type !== "Identifier") {
            error(`${callee}() bindings cannot be used with destructuring.`, decl.id);
          }
          registerRefBinding(decl.id);
          s.overwrite(start, start + $COMPUTED.length, helper("computed"));
        } else if (callee === $FROM_REFS) {
          if (!decl.id.type.endsWith("Pattern")) {
            error(`${callee}() declaration must be used with destructure patterns.`, decl);
          }
          if (decl.id.type === "ObjectPattern") {
            processRefObjectPattern(decl.id, statement);
          } else if (decl.id.type === "ArrayPattern") {
            processRefArrayPattern(decl.id, statement);
          }
          s.remove(start, start + callee.length);
        }
      }
      function registerRefBinding(id) {
        if (id.name[0] === "$") {
          error(`ref variable identifiers cannot start with $.`, id);
        }
        refBindings[id.name] = setupBindings[id.name] = {
          type: "setup-ref",
          rangeNode: id
        };
        refIdentifiers.add(id);
      }
      function processRefObjectPattern(pattern, statement) {
        for (const p of pattern.properties) {
          let nameId;
          if (p.type === "ObjectProperty") {
            if (p.key.start === p.value.start) {
              nameId = p.key;
              s.appendLeft(nameId.end + startOffset, `: __${nameId.name}`);
              if (p.value.type === "AssignmentPattern") {
                refIdentifiers.add(p.value.left);
              }
            } else {
              if (p.value.type === "Identifier") {
                nameId = p.value;
                s.prependRight(nameId.start + startOffset, `__`);
              } else if (p.value.type === "ObjectPattern") {
                processRefObjectPattern(p.value, statement);
              } else if (p.value.type === "ArrayPattern") {
                processRefArrayPattern(p.value, statement);
              } else if (p.value.type === "AssignmentPattern") {
                nameId = p.value.left;
                s.prependRight(nameId.start + startOffset, `__`);
              }
            }
          } else {
            nameId = p.argument;
            s.prependRight(nameId.start + startOffset, `__`);
          }
          if (nameId) {
            registerRefBinding(nameId);
            s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("shallowRef")}(__${nameId.name});`);
          }
        }
      }
      function processRefArrayPattern(pattern, statement) {
        for (const e of pattern.elements) {
          if (!e)
            continue;
          let nameId;
          if (e.type === "Identifier") {
            nameId = e;
          } else if (e.type === "AssignmentPattern") {
            nameId = e.left;
          } else if (e.type === "RestElement") {
            nameId = e.argument;
          } else if (e.type === "ObjectPattern") {
            processRefObjectPattern(e, statement);
          } else if (e.type === "ArrayPattern") {
            processRefArrayPattern(e, statement);
          }
          if (nameId) {
            registerRefBinding(nameId);
            s.prependRight(nameId.start + startOffset, `__`);
            s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("shallowRef")}(__${nameId.name});`);
          }
        }
      }
      function genRuntimeProps(props) {
        const keys = Object.keys(props);
        if (!keys.length) {
          return ``;
        }
        const hasStaticDefaults = propsRuntimeDefaults && propsRuntimeDefaults.type === "ObjectExpression" && propsRuntimeDefaults.properties.every((node) => node.type === "ObjectProperty" && !node.computed);
        let propsDecls = `{
    ${keys.map((key) => {
          let defaultString;
          if (hasStaticDefaults) {
            const prop = propsRuntimeDefaults.properties.find((node) => node.key.name === key);
            if (prop) {
              defaultString = `default: ${source.slice(prop.value.start + startOffset, prop.value.end + startOffset)}`;
            }
          }
          {
            const { type, required } = props[key];
            return `${key}: { type: ${toRuntimeTypeString(type)}, required: ${required}${defaultString ? `, ${defaultString}` : ``} }`;
          }
        }).join(",\n    ")}
  }`;
        if (propsRuntimeDefaults && !hasStaticDefaults) {
          propsDecls = `${helper("mergeDefaults")}(${propsDecls}, ${source.slice(propsRuntimeDefaults.start + startOffset, propsRuntimeDefaults.end + startOffset)})`;
        }
        return `
  props: ${propsDecls} as unknown as undefined,`;
      }
      let scriptAst;
      if (script) {
        scriptAst = parse4(script.content, {
          plugins,
          sourceType: "module"
        }, scriptStartOffset);
        for (const node of scriptAst) {
          if (node.type === "ImportDeclaration") {
            for (const specifier of node.specifiers) {
              const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
              registerUserImport(node.source.value, specifier.local.name, imported, node.importKind === "type", false, specifier.local);
            }
          } else if (node.type === "ExportDefaultDeclaration") {
            defaultExport = node;
            const start = node.start + scriptStartOffset;
            s.overwrite(start, start + `export default`.length, `const ${defaultTempVar} =`);
          } else if (node.type === "ExportNamedDeclaration" && node.specifiers) {
            const defaultSpecifier = node.specifiers.find((s2) => s2.exported.type === "Identifier" && s2.exported.name === "default");
            if (defaultSpecifier) {
              defaultExport = node;
              if (node.specifiers.length > 1) {
                s.remove(defaultSpecifier.start + scriptStartOffset, defaultSpecifier.end + scriptStartOffset);
              } else {
                s.remove(node.start + scriptStartOffset, node.end + scriptStartOffset);
              }
              if (node.source) {
                s.prepend(`import { ${defaultSpecifier.local.name} as ${defaultTempVar} } from '${node.source.value}'
`);
              } else {
                s.append(`
const ${defaultTempVar} = ${defaultSpecifier.local.name}
`);
              }
            }
          }
        }
      }
      const scriptSetupAst = parse4(scriptSetup.content, {
        plugins: [
          ...plugins,
          "topLevelAwait"
        ],
        sourceType: "module"
      }, startOffset);
      for (const node of scriptSetupAst) {
        const start = node.start + startOffset;
        let end = node.end + startOffset;
        if (node.trailingComments && node.trailingComments.length > 0) {
          const lastCommentNode = node.trailingComments[node.trailingComments.length - 1];
          end = lastCommentNode.end + startOffset;
        }
        while (end <= source.length) {
          if (!/\s/.test(source.charAt(end))) {
            break;
          }
          end++;
        }
        if (node.type === "LabeledStatement" && node.label.name === "ref" && node.body.type === "ExpressionStatement") {
          error(`ref sugar using the label syntax was an experimental proposal and has been dropped based on community feedback.`, node);
        }
        if (node.type === "ImportDeclaration") {
          s.move(start, end, 0);
          let removed = 0;
          const removeSpecifier = (i) => {
            const removeLeft = i > removed;
            removed++;
            const current = node.specifiers[i];
            const next = node.specifiers[i + 1];
            s.remove(removeLeft ? node.specifiers[i - 1].end + startOffset : current.start + startOffset, next && !removeLeft ? next.start + startOffset : current.end + startOffset);
          };
          for (let i = 0; i < node.specifiers.length; i++) {
            const specifier = node.specifiers[i];
            const local = specifier.local.name;
            const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
            const source2 = node.source.value;
            const existing = userImports[local];
            if (source2 === "vue" && (imported === DEFINE_PROPS || imported === DEFINE_EMITS || imported === DEFINE_EXPOSE)) {
              warnOnce(`\`${imported}\` is a compiler macro and no longer needs to be imported.`);
              removeSpecifier(i);
            } else if (existing) {
              if (existing.source === source2 && existing.imported === imported) {
                removeSpecifier(i);
              } else {
                error(`different imports aliased to same local name.`, specifier);
              }
            } else {
              registerUserImport(source2, local, imported, node.importKind === "type", true, specifier.local);
            }
          }
          if (node.specifiers.length && removed === node.specifiers.length) {
            s.remove(node.start + startOffset, node.end + startOffset);
          }
        }
        if (node.type === "ExpressionStatement") {
          if (processDefineProps(node.expression) || processDefineEmits(node.expression) || processWithDefaults(node.expression)) {
            s.remove(node.start + startOffset, node.end + startOffset);
          } else if (processDefineExpose(node.expression)) {
            const callee = node.expression.callee;
            s.overwrite(callee.start + startOffset, callee.end + startOffset, "expose");
          }
        }
        if (node.type === "VariableDeclaration" && !node.declare) {
          const total = node.declarations.length;
          let left = total;
          for (let i = 0; i < total; i++) {
            const decl = node.declarations[i];
            if (decl.init) {
              const isDefineProps = processDefineProps(decl.init) || processWithDefaults(decl.init);
              if (isDefineProps) {
                propsIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
              }
              const isDefineEmits = processDefineEmits(decl.init);
              if (isDefineEmits) {
                emitIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
              }
              if (isDefineProps || isDefineEmits) {
                if (left === 1) {
                  s.remove(node.start + startOffset, node.end + startOffset);
                } else {
                  let start2 = decl.start + startOffset;
                  let end2 = decl.end + startOffset;
                  if (i < total - 1) {
                    end2 = node.declarations[i + 1].start + startOffset;
                  } else {
                    start2 = node.declarations[i - 1].end + startOffset;
                  }
                  s.remove(start2, end2);
                  left--;
                }
              } else {
                processRefSugar(decl, node);
              }
            }
          }
        }
        if ((node.type === "VariableDeclaration" || node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") && !node.declare) {
          walkDeclaration(node, setupBindings, userImportAlias);
        }
        if (node.type === "VariableDeclaration" && !node.declare || node.type.endsWith("Statement")) {
          estreeWalker.walk(node, {
            enter(child, parent) {
              if (isFunction(child)) {
                this.skip();
              }
              if (child.type === "AwaitExpression") {
                hasAwait = true;
                processAwait(child, parent.type === "ExpressionStatement");
              }
            }
          });
        }
        if (node.type === "ExportNamedDeclaration" && node.exportKind !== "type" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration") {
          error(`<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`, node);
        }
        if (isTS) {
          if (node.type === "TSEnumDeclaration") {
            registerBinding(setupBindings, node.id, "setup-const");
          }
          if (node.type.startsWith("TS") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "VariableDeclaration" && node.declare) {
            recordType(node, declaredTypes);
            s.move(start, end, 0);
          }
        }
      }
      if (parseOnly) {
        for (const key in userImports) {
          const { rangeNode, isFromSetup } = userImports[key];
          const bindings = isFromSetup ? ranges.scriptSetupBindings : ranges.scriptBindings;
          bindings.push(toTextRange(rangeNode));
        }
        for (const key in setupBindings) {
          ranges.scriptSetupBindings.push(toTextRange(setupBindings[key].rangeNode));
        }
        if (propsRuntimeDecl) {
          ranges.propsRuntimeArg = toTextRange(propsRuntimeDecl);
        }
        if (propsTypeDeclRaw) {
          ranges.propsTypeArg = toTextRange(propsTypeDeclRaw);
        }
        if (emitsRuntimeDecl) {
          ranges.emitsRuntimeArg = toTextRange(emitsRuntimeDecl);
        }
        if (emitsTypeDeclRaw) {
          ranges.emitsTypeArg = toTextRange(emitsTypeDeclRaw);
        }
        if (propsRuntimeDefaults) {
          ranges.withDefaultsArg = toTextRange(propsRuntimeDefaults);
        }
        return Object.assign(Object.assign({}, scriptSetup), {
          ranges,
          scriptAst,
          scriptSetupAst
        });
      }
      if (enableRefSugar) {
        const onIdent = (id, parent, parentStack) => {
          if (refBindings[id.name] && !refIdentifiers.has(id)) {
            if (isStaticProperty(parent) && parent.shorthand) {
              if (!parent.inPattern || isInDestructureAssignment(parent, parentStack)) {
                s.appendLeft(id.end + startOffset, `: ${id.name}.value`);
              }
            } else {
              s.appendLeft(id.end + startOffset, ".value");
            }
          }
        };
        const onNode = (node, parent) => {
          if (isCallOf(node, $RAW)) {
            s.remove(node.callee.start + startOffset, node.callee.end + startOffset);
            return false;
          } else if (parent && isCallOf(node, isRefSugarCall) && (parent.type !== "VariableDeclarator" || node !== parent.init)) {
            error(`${node.callee.name} can only be used directly as a variable initializer.`, node);
          }
        };
        for (const node of scriptSetupAst) {
          if (node.type !== "ImportDeclaration") {
            walkIdentifiers(node, onIdent, onNode);
          }
        }
      }
      if (propsTypeDecl) {
        extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
      }
      if (emitsTypeDecl) {
        extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits);
      }
      checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS);
      checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS);
      checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS);
      if (script) {
        if (startOffset < scriptStartOffset) {
          s.remove(0, startOffset);
          s.remove(endOffset, scriptStartOffset);
          s.remove(scriptEndOffset, source.length);
        } else {
          s.remove(0, scriptStartOffset);
          s.remove(scriptEndOffset, startOffset);
          s.remove(endOffset, source.length);
        }
      } else {
        s.remove(0, startOffset);
        s.remove(endOffset, source.length);
      }
      if (scriptAst) {
        Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst));
      }
      if (propsRuntimeDecl) {
        for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
          bindingMetadata[key] = "props";
        }
      }
      for (const key in typeDeclaredProps) {
        bindingMetadata[key] = "props";
      }
      for (const [key, { isType, imported, source: source2 }] of Object.entries(userImports)) {
        if (isType)
          continue;
        bindingMetadata[key] = imported === "default" && source2.endsWith(".vue") || source2 === "vue" ? "setup-const" : "setup-maybe-ref";
      }
      for (const key in setupBindings) {
        bindingMetadata[key] = setupBindings[key].type;
      }
      for (const key in refBindings) {
        bindingMetadata[key] = "setup-ref";
      }
      if (cssVars.length) {
        helperImports.add(CSS_VARS_HELPER);
        helperImports.add("unref");
        s.prependRight(startOffset, `
${genCssVarsCode(cssVars, bindingMetadata, scopeId, !!options.isProd)}
`);
      }
      let args = `__props`;
      if (propsTypeDecl) {
        args += `: ${scriptSetup.content.slice(propsTypeDecl.start, propsTypeDecl.end)}`;
      }
      if (propsIdentifier) {
        s.prependRight(startOffset, `
const ${propsIdentifier} = __props`);
      }
      if (hasAwait) {
        const any = isTS ? `:any` : ``;
        s.prependRight(startOffset, `
let __temp${any}, __restore${any}
`);
      }
      const destructureElements = hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : [];
      if (emitIdentifier) {
        destructureElements.push(emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`);
      }
      if (destructureElements.length) {
        args += `, { ${destructureElements.join(", ")} }`;
        if (emitsTypeDecl) {
          args += `: { emit: (${scriptSetup.content.slice(emitsTypeDecl.start, emitsTypeDecl.end)}), expose: any, slots: any, attrs: any }`;
        }
      }
      let returned;
      if (options.inlineTemplate) {
        if (sfc.template && !sfc.template.src) {
          if (options.templateOptions && options.templateOptions.ssr) {
            hasInlinedSsrRenderFn = true;
          }
          const { code, ast, preamble, tips, errors } = compileTemplate(Object.assign(Object.assign({ filename, source: sfc.template.content, inMap: sfc.template.map }, options.templateOptions), { id: scopeId, scoped: sfc.styles.some((s2) => s2.scoped), isProd: options.isProd, ssrCssVars: sfc.cssVars, compilerOptions: Object.assign(Object.assign({}, options.templateOptions && options.templateOptions.compilerOptions), {
            inline: true,
            isTS,
            bindingMetadata
          }) }));
          if (tips.length) {
            tips.forEach(warnOnce);
          }
          const err = errors[0];
          if (typeof err === "string") {
            throw new Error(err);
          } else if (err) {
            if (err.loc) {
              err.message += `

` + sfc.filename + "\n" + shared.generateCodeFrame(source, err.loc.start.offset, err.loc.end.offset) + `
`;
            }
            throw err;
          }
          if (preamble) {
            s.prepend(preamble);
          }
          if (ast && ast.helpers.includes(CompilerDOM.UNREF)) {
            helperImports.delete("unref");
          }
          returned = code;
        } else {
          returned = `() => {}`;
        }
      } else {
        const allBindings = Object.assign({}, setupBindings);
        for (const key in userImports) {
          if (!userImports[key].isType && userImports[key].isUsedInTemplate) {
            allBindings[key] = true;
          }
        }
        returned = `{ ${Object.keys(allBindings).join(", ")} }`;
      }
      if (!options.inlineTemplate && true) {
        s.appendRight(endOffset, `
const __returned__ = ${returned}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
      } else {
        s.appendRight(endOffset, `
return ${returned}
}

`);
      }
      let runtimeOptions = ``;
      if (hasInlinedSsrRenderFn) {
        runtimeOptions += `
  __ssrInlineRender: true,`;
      }
      if (propsRuntimeDecl) {
        runtimeOptions += `
  props: ${scriptSetup.content.slice(propsRuntimeDecl.start, propsRuntimeDecl.end).trim()},`;
      } else if (propsTypeDecl) {
        runtimeOptions += genRuntimeProps(typeDeclaredProps);
      }
      if (emitsRuntimeDecl) {
        runtimeOptions += `
  emits: ${scriptSetup.content.slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end).trim()},`;
      } else if (emitsTypeDecl) {
        runtimeOptions += genRuntimeEmits(typeDeclaredEmits);
      }
      const exposeCall = hasDefineExposeCall || options.inlineTemplate ? `` : `  expose()
`;
      if (isTS) {
        const def = defaultExport ? `
  ...${defaultTempVar},` : ``;
        s.prependLeft(startOffset, `
export default ${helper(`defineComponent`)}({${def}${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
        s.appendRight(endOffset, `})`);
      } else {
        if (defaultExport) {
          s.prependLeft(startOffset, `
${hasAwait ? `async ` : ``}function setup(${args}) {
`);
          s.append(`
export default /*#__PURE__*/ Object.assign(${defaultTempVar}, {${runtimeOptions}
  setup
})
`);
        } else {
          s.prependLeft(startOffset, `
export default {${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
          s.appendRight(endOffset, `}`);
        }
      }
      if (helperImports.size > 0) {
        s.prepend(`import { ${[...helperImports].map((h) => `${h} as _${h}`).join(", ")} } from 'vue'
`);
      }
      s.trim();
      return Object.assign(Object.assign({}, scriptSetup), {
        bindings: bindingMetadata,
        content: s.toString(),
        map: s.generateMap({
          source: filename,
          hires: true,
          includeContent: true
        }),
        scriptAst,
        scriptSetupAst
      });
    }
    function registerBinding(bindings, node, type) {
      bindings[node.name] = {
        type,
        rangeNode: node
      };
    }
    function walkDeclaration(node, bindings, userImportAlias) {
      if (node.type === "VariableDeclaration") {
        const isConst = node.kind === "const";
        for (const { id, init } of node.declarations) {
          const isDefineCall = !!(isConst && isCallOf(init, (c) => c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS));
          if (id.type === "Identifier") {
            let bindingType;
            const userReactiveBinding = userImportAlias["reactive"] || "reactive";
            if (isCallOf(init, userReactiveBinding)) {
              bindingType = "setup-let";
            } else if (isDefineCall || isConst && canNeverBeRef(init, userReactiveBinding)) {
              bindingType = "setup-const";
            } else if (isConst) {
              if (isCallOf(init, userImportAlias["ref"] || "ref")) {
                bindingType = "setup-ref";
              } else {
                bindingType = "setup-maybe-ref";
              }
            } else {
              bindingType = "setup-let";
            }
            registerBinding(bindings, id, bindingType);
          } else if (id.type === "ObjectPattern") {
            walkObjectPattern(id, bindings, isConst, isDefineCall);
          } else if (id.type === "ArrayPattern") {
            walkArrayPattern(id, bindings, isConst, isDefineCall);
          }
        }
      } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
        bindings[node.id.name] = {
          type: "setup-const",
          rangeNode: node.id
        };
      }
    }
    function walkObjectPattern(node, bindings, isConst, isDefineCall = false) {
      for (const p of node.properties) {
        if (p.type === "ObjectProperty") {
          if (p.key.type === "Identifier") {
            if (p.key === p.value) {
              const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
              registerBinding(bindings, p.key, type);
            } else {
              walkPattern(p.value, bindings, isConst, isDefineCall);
            }
          }
        } else {
          const type = isConst ? "setup-const" : "setup-let";
          registerBinding(bindings, p.argument, type);
        }
      }
    }
    function walkArrayPattern(node, bindings, isConst, isDefineCall = false) {
      for (const e of node.elements) {
        e && walkPattern(e, bindings, isConst, isDefineCall);
      }
    }
    function walkPattern(node, bindings, isConst, isDefineCall = false) {
      if (node.type === "Identifier") {
        const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
        registerBinding(bindings, node, type);
      } else if (node.type === "RestElement") {
        const type = isConst ? "setup-const" : "setup-let";
        registerBinding(bindings, node.argument, type);
      } else if (node.type === "ObjectPattern") {
        walkObjectPattern(node, bindings, isConst);
      } else if (node.type === "ArrayPattern") {
        walkArrayPattern(node, bindings, isConst);
      } else if (node.type === "AssignmentPattern") {
        if (node.left.type === "Identifier") {
          const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
          registerBinding(bindings, node.left, type);
        } else {
          walkPattern(node.left, bindings, isConst);
        }
      }
    }
    function recordType(node, declaredTypes) {
      if (node.type === "TSInterfaceDeclaration") {
        declaredTypes[node.id.name] = [`Object`];
      } else if (node.type === "TSTypeAliasDeclaration") {
        declaredTypes[node.id.name] = inferRuntimeType(node.typeAnnotation, declaredTypes);
      } else if (node.type === "ExportNamedDeclaration" && node.declaration) {
        recordType(node.declaration, declaredTypes);
      }
    }
    function extractRuntimeProps(node, props, declaredTypes) {
      const members = node.type === "TSTypeLiteral" ? node.members : node.body;
      for (const m of members) {
        if ((m.type === "TSPropertySignature" || m.type === "TSMethodSignature") && m.key.type === "Identifier") {
          let type;
          {
            if (m.type === "TSMethodSignature") {
              type = ["Function"];
            } else if (m.typeAnnotation) {
              type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
            }
          }
          props[m.key.name] = {
            key: m.key.name,
            required: !m.optional,
            type: type || [`null`]
          };
        }
      }
    }
    function inferRuntimeType(node, declaredTypes) {
      switch (node.type) {
        case "TSStringKeyword":
          return ["String"];
        case "TSNumberKeyword":
          return ["Number"];
        case "TSBooleanKeyword":
          return ["Boolean"];
        case "TSObjectKeyword":
          return ["Object"];
        case "TSTypeLiteral":
          return ["Object"];
        case "TSFunctionType":
          return ["Function"];
        case "TSArrayType":
        case "TSTupleType":
          return ["Array"];
        case "TSLiteralType":
          switch (node.literal.type) {
            case "StringLiteral":
              return ["String"];
            case "BooleanLiteral":
              return ["Boolean"];
            case "NumericLiteral":
            case "BigIntLiteral":
              return ["Number"];
            default:
              return [`null`];
          }
        case "TSTypeReference":
          if (node.typeName.type === "Identifier") {
            if (declaredTypes[node.typeName.name]) {
              return declaredTypes[node.typeName.name];
            }
            switch (node.typeName.name) {
              case "Array":
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
                return [node.typeName.name];
              case "Record":
              case "Partial":
              case "Readonly":
              case "Pick":
              case "Omit":
              case "Exclude":
              case "Extract":
              case "Required":
              case "InstanceType":
                return ["Object"];
            }
          }
          return [`null`];
        case "TSParenthesizedType":
          return inferRuntimeType(node.typeAnnotation, declaredTypes);
        case "TSUnionType":
          return [
            ...new Set([].concat(...node.types.map((t2) => inferRuntimeType(t2, declaredTypes))))
          ];
        case "TSIntersectionType":
          return ["Object"];
        default:
          return [`null`];
      }
    }
    function toRuntimeTypeString(types) {
      return types.length > 1 ? `[${types.join(", ")}]` : types[0];
    }
    function extractRuntimeEmits(node, emits) {
      if (node.type === "TSTypeLiteral" || node.type === "TSInterfaceBody") {
        const members = node.type === "TSTypeLiteral" ? node.members : node.body;
        for (let t2 of members) {
          if (t2.type === "TSCallSignatureDeclaration") {
            extractEventNames(t2.parameters[0], emits);
          }
        }
        return;
      } else {
        extractEventNames(node.parameters[0], emits);
      }
    }
    function extractEventNames(eventName, emits) {
      if (eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
        const typeNode = eventName.typeAnnotation.typeAnnotation;
        if (typeNode.type === "TSLiteralType") {
          emits.add(String(typeNode.literal.value));
        } else if (typeNode.type === "TSUnionType") {
          for (const t2 of typeNode.types) {
            if (t2.type === "TSLiteralType") {
              emits.add(String(t2.literal.value));
            }
          }
        }
      }
    }
    function genRuntimeEmits(emits) {
      return emits.size ? `
  emits: [${Array.from(emits).map((p) => JSON.stringify(p)).join(", ")}] as unknown as undefined,` : ``;
    }
    function markScopeIdentifier(node, child, knownIds) {
      const { name } = child;
      if (node.scopeIds && node.scopeIds.has(name)) {
        return;
      }
      if (name in knownIds) {
        knownIds[name]++;
      } else {
        knownIds[name] = 1;
      }
      (node.scopeIds || (node.scopeIds = new Set())).add(name);
    }
    function walkIdentifiers(root, onIdentifier, onNode) {
      const parentStack = [];
      const knownIds = Object.create(null);
      estreeWalker.walk(root, {
        enter(node, parent) {
          parent && parentStack.push(parent);
          if (parent && parent.type.startsWith("TS") && parent.type !== "TSAsExpression" && parent.type !== "TSNonNullExpression" && parent.type !== "TSTypeAssertion") {
            return this.skip();
          }
          if (onNode && onNode(node, parent, parentStack) === false) {
            return this.skip();
          }
          if (node.type === "Identifier") {
            if (!knownIds[node.name] && isRefIdentifier(node, parent, parentStack)) {
              onIdentifier(node, parent, parentStack);
            }
          } else if (isFunction(node)) {
            if (node.body.type === "BlockStatement") {
              node.body.body.forEach((p) => {
                if (p.type === "VariableDeclaration") {
                  for (const decl of p.declarations) {
                    extractIdentifiers(decl.id).forEach((id) => {
                      markScopeIdentifier(node, id, knownIds);
                    });
                  }
                }
              });
            }
            node.params.forEach((p) => estreeWalker.walk(p, {
              enter(child, parent2) {
                if (child.type === "Identifier" && !isStaticPropertyKey(child, parent2) && !(parent2 && parent2.type === "AssignmentPattern" && parent2.right === child)) {
                  markScopeIdentifier(node, child, knownIds);
                }
              }
            }));
          } else if (node.type === "ObjectProperty" && parent.type === "ObjectPattern") {
            node.inPattern = true;
          }
        },
        leave(node, parent) {
          parent && parentStack.pop();
          if (node.scopeIds) {
            node.scopeIds.forEach((id) => {
              knownIds[id]--;
              if (knownIds[id] === 0) {
                delete knownIds[id];
              }
            });
          }
        }
      });
    }
    function isRefIdentifier(id, parent, parentStack) {
      if (!parent) {
        return true;
      }
      if ((parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
        return false;
      }
      if (isFunction(parent)) {
        if (parent.id === id) {
          return false;
        }
        if (parent.params.includes(id)) {
          return false;
        }
      }
      if (isStaticPropertyKey(id, parent)) {
        return false;
      }
      if (parent.type === "ArrayPattern" && !isInDestructureAssignment(parent, parentStack)) {
        return false;
      }
      if ((parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && parent.property === id && !parent.computed) {
        return false;
      }
      if (id.name === "arguments") {
        return false;
      }
      return true;
    }
    var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    function isFunction(node) {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    }
    function isCallOf(node, test) {
      return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
    }
    function canNeverBeRef(node, userReactiveImport) {
      if (isCallOf(node, userReactiveImport)) {
        return true;
      }
      switch (node.type) {
        case "UnaryExpression":
        case "BinaryExpression":
        case "ArrayExpression":
        case "ObjectExpression":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "UpdateExpression":
        case "ClassExpression":
        case "TaggedTemplateExpression":
          return true;
        case "SequenceExpression":
          return canNeverBeRef(node.expressions[node.expressions.length - 1], userReactiveImport);
        default:
          if (node.type.endsWith("Literal")) {
            return true;
          }
          return false;
      }
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i = parentStack.length;
        while (i--) {
          const p = parentStack[i];
          if (p.type === "AssignmentExpression") {
            const root = parentStack[0];
            return !(root.type === "LabeledStatement" && root.label.name === "ref");
          } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function analyzeScriptBindings(ast) {
      for (const node of ast) {
        if (node.type === "ExportDefaultDeclaration" && node.declaration.type === "ObjectExpression") {
          return analyzeBindingsFromOptions(node.declaration);
        }
      }
      return {};
    }
    function analyzeBindingsFromOptions(node) {
      const bindings = {};
      Object.defineProperty(bindings, "__isScriptSetup", {
        enumerable: false,
        value: false
      });
      for (const property of node.properties) {
        if (property.type === "ObjectProperty" && !property.computed && property.key.type === "Identifier") {
          if (property.key.name === "props") {
            for (const key of getObjectOrArrayExpressionKeys(property.value)) {
              bindings[key] = "props";
            }
          } else if (property.key.name === "inject") {
            for (const key of getObjectOrArrayExpressionKeys(property.value)) {
              bindings[key] = "options";
            }
          } else if (property.value.type === "ObjectExpression" && (property.key.name === "computed" || property.key.name === "methods")) {
            for (const key of getObjectExpressionKeys(property.value)) {
              bindings[key] = "options";
            }
          }
        } else if (property.type === "ObjectMethod" && property.key.type === "Identifier" && (property.key.name === "setup" || property.key.name === "data")) {
          for (const bodyItem of property.body.body) {
            if (bodyItem.type === "ReturnStatement" && bodyItem.argument && bodyItem.argument.type === "ObjectExpression") {
              for (const key of getObjectExpressionKeys(bodyItem.argument)) {
                bindings[key] = property.key.name === "setup" ? "setup-maybe-ref" : "data";
              }
            }
          }
        }
      }
      return bindings;
    }
    function getObjectExpressionKeys(node) {
      const keys = [];
      for (const prop of node.properties) {
        if ((prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && !prop.computed) {
          if (prop.key.type === "Identifier") {
            keys.push(prop.key.name);
          } else if (prop.key.type === "StringLiteral") {
            keys.push(prop.key.value);
          }
        }
      }
      return keys;
    }
    function getArrayExpressionKeys(node) {
      const keys = [];
      for (const element of node.elements) {
        if (element && element.type === "StringLiteral") {
          keys.push(element.value);
        }
      }
      return keys;
    }
    function getObjectOrArrayExpressionKeys(value) {
      if (value.type === "ArrayExpression") {
        return getArrayExpressionKeys(value);
      }
      if (value.type === "ObjectExpression") {
        return getObjectExpressionKeys(value);
      }
      return [];
    }
    function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          param.properties.forEach((prop) => {
            if (prop.type === "RestElement") {
              extractIdentifiers(prop.argument, nodes);
            } else {
              extractIdentifiers(prop.value, nodes);
            }
          });
          break;
        case "ArrayPattern":
          param.elements.forEach((element) => {
            if (element)
              extractIdentifiers(element, nodes);
          });
          break;
        case "RestElement":
          extractIdentifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extractIdentifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    function toTextRange(node) {
      return {
        start: node.start,
        end: node.end
      };
    }
    var templateUsageCheckCache = createCache();
    function resolveTemplateUsageCheckString(sfc) {
      const { content, ast } = sfc.template;
      const cached = templateUsageCheckCache.get(content);
      if (cached) {
        return cached;
      }
      let code = "";
      CompilerDOM.transform(CompilerDOM.createRoot([ast]), {
        nodeTransforms: [
          (node) => {
            if (node.type === 1) {
              if (!CompilerDOM.parserOptions.isNativeTag(node.tag) && !CompilerDOM.parserOptions.isBuiltInComponent(node.tag)) {
                code += `,${shared.camelize(node.tag)},${shared.capitalize(shared.camelize(node.tag))}`;
              }
              for (let i = 0; i < node.props.length; i++) {
                const prop = node.props[i];
                if (prop.type === 7) {
                  if (!isBuiltInDir(prop.name)) {
                    code += `,v${shared.capitalize(shared.camelize(prop.name))}`;
                  }
                  if (prop.exp) {
                    code += `,${stripStrings(prop.exp.content)}`;
                  }
                }
              }
            } else if (node.type === 5) {
              code += `,${stripStrings(node.content.content)}`;
            }
          }
        ]
      });
      code += ";";
      templateUsageCheckCache.set(content, code);
      return code;
    }
    function stripStrings(exp) {
      return exp.replace(/'[^']+'|"[^"]+"/g, "").replace(/`[^`]+`/g, stripTemplateString);
    }
    function stripTemplateString(str) {
      const interpMatch = str.match(/\${[^}]+}/g);
      if (interpMatch) {
        return interpMatch.map((m) => m.slice(2, -1)).join(",");
      }
      return "";
    }
    exports2.generateCodeFrame = compilerCore.generateCodeFrame;
    exports2.MagicString = MagicString__default;
    exports2.babelParse = parser.parse;
    exports2.walk = estreeWalker.walk;
    exports2.compileScript = compileScript;
    exports2.compileStyle = compileStyle;
    exports2.compileStyleAsync = compileStyleAsync;
    exports2.compileTemplate = compileTemplate;
    exports2.parse = parse3;
    exports2.rewriteDefault = rewriteDefault;
    exports2.walkIdentifiers = walkIdentifiers;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/base64.js
var require_base643 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base643();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/util.js
var require_util6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj2 = Object.create(null);
      return !("__proto__" in obj2);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/array-set.js
var require_array_set3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/array-set.js"(exports2) {
    var util = require_util6();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/mapping-list.js
var require_mapping_list3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util6();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq3();
    var util = require_util6();
    var ArraySet = require_array_set3().ArraySet;
    var MappingList = require_mapping_list3().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/binary-search.js
var require_binary_search3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/quick-sort.js
var require_quick_sort3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/quick-sort.js"(exports2) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util6();
    var binarySearch = require_binary_search3();
    var ArraySet = require_array_set3().ArraySet;
    var base64VLQ = require_base64_vlq3();
    var quickSort = require_quick_sort3().quickSort;
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
        }, this);
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"))
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret2 = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret2;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-node.js
var require_source_node3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator3().SourceMapGenerator;
    var util = require_util6();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/source-map.js
var require_source_map3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/source-map-npm-0.5.7-7c3f035429-5dc2043b93.zip/node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator3().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer3().SourceMapConsumer;
    exports2.SourceNode = require_source_node3().SourceNode;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/source-map.js
var require_source_map4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/source-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _sourceMap = require_source_map3();
    var SourceMap = class {
      constructor(opts, code) {
        this._cachedMap = void 0;
        this._code = void 0;
        this._opts = void 0;
        this._rawMappings = void 0;
        this._lastGenLine = void 0;
        this._lastSourceLine = void 0;
        this._lastSourceColumn = void 0;
        this._cachedMap = null;
        this._code = code;
        this._opts = opts;
        this._rawMappings = [];
      }
      get() {
        if (!this._cachedMap) {
          const map = this._cachedMap = new _sourceMap.SourceMapGenerator({
            sourceRoot: this._opts.sourceRoot
          });
          const code = this._code;
          if (typeof code === "string") {
            map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
          } else if (typeof code === "object") {
            Object.keys(code).forEach((sourceFileName) => {
              map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
            });
          }
          this._rawMappings.forEach((mapping) => map.addMapping(mapping), map);
        }
        return this._cachedMap.toJSON();
      }
      getRawMappings() {
        return this._rawMappings.slice();
      }
      mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
        if (this._lastGenLine !== generatedLine && line === null)
          return;
        if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
          return;
        }
        this._cachedMap = null;
        this._lastGenLine = generatedLine;
        this._lastSourceLine = line;
        this._lastSourceColumn = column;
        this._rawMappings.push({
          name: identifierName || void 0,
          generated: {
            line: generatedLine,
            column: generatedColumn
          },
          source: line == null ? void 0 : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
          original: line == null ? void 0 : {
            line,
            column
          }
        });
      }
    };
    exports2.default = SourceMap;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var SPACES_RE = /^[ \t]+$/;
    var Buffer2 = class {
      constructor(map) {
        this._map = null;
        this._buf = "";
        this._last = 0;
        this._queue = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: null,
          line: null,
          column: null,
          filename: null
        };
        this._disallowedPop = null;
        this._map = map;
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: this._buf.trimRight(),
          map: null,
          rawMappings: map == null ? void 0 : map.getRawMappings()
        };
        if (map) {
          Object.defineProperty(result, "map", {
            configurable: true,
            enumerable: true,
            get() {
              return this.map = map.get();
            },
            set(value) {
              Object.defineProperty(this, "map", {
                value,
                writable: true
              });
            }
          });
        }
        return result;
      }
      append(str) {
        this._flush();
        const {
          line,
          column,
          filename,
          identifierName,
          force
        } = this._sourcePosition;
        this._append(str, line, column, identifierName, filename, force);
      }
      queue(str) {
        if (str === "\n") {
          while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
            this._queue.shift();
          }
        }
        const {
          line,
          column,
          filename,
          identifierName,
          force
        } = this._sourcePosition;
        this._queue.unshift([str, line, column, identifierName, filename, force]);
      }
      _flush() {
        let item;
        while (item = this._queue.pop()) {
          this._append(...item);
        }
      }
      _append(str, line, column, identifierName, filename, force) {
        this._buf += str;
        this._last = str.charCodeAt(str.length - 1);
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, filename, force);
        }
        while (i !== -1) {
          this._position.line++;
          this._position.column = 0;
          last = i + 1;
          if (last < str.length) {
            this._mark(++line, 0, identifierName, filename, force);
          }
          i = str.indexOf("\n", last);
        }
        this._position.column += str.length - last;
      }
      _mark(line, column, identifierName, filename, force) {
        var _this$_map;
        (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
      }
      removeTrailingNewline() {
        if (this._queue.length > 0 && this._queue[0][0] === "\n") {
          this._queue.shift();
        }
      }
      removeLastSemicolon() {
        if (this._queue.length > 0 && this._queue[0][0] === ";") {
          this._queue.shift();
        }
      }
      getLastChar() {
        let last;
        if (this._queue.length > 0) {
          const str = this._queue[0][0];
          last = str.charCodeAt(0);
        } else {
          last = this._last;
        }
        return last;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        if (queue.length > 0) {
          const last = queue[0][0];
          const lastCp = last.charCodeAt(0);
          if (lastCp !== 10)
            return;
          if (queue.length > 1) {
            const secondLast = queue[1][0];
            return secondLast.charCodeAt(0);
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queue.length > 0 || !!this._last;
      }
      exactSource(loc, cb) {
        this.source("start", loc, true);
        cb();
        this.source("end", loc);
        this._disallowPop("start", loc);
      }
      source(prop, loc, force) {
        if (prop && !loc)
          return;
        this._normalizePosition(prop, loc, this._sourcePosition, force);
      }
      withSource(prop, loc, cb) {
        if (!this._map)
          return cb();
        const originalLine = this._sourcePosition.line;
        const originalColumn = this._sourcePosition.column;
        const originalFilename = this._sourcePosition.filename;
        const originalIdentifierName = this._sourcePosition.identifierName;
        this.source(prop, loc);
        cb();
        if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
          this._sourcePosition.line = originalLine;
          this._sourcePosition.column = originalColumn;
          this._sourcePosition.filename = originalFilename;
          this._sourcePosition.identifierName = originalIdentifierName;
          this._sourcePosition.force = false;
          this._disallowedPop = null;
        }
      }
      _disallowPop(prop, loc) {
        if (prop && !loc)
          return;
        this._disallowedPop = this._normalizePosition(prop, loc);
      }
      _normalizePosition(prop, loc, targetObj, force) {
        const pos = loc ? loc[prop] : null;
        if (targetObj === void 0) {
          targetObj = {
            identifierName: null,
            line: null,
            column: null,
            filename: null,
            force: false
          };
        }
        const origLine = targetObj.line;
        const origColumn = targetObj.column;
        const origFilename = targetObj.filename;
        targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;
        targetObj.line = pos == null ? void 0 : pos.line;
        targetObj.column = pos == null ? void 0 : pos.column;
        targetObj.filename = loc == null ? void 0 : loc.filename;
        if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
          targetObj.force = force;
        }
        return targetObj;
      }
      getCurrentColumn() {
        const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
        const lastIndex = extra.lastIndexOf("\n");
        return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
      }
      getCurrentLine() {
        const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
        let count = 0;
        for (let i = 0; i < extra.length; i++) {
          if (extra[i] === "\n")
            count++;
        }
        return this._position.line + count;
      }
    };
    exports2.default = Buffer2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/shallowEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys = Object.keys(expected);
      for (const key of keys) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isArrayExpression = isArrayExpression;
    exports2.isAssignmentExpression = isAssignmentExpression;
    exports2.isBinaryExpression = isBinaryExpression;
    exports2.isInterpreterDirective = isInterpreterDirective;
    exports2.isDirective = isDirective;
    exports2.isDirectiveLiteral = isDirectiveLiteral;
    exports2.isBlockStatement = isBlockStatement;
    exports2.isBreakStatement = isBreakStatement;
    exports2.isCallExpression = isCallExpression;
    exports2.isCatchClause = isCatchClause;
    exports2.isConditionalExpression = isConditionalExpression;
    exports2.isContinueStatement = isContinueStatement;
    exports2.isDebuggerStatement = isDebuggerStatement;
    exports2.isDoWhileStatement = isDoWhileStatement;
    exports2.isEmptyStatement = isEmptyStatement;
    exports2.isExpressionStatement = isExpressionStatement;
    exports2.isFile = isFile;
    exports2.isForInStatement = isForInStatement;
    exports2.isForStatement = isForStatement;
    exports2.isFunctionDeclaration = isFunctionDeclaration;
    exports2.isFunctionExpression = isFunctionExpression;
    exports2.isIdentifier = isIdentifier2;
    exports2.isIfStatement = isIfStatement;
    exports2.isLabeledStatement = isLabeledStatement;
    exports2.isStringLiteral = isStringLiteral;
    exports2.isNumericLiteral = isNumericLiteral;
    exports2.isNullLiteral = isNullLiteral;
    exports2.isBooleanLiteral = isBooleanLiteral;
    exports2.isRegExpLiteral = isRegExpLiteral;
    exports2.isLogicalExpression = isLogicalExpression;
    exports2.isMemberExpression = isMemberExpression;
    exports2.isNewExpression = isNewExpression;
    exports2.isProgram = isProgram;
    exports2.isObjectExpression = isObjectExpression;
    exports2.isObjectMethod = isObjectMethod;
    exports2.isObjectProperty = isObjectProperty;
    exports2.isRestElement = isRestElement;
    exports2.isReturnStatement = isReturnStatement;
    exports2.isSequenceExpression = isSequenceExpression;
    exports2.isParenthesizedExpression = isParenthesizedExpression;
    exports2.isSwitchCase = isSwitchCase;
    exports2.isSwitchStatement = isSwitchStatement;
    exports2.isThisExpression = isThisExpression;
    exports2.isThrowStatement = isThrowStatement;
    exports2.isTryStatement = isTryStatement;
    exports2.isUnaryExpression = isUnaryExpression;
    exports2.isUpdateExpression = isUpdateExpression;
    exports2.isVariableDeclaration = isVariableDeclaration;
    exports2.isVariableDeclarator = isVariableDeclarator;
    exports2.isWhileStatement = isWhileStatement;
    exports2.isWithStatement = isWithStatement;
    exports2.isAssignmentPattern = isAssignmentPattern;
    exports2.isArrayPattern = isArrayPattern;
    exports2.isArrowFunctionExpression = isArrowFunctionExpression;
    exports2.isClassBody = isClassBody;
    exports2.isClassExpression = isClassExpression;
    exports2.isClassDeclaration = isClassDeclaration;
    exports2.isExportAllDeclaration = isExportAllDeclaration;
    exports2.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports2.isExportNamedDeclaration = isExportNamedDeclaration;
    exports2.isExportSpecifier = isExportSpecifier;
    exports2.isForOfStatement = isForOfStatement;
    exports2.isImportDeclaration = isImportDeclaration;
    exports2.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports2.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports2.isImportSpecifier = isImportSpecifier;
    exports2.isMetaProperty = isMetaProperty;
    exports2.isClassMethod = isClassMethod;
    exports2.isObjectPattern = isObjectPattern;
    exports2.isSpreadElement = isSpreadElement;
    exports2.isSuper = isSuper;
    exports2.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports2.isTemplateElement = isTemplateElement;
    exports2.isTemplateLiteral = isTemplateLiteral;
    exports2.isYieldExpression = isYieldExpression;
    exports2.isAwaitExpression = isAwaitExpression;
    exports2.isImport = isImport;
    exports2.isBigIntLiteral = isBigIntLiteral;
    exports2.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports2.isOptionalMemberExpression = isOptionalMemberExpression;
    exports2.isOptionalCallExpression = isOptionalCallExpression;
    exports2.isClassProperty = isClassProperty;
    exports2.isClassPrivateProperty = isClassPrivateProperty;
    exports2.isClassPrivateMethod = isClassPrivateMethod;
    exports2.isPrivateName = isPrivateName;
    exports2.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports2.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports2.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports2.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports2.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports2.isClassImplements = isClassImplements;
    exports2.isDeclareClass = isDeclareClass;
    exports2.isDeclareFunction = isDeclareFunction;
    exports2.isDeclareInterface = isDeclareInterface;
    exports2.isDeclareModule = isDeclareModule;
    exports2.isDeclareModuleExports = isDeclareModuleExports;
    exports2.isDeclareTypeAlias = isDeclareTypeAlias;
    exports2.isDeclareOpaqueType = isDeclareOpaqueType;
    exports2.isDeclareVariable = isDeclareVariable;
    exports2.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports2.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports2.isDeclaredPredicate = isDeclaredPredicate;
    exports2.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports2.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports2.isFunctionTypeParam = isFunctionTypeParam;
    exports2.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports2.isInferredPredicate = isInferredPredicate;
    exports2.isInterfaceExtends = isInterfaceExtends;
    exports2.isInterfaceDeclaration = isInterfaceDeclaration;
    exports2.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports2.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports2.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports2.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports2.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports2.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports2.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports2.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports2.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports2.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports2.isObjectTypeIndexer = isObjectTypeIndexer;
    exports2.isObjectTypeProperty = isObjectTypeProperty;
    exports2.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports2.isOpaqueType = isOpaqueType;
    exports2.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports2.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports2.isStringTypeAnnotation = isStringTypeAnnotation;
    exports2.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports2.isThisTypeAnnotation = isThisTypeAnnotation;
    exports2.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports2.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports2.isTypeAlias = isTypeAlias;
    exports2.isTypeAnnotation = isTypeAnnotation;
    exports2.isTypeCastExpression = isTypeCastExpression;
    exports2.isTypeParameter = isTypeParameter;
    exports2.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports2.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports2.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports2.isVariance = isVariance;
    exports2.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports2.isEnumDeclaration = isEnumDeclaration;
    exports2.isEnumBooleanBody = isEnumBooleanBody;
    exports2.isEnumNumberBody = isEnumNumberBody;
    exports2.isEnumStringBody = isEnumStringBody;
    exports2.isEnumSymbolBody = isEnumSymbolBody;
    exports2.isEnumBooleanMember = isEnumBooleanMember;
    exports2.isEnumNumberMember = isEnumNumberMember;
    exports2.isEnumStringMember = isEnumStringMember;
    exports2.isEnumDefaultedMember = isEnumDefaultedMember;
    exports2.isIndexedAccessType = isIndexedAccessType;
    exports2.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports2.isJSXAttribute = isJSXAttribute;
    exports2.isJSXClosingElement = isJSXClosingElement;
    exports2.isJSXElement = isJSXElement;
    exports2.isJSXEmptyExpression = isJSXEmptyExpression;
    exports2.isJSXExpressionContainer = isJSXExpressionContainer;
    exports2.isJSXSpreadChild = isJSXSpreadChild;
    exports2.isJSXIdentifier = isJSXIdentifier;
    exports2.isJSXMemberExpression = isJSXMemberExpression;
    exports2.isJSXNamespacedName = isJSXNamespacedName;
    exports2.isJSXOpeningElement = isJSXOpeningElement;
    exports2.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports2.isJSXText = isJSXText;
    exports2.isJSXFragment = isJSXFragment;
    exports2.isJSXOpeningFragment = isJSXOpeningFragment;
    exports2.isJSXClosingFragment = isJSXClosingFragment;
    exports2.isNoop = isNoop;
    exports2.isPlaceholder = isPlaceholder;
    exports2.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports2.isArgumentPlaceholder = isArgumentPlaceholder;
    exports2.isBindExpression = isBindExpression;
    exports2.isImportAttribute = isImportAttribute;
    exports2.isDecorator = isDecorator;
    exports2.isDoExpression = isDoExpression;
    exports2.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports2.isRecordExpression = isRecordExpression;
    exports2.isTupleExpression = isTupleExpression;
    exports2.isDecimalLiteral = isDecimalLiteral;
    exports2.isStaticBlock = isStaticBlock;
    exports2.isModuleExpression = isModuleExpression;
    exports2.isTopicReference = isTopicReference;
    exports2.isPipelineTopicExpression = isPipelineTopicExpression;
    exports2.isPipelineBareFunction = isPipelineBareFunction;
    exports2.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports2.isTSParameterProperty = isTSParameterProperty;
    exports2.isTSDeclareFunction = isTSDeclareFunction;
    exports2.isTSDeclareMethod = isTSDeclareMethod;
    exports2.isTSQualifiedName = isTSQualifiedName;
    exports2.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports2.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports2.isTSPropertySignature = isTSPropertySignature;
    exports2.isTSMethodSignature = isTSMethodSignature;
    exports2.isTSIndexSignature = isTSIndexSignature;
    exports2.isTSAnyKeyword = isTSAnyKeyword;
    exports2.isTSBooleanKeyword = isTSBooleanKeyword;
    exports2.isTSBigIntKeyword = isTSBigIntKeyword;
    exports2.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports2.isTSNeverKeyword = isTSNeverKeyword;
    exports2.isTSNullKeyword = isTSNullKeyword;
    exports2.isTSNumberKeyword = isTSNumberKeyword;
    exports2.isTSObjectKeyword = isTSObjectKeyword;
    exports2.isTSStringKeyword = isTSStringKeyword;
    exports2.isTSSymbolKeyword = isTSSymbolKeyword;
    exports2.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports2.isTSUnknownKeyword = isTSUnknownKeyword;
    exports2.isTSVoidKeyword = isTSVoidKeyword;
    exports2.isTSThisType = isTSThisType;
    exports2.isTSFunctionType = isTSFunctionType;
    exports2.isTSConstructorType = isTSConstructorType;
    exports2.isTSTypeReference = isTSTypeReference;
    exports2.isTSTypePredicate = isTSTypePredicate;
    exports2.isTSTypeQuery = isTSTypeQuery;
    exports2.isTSTypeLiteral = isTSTypeLiteral;
    exports2.isTSArrayType = isTSArrayType;
    exports2.isTSTupleType = isTSTupleType;
    exports2.isTSOptionalType = isTSOptionalType;
    exports2.isTSRestType = isTSRestType;
    exports2.isTSNamedTupleMember = isTSNamedTupleMember;
    exports2.isTSUnionType = isTSUnionType;
    exports2.isTSIntersectionType = isTSIntersectionType;
    exports2.isTSConditionalType = isTSConditionalType;
    exports2.isTSInferType = isTSInferType;
    exports2.isTSParenthesizedType = isTSParenthesizedType;
    exports2.isTSTypeOperator = isTSTypeOperator;
    exports2.isTSIndexedAccessType = isTSIndexedAccessType;
    exports2.isTSMappedType = isTSMappedType;
    exports2.isTSLiteralType = isTSLiteralType;
    exports2.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports2.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports2.isTSInterfaceBody = isTSInterfaceBody;
    exports2.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports2.isTSAsExpression = isTSAsExpression;
    exports2.isTSTypeAssertion = isTSTypeAssertion;
    exports2.isTSEnumDeclaration = isTSEnumDeclaration;
    exports2.isTSEnumMember = isTSEnumMember;
    exports2.isTSModuleDeclaration = isTSModuleDeclaration;
    exports2.isTSModuleBlock = isTSModuleBlock;
    exports2.isTSImportType = isTSImportType;
    exports2.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports2.isTSExternalModuleReference = isTSExternalModuleReference;
    exports2.isTSNonNullExpression = isTSNonNullExpression;
    exports2.isTSExportAssignment = isTSExportAssignment;
    exports2.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports2.isTSTypeAnnotation = isTSTypeAnnotation;
    exports2.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports2.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports2.isTSTypeParameter = isTSTypeParameter;
    exports2.isExpression = isExpression;
    exports2.isBinary = isBinary;
    exports2.isScopable = isScopable;
    exports2.isBlockParent = isBlockParent;
    exports2.isBlock = isBlock;
    exports2.isStatement = isStatement;
    exports2.isTerminatorless = isTerminatorless;
    exports2.isCompletionStatement = isCompletionStatement;
    exports2.isConditional = isConditional;
    exports2.isLoop = isLoop;
    exports2.isWhile = isWhile;
    exports2.isExpressionWrapper = isExpressionWrapper;
    exports2.isFor = isFor;
    exports2.isForXStatement = isForXStatement;
    exports2.isFunction = isFunction;
    exports2.isFunctionParent = isFunctionParent;
    exports2.isPureish = isPureish;
    exports2.isDeclaration = isDeclaration;
    exports2.isPatternLike = isPatternLike;
    exports2.isLVal = isLVal;
    exports2.isTSEntityName = isTSEntityName;
    exports2.isLiteral = isLiteral;
    exports2.isImmutable = isImmutable;
    exports2.isUserWhitespacable = isUserWhitespacable;
    exports2.isMethod = isMethod;
    exports2.isObjectMember = isObjectMember;
    exports2.isProperty = isProperty;
    exports2.isUnaryLike = isUnaryLike;
    exports2.isPattern = isPattern;
    exports2.isClass = isClass2;
    exports2.isModuleDeclaration = isModuleDeclaration;
    exports2.isExportDeclaration = isExportDeclaration;
    exports2.isModuleSpecifier = isModuleSpecifier;
    exports2.isPrivate = isPrivate;
    exports2.isFlow = isFlow;
    exports2.isFlowType = isFlowType;
    exports2.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports2.isFlowDeclaration = isFlowDeclaration;
    exports2.isFlowPredicate = isFlowPredicate;
    exports2.isEnumBody = isEnumBody;
    exports2.isEnumMember = isEnumMember;
    exports2.isJSX = isJSX;
    exports2.isTSTypeElement = isTSTypeElement;
    exports2.isTSType = isTSType;
    exports2.isTSBaseType = isTSBaseType;
    exports2.isNumberLiteral = isNumberLiteral;
    exports2.isRegexLiteral = isRegexLiteral;
    exports2.isRestProperty = isRestProperty;
    exports2.isSpreadProperty = isSpreadProperty;
    var _shallowEqual = require_shallowEqual();
    function isArrayExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAssignmentExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBinaryExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterpreterDirective(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDirective(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Directive") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDirectiveLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlockStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBreakStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCallExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCatchClause(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isConditionalExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isContinueStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDebuggerStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDoWhileStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEmptyStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpressionStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFile(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "File") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForInStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIdentifier2(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Identifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIfStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLabeledStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumericLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRegExpLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLogicalExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNewExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isProgram(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Program") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRestElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RestElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isReturnStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSequenceExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isParenthesizedExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSwitchCase(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSwitchStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThisExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThrowStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTryStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnaryExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUpdateExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariableDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariableDeclarator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWhileStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWithStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAssignmentPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrayPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForOfStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMetaProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSpreadElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSuper(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Super") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTemplateElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTemplateLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isYieldExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAwaitExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImport(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Import") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBigIntLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalCallExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassPrivateProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassPrivateMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPrivateName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClassImplements(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareClass(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareInterface(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareModule(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareModuleExports(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareVariable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclaredPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionTypeParam(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInferredPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceExtends(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOpaqueType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeAlias(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeCastExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameter(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVariance(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Variance") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBooleanBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumNumberBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumStringBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumSymbolBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBooleanMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumNumberMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumStringMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "IndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXClosingElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXSpreadChild(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXMemberExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXNamespacedName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXOpeningElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXText(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXText") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSXClosingFragment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNoop(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Noop") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPlaceholder(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBindExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImportAttribute(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ImportAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDecorator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Decorator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDoExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRecordExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTupleExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDecimalLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DecimalLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStaticBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StaticBlock") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ModuleExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTopicReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TopicReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelineBareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSParameterProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSDeclareFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSDeclareMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSQualifiedName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSPropertySignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSMethodSignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIndexSignature(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSAnyKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIntrinsicKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNeverKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNullKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNumberKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSObjectKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSStringKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSVoidKeyword(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSThisType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSFunctionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConstructorType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypePredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeQuery(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSArrayType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTupleType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSOptionalType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSRestType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNamedTupleMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSUnionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIntersectionType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSConditionalType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInferType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSParenthesizedType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeOperator(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSMappedType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSLiteralType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSInterfaceBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSAsExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAssertion(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEnumMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSModuleBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSImportType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNonNullExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSExportAssignment(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeParameter(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpression(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ArrayExpression" || nodeType === "AssignmentExpression" || nodeType === "BinaryExpression" || nodeType === "CallExpression" || nodeType === "ConditionalExpression" || nodeType === "FunctionExpression" || nodeType === "Identifier" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "LogicalExpression" || nodeType === "MemberExpression" || nodeType === "NewExpression" || nodeType === "ObjectExpression" || nodeType === "SequenceExpression" || nodeType === "ParenthesizedExpression" || nodeType === "ThisExpression" || nodeType === "UnaryExpression" || nodeType === "UpdateExpression" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassExpression" || nodeType === "MetaProperty" || nodeType === "Super" || nodeType === "TaggedTemplateExpression" || nodeType === "TemplateLiteral" || nodeType === "YieldExpression" || nodeType === "AwaitExpression" || nodeType === "Import" || nodeType === "BigIntLiteral" || nodeType === "OptionalMemberExpression" || nodeType === "OptionalCallExpression" || nodeType === "TypeCastExpression" || nodeType === "JSXElement" || nodeType === "JSXFragment" || nodeType === "BindExpression" || nodeType === "DoExpression" || nodeType === "RecordExpression" || nodeType === "TupleExpression" || nodeType === "DecimalLiteral" || nodeType === "ModuleExpression" || nodeType === "TopicReference" || nodeType === "PipelineTopicExpression" || nodeType === "PipelineBareFunction" || nodeType === "PipelinePrimaryTopicReference" || nodeType === "TSAsExpression" || nodeType === "TSTypeAssertion" || nodeType === "TSNonNullExpression" || nodeType === "Placeholder" && (node.expectedNode === "Expression" || node.expectedNode === "Identifier" || node.expectedNode === "StringLiteral")) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBinary(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isScopable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement" || nodeType === "CatchClause" || nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "Program" || nodeType === "ObjectMethod" || nodeType === "SwitchStatement" || nodeType === "WhileStatement" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassExpression" || nodeType === "ClassDeclaration" || nodeType === "ForOfStatement" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod" || nodeType === "StaticBlock" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlockParent(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement" || nodeType === "CatchClause" || nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "Program" || nodeType === "ObjectMethod" || nodeType === "SwitchStatement" || nodeType === "WhileStatement" || nodeType === "ArrowFunctionExpression" || nodeType === "ForOfStatement" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod" || nodeType === "StaticBlock" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isBlock(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement" || nodeType === "Program" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BlockStatement" || nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "DebuggerStatement" || nodeType === "DoWhileStatement" || nodeType === "EmptyStatement" || nodeType === "ExpressionStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "IfStatement" || nodeType === "LabeledStatement" || nodeType === "ReturnStatement" || nodeType === "SwitchStatement" || nodeType === "ThrowStatement" || nodeType === "TryStatement" || nodeType === "VariableDeclaration" || nodeType === "WhileStatement" || nodeType === "WithStatement" || nodeType === "ClassDeclaration" || nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ForOfStatement" || nodeType === "ImportDeclaration" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias" || nodeType === "EnumDeclaration" || nodeType === "TSDeclareFunction" || nodeType === "TSInterfaceDeclaration" || nodeType === "TSTypeAliasDeclaration" || nodeType === "TSEnumDeclaration" || nodeType === "TSModuleDeclaration" || nodeType === "TSImportEqualsDeclaration" || nodeType === "TSExportAssignment" || nodeType === "TSNamespaceExportDeclaration" || nodeType === "Placeholder" && (node.expectedNode === "Statement" || node.expectedNode === "Declaration" || node.expectedNode === "BlockStatement")) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTerminatorless(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "ReturnStatement" || nodeType === "ThrowStatement" || nodeType === "YieldExpression" || nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isCompletionStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "ReturnStatement" || nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isConditional(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ConditionalExpression" || nodeType === "IfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLoop(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "WhileStatement" || nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isWhile(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DoWhileStatement" || nodeType === "WhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExpressionWrapper(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExpressionStatement" || nodeType === "ParenthesizedExpression" || nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFor(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isForXStatement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ForInStatement" || nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunction(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "ObjectMethod" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFunctionParent(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "ObjectMethod" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPureish(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "ArrowFunctionExpression" || nodeType === "BigIntLiteral" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "FunctionDeclaration" || nodeType === "VariableDeclaration" || nodeType === "ClassDeclaration" || nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ImportDeclaration" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias" || nodeType === "EnumDeclaration" || nodeType === "TSDeclareFunction" || nodeType === "TSInterfaceDeclaration" || nodeType === "TSTypeAliasDeclaration" || nodeType === "TSEnumDeclaration" || nodeType === "TSModuleDeclaration" || nodeType === "Placeholder" && node.expectedNode === "Declaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPatternLike(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Identifier" || nodeType === "RestElement" || nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "Placeholder" && (node.expectedNode === "Pattern" || node.expectedNode === "Identifier")) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLVal(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Identifier" || nodeType === "MemberExpression" || nodeType === "RestElement" || nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "TSParameterProperty" || nodeType === "Placeholder" && (node.expectedNode === "Pattern" || node.expectedNode === "Identifier")) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSEntityName(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "Identifier" || nodeType === "TSQualifiedName" || nodeType === "Placeholder" && node.expectedNode === "Identifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isLiteral(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "TemplateLiteral" || nodeType === "BigIntLiteral" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isImmutable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "BigIntLiteral" || nodeType === "JSXAttribute" || nodeType === "JSXClosingElement" || nodeType === "JSXElement" || nodeType === "JSXExpressionContainer" || nodeType === "JSXSpreadChild" || nodeType === "JSXOpeningElement" || nodeType === "JSXText" || nodeType === "JSXFragment" || nodeType === "JSXOpeningFragment" || nodeType === "JSXClosingFragment" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUserWhitespacable(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectMethod" || nodeType === "ObjectProperty" || nodeType === "ObjectTypeInternalSlot" || nodeType === "ObjectTypeCallProperty" || nodeType === "ObjectTypeIndexer" || nodeType === "ObjectTypeProperty" || nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isMethod(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectMethod" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isObjectMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectMethod" || nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isProperty(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ObjectProperty" || nodeType === "ClassProperty" || nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isUnaryLike(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "UnaryExpression" || nodeType === "SpreadElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPattern(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "Placeholder" && node.expectedNode === "Pattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isClass2(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassExpression" || nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isExportDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isModuleSpecifier(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ExportSpecifier" || nodeType === "ImportDefaultSpecifier" || nodeType === "ImportNamespaceSpecifier" || nodeType === "ImportSpecifier" || nodeType === "ExportNamespaceSpecifier" || nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isPrivate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "ClassPrivateProperty" || nodeType === "ClassPrivateMethod" || nodeType === "PrivateName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlow(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AnyTypeAnnotation" || nodeType === "ArrayTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "BooleanLiteralTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "ClassImplements" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "DeclaredPredicate" || nodeType === "ExistsTypeAnnotation" || nodeType === "FunctionTypeAnnotation" || nodeType === "FunctionTypeParam" || nodeType === "GenericTypeAnnotation" || nodeType === "InferredPredicate" || nodeType === "InterfaceExtends" || nodeType === "InterfaceDeclaration" || nodeType === "InterfaceTypeAnnotation" || nodeType === "IntersectionTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NullableTypeAnnotation" || nodeType === "NumberLiteralTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "ObjectTypeAnnotation" || nodeType === "ObjectTypeInternalSlot" || nodeType === "ObjectTypeCallProperty" || nodeType === "ObjectTypeIndexer" || nodeType === "ObjectTypeProperty" || nodeType === "ObjectTypeSpreadProperty" || nodeType === "OpaqueType" || nodeType === "QualifiedTypeIdentifier" || nodeType === "StringLiteralTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "TupleTypeAnnotation" || nodeType === "TypeofTypeAnnotation" || nodeType === "TypeAlias" || nodeType === "TypeAnnotation" || nodeType === "TypeCastExpression" || nodeType === "TypeParameter" || nodeType === "TypeParameterDeclaration" || nodeType === "TypeParameterInstantiation" || nodeType === "UnionTypeAnnotation" || nodeType === "Variance" || nodeType === "VoidTypeAnnotation" || nodeType === "IndexedAccessType" || nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AnyTypeAnnotation" || nodeType === "ArrayTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "BooleanLiteralTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "ExistsTypeAnnotation" || nodeType === "FunctionTypeAnnotation" || nodeType === "GenericTypeAnnotation" || nodeType === "InterfaceTypeAnnotation" || nodeType === "IntersectionTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NullableTypeAnnotation" || nodeType === "NumberLiteralTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "ObjectTypeAnnotation" || nodeType === "StringLiteralTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "TupleTypeAnnotation" || nodeType === "TypeofTypeAnnotation" || nodeType === "UnionTypeAnnotation" || nodeType === "VoidTypeAnnotation" || nodeType === "IndexedAccessType" || nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "AnyTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowDeclaration(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isFlowPredicate(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "DeclaredPredicate" || nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumBody(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanBody" || nodeType === "EnumNumberBody" || nodeType === "EnumStringBody" || nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isEnumMember(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "EnumBooleanMember" || nodeType === "EnumNumberMember" || nodeType === "EnumStringMember" || nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isJSX(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "JSXAttribute" || nodeType === "JSXClosingElement" || nodeType === "JSXElement" || nodeType === "JSXEmptyExpression" || nodeType === "JSXExpressionContainer" || nodeType === "JSXSpreadChild" || nodeType === "JSXIdentifier" || nodeType === "JSXMemberExpression" || nodeType === "JSXNamespacedName" || nodeType === "JSXOpeningElement" || nodeType === "JSXSpreadAttribute" || nodeType === "JSXText" || nodeType === "JSXFragment" || nodeType === "JSXOpeningFragment" || nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSTypeElement(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSCallSignatureDeclaration" || nodeType === "TSConstructSignatureDeclaration" || nodeType === "TSPropertySignature" || nodeType === "TSMethodSignature" || nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAnyKeyword" || nodeType === "TSBooleanKeyword" || nodeType === "TSBigIntKeyword" || nodeType === "TSIntrinsicKeyword" || nodeType === "TSNeverKeyword" || nodeType === "TSNullKeyword" || nodeType === "TSNumberKeyword" || nodeType === "TSObjectKeyword" || nodeType === "TSStringKeyword" || nodeType === "TSSymbolKeyword" || nodeType === "TSUndefinedKeyword" || nodeType === "TSUnknownKeyword" || nodeType === "TSVoidKeyword" || nodeType === "TSThisType" || nodeType === "TSFunctionType" || nodeType === "TSConstructorType" || nodeType === "TSTypeReference" || nodeType === "TSTypePredicate" || nodeType === "TSTypeQuery" || nodeType === "TSTypeLiteral" || nodeType === "TSArrayType" || nodeType === "TSTupleType" || nodeType === "TSOptionalType" || nodeType === "TSRestType" || nodeType === "TSUnionType" || nodeType === "TSIntersectionType" || nodeType === "TSConditionalType" || nodeType === "TSInferType" || nodeType === "TSParenthesizedType" || nodeType === "TSTypeOperator" || nodeType === "TSIndexedAccessType" || nodeType === "TSMappedType" || nodeType === "TSLiteralType" || nodeType === "TSExpressionWithTypeArguments" || nodeType === "TSImportType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isTSBaseType(node, opts) {
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "TSAnyKeyword" || nodeType === "TSBooleanKeyword" || nodeType === "TSBigIntKeyword" || nodeType === "TSIntrinsicKeyword" || nodeType === "TSNeverKeyword" || nodeType === "TSNullKeyword" || nodeType === "TSNumberKeyword" || nodeType === "TSObjectKeyword" || nodeType === "TSStringKeyword" || nodeType === "TSSymbolKeyword" || nodeType === "TSUndefinedKeyword" || nodeType === "TSUnknownKeyword" || nodeType === "TSVoidKeyword" || nodeType === "TSThisType" || nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isNumberLiteral(node, opts) {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRegexLiteral(node, opts) {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isRestProperty(node, opts) {
      console.trace("The node type RestProperty has been renamed to RestElement");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
    function isSpreadProperty(node, opts) {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");
      if (!node)
        return false;
      const nodeType = node.type;
      if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return (0, _shallowEqual.default)(node, opts);
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/matchesPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = matchesPattern;
    var _generated = require_generated();
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _generated.isMemberExpression)(member))
        return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node;
      for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length)
        return false;
      if (!allowPartial && nodes.length > parts.length)
        return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node2 = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node2)) {
          value = node2.name;
        } else if ((0, _generated.isStringLiteral)(node2)) {
          value = node2.value;
        } else if ((0, _generated.isThisExpression)(node2)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i] !== value)
          return false;
      }
      return true;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = isReactComponent;
    exports2.default = _default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/to-fast-properties-npm-2.0.0-0dc60cc481-be2de62fe5.zip/node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/to-fast-properties-npm-2.0.0-0dc60cc481-be2de62fe5.zip/node_modules/to-fast-properties/index.js"(exports2, module2) {
    "use strict";
    var fastProto = null;
    function FastObject(o) {
      if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }
      fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
      return new FastObject();
    }
    FastObject();
    module2.exports = function toFastproperties(o) {
      return FastObject(o);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isType;
    var _definitions = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (_definitions.ALIAS_KEYS[targetType])
        return false;
      const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (const alias of aliases) {
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPlaceholderType;
    var _definitions = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _definitions = require_definitions();
    function is(type, node, opts) {
      if (!node)
        return false;
      const matches = (0, _isType.default)(node.type, type);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierStart = isIdentifierStart;
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isKeyword = isKeyword;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-validator-identifier-npm-7.14.9-d7bb91b6de-58552531a7.zip/node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib6();
    function isValidIdentifier(name, reserved = true) {
      if (typeof name !== "string")
        return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/constants/index.js
var require_constants4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/constants/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NOT_LOCAL_BINDING = exports2.BLOCK_SCOPED_SYMBOL = exports2.INHERIT_KEYS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.ASSIGNMENT_OPERATORS = exports2.BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.UPDATE_OPERATORS = exports2.LOGICAL_OPERATORS = exports2.COMMENT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    exports2.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    var FLATTENABLE_KEYS = ["body", "expressions"];
    exports2.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    var FOR_INIT_KEYS = ["left", "init"];
    exports2.FOR_INIT_KEYS = FOR_INIT_KEYS;
    var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    exports2.COMMENT_KEYS = COMMENT_KEYS;
    var LOGICAL_OPERATORS = ["||", "&&", "??"];
    exports2.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    var UPDATE_OPERATORS = ["++", "--"];
    exports2.UPDATE_OPERATORS = UPDATE_OPERATORS;
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    exports2.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    exports2.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    exports2.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    exports2.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
    exports2.BINARY_OPERATORS = BINARY_OPERATORS;
    var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    exports2.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    exports2.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    exports2.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    var STRING_UNARY_OPERATORS = ["typeof"];
    exports2.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    exports2.UNARY_OPERATORS = UNARY_OPERATORS;
    var INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports2.INHERIT_KEYS = INHERIT_KEYS;
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports2.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    exports2.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = validate;
    exports2.validateField = validateField;
    exports2.validateChild = validateChild;
    var _definitions = require_definitions();
    function validate(node, key, val) {
      if (!node)
        return;
      const fields = _definitions.NODE_FIELDS[node.type];
      if (!fields)
        return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      if (val == null)
        return;
      const validate2 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
      if (!validate2)
        return;
      validate2(node, key, val);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/utils.js
var require_utils5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validate = validate;
    exports2.typeIs = typeIs;
    exports2.validateType = validateType;
    exports2.validateOptional = validateOptional;
    exports2.validateOptionalType = validateOptionalType;
    exports2.arrayOf = arrayOf;
    exports2.arrayOfType = arrayOfType;
    exports2.validateArrayOfType = validateArrayOfType;
    exports2.assertEach = assertEach;
    exports2.assertOneOf = assertOneOf;
    exports2.assertNodeType = assertNodeType;
    exports2.assertNodeOrValueType = assertNodeOrValueType;
    exports2.assertValueType = assertValueType;
    exports2.assertShape = assertShape;
    exports2.assertOptionalChainStart = assertOptionalChainStart;
    exports2.chain = chain;
    exports2.default = defineType;
    exports2.NODE_PARENT_VALIDATIONS = exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.NODE_FIELDS = exports2.FLIPPED_ALIAS_KEYS = exports2.ALIAS_KEYS = exports2.VISITOR_KEYS = void 0;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = {};
    exports2.VISITOR_KEYS = VISITOR_KEYS;
    var ALIAS_KEYS = {};
    exports2.ALIAS_KEYS = ALIAS_KEYS;
    var FLIPPED_ALIAS_KEYS = {};
    exports2.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    var NODE_FIELDS = {};
    exports2.NODE_FIELDS = NODE_FIELDS;
    var BUILDER_KEYS = {};
    exports2.BUILDER_KEYS = BUILDER_KEYS;
    var DEPRECATED_KEYS = {};
    exports2.DEPRECATED_KEYS = DEPRECATED_KEYS;
    var NODE_PARENT_VALIDATIONS = {};
    exports2.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    }
    function validateType(typeName) {
      return validate(typeIs(typeName));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val))
          return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING)
            (0, _validate.validateChild)(node, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    function assertNodeType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types;
      return validate2;
    }
    function assertNodeOrValueType(...types) {
      function validate2(node, key, val) {
        for (const type of types) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional)
              return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional)
              return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "validate"];
    function defineType(type, opts = {}) {
      const inherits2 = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits2.fields) {
          const keys = Object.getOwnPropertyNames(inherits2.fields);
          for (const key of keys) {
            const field = inherits2.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits2.visitor || [];
      const aliases = opts.aliases || inherits2.aliases || [];
      const builder = opts.builder || inherits2.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (validFieldKeys.indexOf(k) === -1) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
    var store = {};
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.classMethodOrDeclareMethodCommon = exports2.classMethodOrPropertyCommon = exports2.patternLikeCommon = exports2.functionDeclarationCommon = exports2.functionTypeAnnotationCommon = exports2.functionCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib6();
    var _constants = require_constants4();
    var _utils = require_utils5();
    (0, _utils.default)("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)("string");
            }
            const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "PrivateName"];
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    (0, _utils.default)("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    (0, _utils.default)("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    (0, _utils.default)("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    (0, _utils.default)("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    (0, _utils.default)("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    (0, _utils.default)("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    (0, _utils.default)("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    (0, _utils.default)("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    (0, _utils.default)("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    (0, _utils.default)("DebuggerStatement", {
      aliases: ["Statement"]
    });
    (0, _utils.default)("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    (0, _utils.default)("EmptyStatement", {
      aliases: ["Statement"]
    });
    (0, _utils.default)("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    (0, _utils.default)("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    (0, _utils.default)("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    (0, _utils.default)("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
      },
      generator: {
        default: false
      },
      async: {
        default: false
      }
    };
    exports2.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = {
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
    exports2.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = Object.assign({}, functionCommon, {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports2.functionDeclarationCommon = functionDeclarationCommon;
    (0, _utils.default)("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return () => {
          };
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    (0, _utils.default)("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    var patternLikeCommon = {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
      }
    };
    exports2.patternLikeCommon = patternLikeCommon;
    (0, _utils.default)("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon, {
        name: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          }))
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      }),
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /\.(\w+)$/.exec(key);
        if (!match)
          return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp))
            return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
            return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp))
            return;
          if ((0, _is.default)("Method", parent, nonComp))
            return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent))
            return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          }))
            return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node
          }))
            return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      }
    });
    (0, _utils.default)("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    (0, _utils.default)("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    (0, _utils.default)("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("number")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    (0, _utils.default)("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {})
    });
    (0, _utils.default)("NewExpression", {
      inherits: "CallExpression"
    });
    (0, _utils.default)("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    (0, _utils.default)("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    (0, _utils.default)("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    (0, _utils.default)("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon, {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression")
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      }),
      validate(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match)
          throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match;
        if (parent[listKey].length > index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }
    });
    (0, _utils.default)("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    (0, _utils.default)("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      }
    });
    (0, _utils.default)("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
      }
    });
    (0, _utils.default)("ThisExpression", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          }))
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    (0, _utils.default)("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    (0, _utils.default)("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const")
        },
        declarations: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
      },
      validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ForXStatement", parent, {
          left: node
        }))
          return;
        if (node.declarations.length !== 1) {
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      }
    });
    (0, _utils.default)("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("LVal");
            }
            const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
            const without = (0, _utils.assertNodeType)("Identifier");
            return function(node, key, val) {
              const validator = node.init ? normal : without;
              validator(node, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    (0, _utils.default)("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    (0, _utils.default)("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      })
    });
    (0, _utils.default)("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    (0, _utils.default)("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        }
      })
    });
    (0, _utils.default)("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
        }
      }
    });
    (0, _utils.default)("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    (0, _utils.default)("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    (0, _utils.default)("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
      }
    });
    (0, _utils.default)("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    (0, _utils.default)("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            };
          }()))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    (0, _utils.default)("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        }
      }
    });
    (0, _utils.default)("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
            return function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    (0, _utils.default)("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration"],
      fields: {
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    (0, _utils.default)("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof"),
          optional: true
        }
      }
    });
    (0, _utils.default)("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          }))
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = {
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
      }
    };
    exports2.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports2.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    (0, _utils.default)("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    (0, _utils.default)("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
      })
    });
    (0, _utils.default)("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("Super", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    (0, _utils.default)("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          })
        },
        tail: {
          default: false
        }
      }
    });
    (0, _utils.default)("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    (0, _utils.default)("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("Import", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier"];
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    (0, _utils.default)("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    (0, _utils.default)("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon, {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    (0, _utils.default)("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    (0, _utils.default)("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    (0, _utils.default)("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _utils = require_utils5();
    var defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
      (0, _utils.default)(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
        aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      });
    };
    (0, _utils.default)("AnyTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("BooleanTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("NullLiteralTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("ClassImplements", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    (0, _utils.default)("DeclareFunction", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    (0, _utils.default)("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    (0, _utils.default)("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    (0, _utils.default)("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    (0, _utils.default)("DeclareVariable", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    (0, _utils.default)("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    (0, _utils.default)("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["Flow", "FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    (0, _utils.default)("ExistsTypeAnnotation", {
      aliases: ["Flow", "FlowType"]
    });
    (0, _utils.default)("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      aliases: ["Flow"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow", "FlowType"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    (0, _utils.default)("InferredPredicate", {
      aliases: ["Flow", "FlowPredicate"]
    });
    (0, _utils.default)("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    (0, _utils.default)("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["Flow", "FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    (0, _utils.default)("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    (0, _utils.default)("MixedTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("EmptyTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow", "FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    (0, _utils.default)("NumberTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["Flow", "FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
        callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
        internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    (0, _utils.default)("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      aliases: ["Flow"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    (0, _utils.default)("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    (0, _utils.default)("StringTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("SymbolTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("ThisTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    (0, _utils.default)("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["Flow", "FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("TypeAnnotation", {
      aliases: ["Flow"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["Flow", "ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    (0, _utils.default)("TypeParameter", {
      aliases: ["Flow"],
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    (0, _utils.default)("TypeParameterDeclaration", {
      aliases: ["Flow"],
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    (0, _utils.default)("TypeParameterInstantiation", {
      aliases: ["Flow"],
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    (0, _utils.default)("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    (0, _utils.default)("Variance", {
      aliases: ["Flow"],
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    (0, _utils.default)("VoidTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    (0, _utils.default)("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    (0, _utils.default)("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    (0, _utils.default)("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    (0, _utils.default)("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    (0, _utils.default)("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    (0, _utils.default)("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    (0, _utils.default)("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    (0, _utils.default)("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils5();
    (0, _utils.default)("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    (0, _utils.default)("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    (0, _utils.default)("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["JSX", "Immutable", "Expression"],
      fields: {
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        },
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      }
    });
    (0, _utils.default)("JSXEmptyExpression", {
      aliases: ["JSX"]
    });
    (0, _utils.default)("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    (0, _utils.default)("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("JSXIdentifier", {
      builder: ["name"],
      aliases: ["JSX"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    (0, _utils.default)("JSXMemberExpression", {
      visitor: ["object", "property"],
      aliases: ["JSX"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    (0, _utils.default)("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      aliases: ["JSX"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    (0, _utils.default)("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    (0, _utils.default)("JSXSpreadAttribute", {
      visitor: ["argument"],
      aliases: ["JSX"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("JSXText", {
      aliases: ["JSX", "Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    (0, _utils.default)("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["JSX", "Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    (0, _utils.default)("JSXOpeningFragment", {
      aliases: ["JSX", "Immutable"]
    });
    (0, _utils.default)("JSXClosingFragment", {
      aliases: ["JSX", "Immutable"]
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/placeholders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS = void 0;
    var _utils = require_utils5();
    var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    exports2.PLACEHOLDERS = PLACEHOLDERS;
    var PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    exports2.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length)
        PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    exports2.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils5();
    var _placeholders = require_placeholders();
    {
      (0, _utils.default)("Noop", {
        visitor: []
      });
    }
    (0, _utils.default)("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }
    });
    (0, _utils.default)("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils5();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils5();
    var _core = require_core();
    var _is = require_is();
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = {
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
    (0, _utils.default)("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      }
    });
    (0, _utils.default)("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
    });
    (0, _utils.default)("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
    });
    (0, _utils.default)("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = {
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    };
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon
    };
    (0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    (0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = {
      key: (0, _utils.validateType)("Expression"),
      computed: (0, _utils.validate)(bool),
      optional: (0, _utils.validateOptional)(bool)
    };
    (0, _utils.default)("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation", "initializer"],
      fields: Object.assign({}, namedTypeElementCommon, {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    (0, _utils.default)("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    (0, _utils.default)("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      (0, _utils.default)(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    (0, _utils.default)("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    (0, _utils.default)("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon
    }));
    (0, _utils.default)("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon, {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    (0, _utils.default)("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    (0, _utils.default)("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    (0, _utils.default)("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName"],
      fields: {
        exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
      }
    });
    (0, _utils.default)("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    (0, _utils.default)("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
      }
    });
    (0, _utils.default)("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    (0, _utils.default)("TSUnionType", unionOrIntersection);
    (0, _utils.default)("TSIntersectionType", unionOrIntersection);
    (0, _utils.default)("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    (0, _utils.default)("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation", "nameType"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      }
    });
    (0, _utils.default)("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
            function validator(parent, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent, key, node);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    (0, _utils.default)("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    (0, _utils.default)("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    (0, _utils.default)("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    (0, _utils.default)("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSAsExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    (0, _utils.default)("TSTypeAssertion", {
      aliases: ["Expression"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    (0, _utils.default)("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    (0, _utils.default)("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    (0, _utils.default)("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    (0, _utils.default)("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    (0, _utils.default)("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    (0, _utils.default)("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    (0, _utils.default)("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    (0, _utils.default)("TSNonNullExpression", {
      aliases: ["Expression"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    (0, _utils.default)("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    (0, _utils.default)("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    (0, _utils.default)("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    (0, _utils.default)("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
      }
    });
    (0, _utils.default)("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
      }
    });
    (0, _utils.default)("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/definitions/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    Object.defineProperty(exports2, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports2, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports2, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports2, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports2.TYPES = void 0;
    var _toFastProperties = require_to_fast_properties();
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils5();
    var _placeholders = require_placeholders();
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
    exports2.TYPES = TYPES;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/builder.js
var require_builder = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = builder;
    var _definitions = require_definitions();
    var _validate = require_validate();
    function builder(type, ...args) {
      const keys = _definitions.BUILDER_KEYS[type];
      const countArgs = args.length;
      if (countArgs > keys.length) {
        throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
      }
      const node = {
        type
      };
      let i = 0;
      keys.forEach((key) => {
        const field = _definitions.NODE_FIELDS[type][key];
        let arg;
        if (i < countArgs)
          arg = args[i];
        if (arg === void 0) {
          arg = Array.isArray(field.default) ? [] : field.default;
        }
        node[key] = arg;
        i++;
      });
      for (const key of Object.keys(node)) {
        (0, _validate.default)(node, key, node[key]);
      }
      return node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrayExpression = arrayExpression;
    exports2.assignmentExpression = assignmentExpression;
    exports2.binaryExpression = binaryExpression;
    exports2.interpreterDirective = interpreterDirective;
    exports2.directive = directive;
    exports2.directiveLiteral = directiveLiteral;
    exports2.blockStatement = blockStatement;
    exports2.breakStatement = breakStatement;
    exports2.callExpression = callExpression;
    exports2.catchClause = catchClause;
    exports2.conditionalExpression = conditionalExpression;
    exports2.continueStatement = continueStatement;
    exports2.debuggerStatement = debuggerStatement;
    exports2.doWhileStatement = doWhileStatement;
    exports2.emptyStatement = emptyStatement;
    exports2.expressionStatement = expressionStatement;
    exports2.file = file;
    exports2.forInStatement = forInStatement;
    exports2.forStatement = forStatement;
    exports2.functionDeclaration = functionDeclaration;
    exports2.functionExpression = functionExpression;
    exports2.identifier = identifier;
    exports2.ifStatement = ifStatement;
    exports2.labeledStatement = labeledStatement;
    exports2.stringLiteral = stringLiteral;
    exports2.numericLiteral = numericLiteral;
    exports2.nullLiteral = nullLiteral;
    exports2.booleanLiteral = booleanLiteral;
    exports2.regExpLiteral = regExpLiteral;
    exports2.logicalExpression = logicalExpression;
    exports2.memberExpression = memberExpression;
    exports2.newExpression = newExpression;
    exports2.program = program2;
    exports2.objectExpression = objectExpression;
    exports2.objectMethod = objectMethod;
    exports2.objectProperty = objectProperty;
    exports2.restElement = restElement;
    exports2.returnStatement = returnStatement;
    exports2.sequenceExpression = sequenceExpression;
    exports2.parenthesizedExpression = parenthesizedExpression;
    exports2.switchCase = switchCase;
    exports2.switchStatement = switchStatement;
    exports2.thisExpression = thisExpression;
    exports2.throwStatement = throwStatement;
    exports2.tryStatement = tryStatement;
    exports2.unaryExpression = unaryExpression;
    exports2.updateExpression = updateExpression;
    exports2.variableDeclaration = variableDeclaration;
    exports2.variableDeclarator = variableDeclarator;
    exports2.whileStatement = whileStatement;
    exports2.withStatement = withStatement;
    exports2.assignmentPattern = assignmentPattern;
    exports2.arrayPattern = arrayPattern;
    exports2.arrowFunctionExpression = arrowFunctionExpression;
    exports2.classBody = classBody;
    exports2.classExpression = classExpression;
    exports2.classDeclaration = classDeclaration;
    exports2.exportAllDeclaration = exportAllDeclaration;
    exports2.exportDefaultDeclaration = exportDefaultDeclaration;
    exports2.exportNamedDeclaration = exportNamedDeclaration;
    exports2.exportSpecifier = exportSpecifier;
    exports2.forOfStatement = forOfStatement;
    exports2.importDeclaration = importDeclaration;
    exports2.importDefaultSpecifier = importDefaultSpecifier;
    exports2.importNamespaceSpecifier = importNamespaceSpecifier;
    exports2.importSpecifier = importSpecifier;
    exports2.metaProperty = metaProperty;
    exports2.classMethod = classMethod;
    exports2.objectPattern = objectPattern;
    exports2.spreadElement = spreadElement;
    exports2.super = _super;
    exports2.taggedTemplateExpression = taggedTemplateExpression;
    exports2.templateElement = templateElement;
    exports2.templateLiteral = templateLiteral;
    exports2.yieldExpression = yieldExpression;
    exports2.awaitExpression = awaitExpression;
    exports2.import = _import;
    exports2.bigIntLiteral = bigIntLiteral;
    exports2.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports2.optionalMemberExpression = optionalMemberExpression;
    exports2.optionalCallExpression = optionalCallExpression;
    exports2.classProperty = classProperty;
    exports2.classPrivateProperty = classPrivateProperty;
    exports2.classPrivateMethod = classPrivateMethod;
    exports2.privateName = privateName;
    exports2.anyTypeAnnotation = anyTypeAnnotation;
    exports2.arrayTypeAnnotation = arrayTypeAnnotation;
    exports2.booleanTypeAnnotation = booleanTypeAnnotation;
    exports2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports2.classImplements = classImplements;
    exports2.declareClass = declareClass;
    exports2.declareFunction = declareFunction;
    exports2.declareInterface = declareInterface;
    exports2.declareModule = declareModule;
    exports2.declareModuleExports = declareModuleExports;
    exports2.declareTypeAlias = declareTypeAlias;
    exports2.declareOpaqueType = declareOpaqueType;
    exports2.declareVariable = declareVariable;
    exports2.declareExportDeclaration = declareExportDeclaration;
    exports2.declareExportAllDeclaration = declareExportAllDeclaration;
    exports2.declaredPredicate = declaredPredicate;
    exports2.existsTypeAnnotation = existsTypeAnnotation;
    exports2.functionTypeAnnotation = functionTypeAnnotation;
    exports2.functionTypeParam = functionTypeParam;
    exports2.genericTypeAnnotation = genericTypeAnnotation;
    exports2.inferredPredicate = inferredPredicate;
    exports2.interfaceExtends = interfaceExtends;
    exports2.interfaceDeclaration = interfaceDeclaration;
    exports2.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports2.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports2.mixedTypeAnnotation = mixedTypeAnnotation;
    exports2.emptyTypeAnnotation = emptyTypeAnnotation;
    exports2.nullableTypeAnnotation = nullableTypeAnnotation;
    exports2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports2.numberTypeAnnotation = numberTypeAnnotation;
    exports2.objectTypeAnnotation = objectTypeAnnotation;
    exports2.objectTypeInternalSlot = objectTypeInternalSlot;
    exports2.objectTypeCallProperty = objectTypeCallProperty;
    exports2.objectTypeIndexer = objectTypeIndexer;
    exports2.objectTypeProperty = objectTypeProperty;
    exports2.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports2.opaqueType = opaqueType;
    exports2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports2.stringTypeAnnotation = stringTypeAnnotation;
    exports2.symbolTypeAnnotation = symbolTypeAnnotation;
    exports2.thisTypeAnnotation = thisTypeAnnotation;
    exports2.tupleTypeAnnotation = tupleTypeAnnotation;
    exports2.typeofTypeAnnotation = typeofTypeAnnotation;
    exports2.typeAlias = typeAlias;
    exports2.typeAnnotation = typeAnnotation;
    exports2.typeCastExpression = typeCastExpression;
    exports2.typeParameter = typeParameter;
    exports2.typeParameterDeclaration = typeParameterDeclaration;
    exports2.typeParameterInstantiation = typeParameterInstantiation;
    exports2.unionTypeAnnotation = unionTypeAnnotation;
    exports2.variance = variance;
    exports2.voidTypeAnnotation = voidTypeAnnotation;
    exports2.enumDeclaration = enumDeclaration;
    exports2.enumBooleanBody = enumBooleanBody;
    exports2.enumNumberBody = enumNumberBody;
    exports2.enumStringBody = enumStringBody;
    exports2.enumSymbolBody = enumSymbolBody;
    exports2.enumBooleanMember = enumBooleanMember;
    exports2.enumNumberMember = enumNumberMember;
    exports2.enumStringMember = enumStringMember;
    exports2.enumDefaultedMember = enumDefaultedMember;
    exports2.indexedAccessType = indexedAccessType;
    exports2.optionalIndexedAccessType = optionalIndexedAccessType;
    exports2.jSXAttribute = exports2.jsxAttribute = jsxAttribute;
    exports2.jSXClosingElement = exports2.jsxClosingElement = jsxClosingElement;
    exports2.jSXElement = exports2.jsxElement = jsxElement;
    exports2.jSXEmptyExpression = exports2.jsxEmptyExpression = jsxEmptyExpression;
    exports2.jSXExpressionContainer = exports2.jsxExpressionContainer = jsxExpressionContainer;
    exports2.jSXSpreadChild = exports2.jsxSpreadChild = jsxSpreadChild;
    exports2.jSXIdentifier = exports2.jsxIdentifier = jsxIdentifier;
    exports2.jSXMemberExpression = exports2.jsxMemberExpression = jsxMemberExpression;
    exports2.jSXNamespacedName = exports2.jsxNamespacedName = jsxNamespacedName;
    exports2.jSXOpeningElement = exports2.jsxOpeningElement = jsxOpeningElement;
    exports2.jSXSpreadAttribute = exports2.jsxSpreadAttribute = jsxSpreadAttribute;
    exports2.jSXText = exports2.jsxText = jsxText;
    exports2.jSXFragment = exports2.jsxFragment = jsxFragment;
    exports2.jSXOpeningFragment = exports2.jsxOpeningFragment = jsxOpeningFragment;
    exports2.jSXClosingFragment = exports2.jsxClosingFragment = jsxClosingFragment;
    exports2.noop = noop;
    exports2.placeholder = placeholder;
    exports2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports2.argumentPlaceholder = argumentPlaceholder;
    exports2.bindExpression = bindExpression;
    exports2.importAttribute = importAttribute;
    exports2.decorator = decorator;
    exports2.doExpression = doExpression;
    exports2.exportDefaultSpecifier = exportDefaultSpecifier;
    exports2.recordExpression = recordExpression;
    exports2.tupleExpression = tupleExpression;
    exports2.decimalLiteral = decimalLiteral;
    exports2.staticBlock = staticBlock;
    exports2.moduleExpression = moduleExpression;
    exports2.topicReference = topicReference;
    exports2.pipelineTopicExpression = pipelineTopicExpression;
    exports2.pipelineBareFunction = pipelineBareFunction;
    exports2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports2.tSParameterProperty = exports2.tsParameterProperty = tsParameterProperty;
    exports2.tSDeclareFunction = exports2.tsDeclareFunction = tsDeclareFunction;
    exports2.tSDeclareMethod = exports2.tsDeclareMethod = tsDeclareMethod;
    exports2.tSQualifiedName = exports2.tsQualifiedName = tsQualifiedName;
    exports2.tSCallSignatureDeclaration = exports2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports2.tSConstructSignatureDeclaration = exports2.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports2.tSPropertySignature = exports2.tsPropertySignature = tsPropertySignature;
    exports2.tSMethodSignature = exports2.tsMethodSignature = tsMethodSignature;
    exports2.tSIndexSignature = exports2.tsIndexSignature = tsIndexSignature;
    exports2.tSAnyKeyword = exports2.tsAnyKeyword = tsAnyKeyword;
    exports2.tSBooleanKeyword = exports2.tsBooleanKeyword = tsBooleanKeyword;
    exports2.tSBigIntKeyword = exports2.tsBigIntKeyword = tsBigIntKeyword;
    exports2.tSIntrinsicKeyword = exports2.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports2.tSNeverKeyword = exports2.tsNeverKeyword = tsNeverKeyword;
    exports2.tSNullKeyword = exports2.tsNullKeyword = tsNullKeyword;
    exports2.tSNumberKeyword = exports2.tsNumberKeyword = tsNumberKeyword;
    exports2.tSObjectKeyword = exports2.tsObjectKeyword = tsObjectKeyword;
    exports2.tSStringKeyword = exports2.tsStringKeyword = tsStringKeyword;
    exports2.tSSymbolKeyword = exports2.tsSymbolKeyword = tsSymbolKeyword;
    exports2.tSUndefinedKeyword = exports2.tsUndefinedKeyword = tsUndefinedKeyword;
    exports2.tSUnknownKeyword = exports2.tsUnknownKeyword = tsUnknownKeyword;
    exports2.tSVoidKeyword = exports2.tsVoidKeyword = tsVoidKeyword;
    exports2.tSThisType = exports2.tsThisType = tsThisType;
    exports2.tSFunctionType = exports2.tsFunctionType = tsFunctionType;
    exports2.tSConstructorType = exports2.tsConstructorType = tsConstructorType;
    exports2.tSTypeReference = exports2.tsTypeReference = tsTypeReference;
    exports2.tSTypePredicate = exports2.tsTypePredicate = tsTypePredicate;
    exports2.tSTypeQuery = exports2.tsTypeQuery = tsTypeQuery;
    exports2.tSTypeLiteral = exports2.tsTypeLiteral = tsTypeLiteral;
    exports2.tSArrayType = exports2.tsArrayType = tsArrayType;
    exports2.tSTupleType = exports2.tsTupleType = tsTupleType;
    exports2.tSOptionalType = exports2.tsOptionalType = tsOptionalType;
    exports2.tSRestType = exports2.tsRestType = tsRestType;
    exports2.tSNamedTupleMember = exports2.tsNamedTupleMember = tsNamedTupleMember;
    exports2.tSUnionType = exports2.tsUnionType = tsUnionType;
    exports2.tSIntersectionType = exports2.tsIntersectionType = tsIntersectionType;
    exports2.tSConditionalType = exports2.tsConditionalType = tsConditionalType;
    exports2.tSInferType = exports2.tsInferType = tsInferType;
    exports2.tSParenthesizedType = exports2.tsParenthesizedType = tsParenthesizedType;
    exports2.tSTypeOperator = exports2.tsTypeOperator = tsTypeOperator;
    exports2.tSIndexedAccessType = exports2.tsIndexedAccessType = tsIndexedAccessType;
    exports2.tSMappedType = exports2.tsMappedType = tsMappedType;
    exports2.tSLiteralType = exports2.tsLiteralType = tsLiteralType;
    exports2.tSExpressionWithTypeArguments = exports2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports2.tSInterfaceDeclaration = exports2.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports2.tSInterfaceBody = exports2.tsInterfaceBody = tsInterfaceBody;
    exports2.tSTypeAliasDeclaration = exports2.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports2.tSAsExpression = exports2.tsAsExpression = tsAsExpression;
    exports2.tSTypeAssertion = exports2.tsTypeAssertion = tsTypeAssertion;
    exports2.tSEnumDeclaration = exports2.tsEnumDeclaration = tsEnumDeclaration;
    exports2.tSEnumMember = exports2.tsEnumMember = tsEnumMember;
    exports2.tSModuleDeclaration = exports2.tsModuleDeclaration = tsModuleDeclaration;
    exports2.tSModuleBlock = exports2.tsModuleBlock = tsModuleBlock;
    exports2.tSImportType = exports2.tsImportType = tsImportType;
    exports2.tSImportEqualsDeclaration = exports2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports2.tSExternalModuleReference = exports2.tsExternalModuleReference = tsExternalModuleReference;
    exports2.tSNonNullExpression = exports2.tsNonNullExpression = tsNonNullExpression;
    exports2.tSExportAssignment = exports2.tsExportAssignment = tsExportAssignment;
    exports2.tSNamespaceExportDeclaration = exports2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports2.tSTypeAnnotation = exports2.tsTypeAnnotation = tsTypeAnnotation;
    exports2.tSTypeParameterInstantiation = exports2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports2.tSTypeParameterDeclaration = exports2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports2.tSTypeParameter = exports2.tsTypeParameter = tsTypeParameter;
    exports2.numberLiteral = NumberLiteral;
    exports2.regexLiteral = RegexLiteral;
    exports2.restProperty = RestProperty;
    exports2.spreadProperty = SpreadProperty;
    var _builder = require_builder();
    function arrayExpression(elements) {
      return (0, _builder.default)("ArrayExpression", ...arguments);
    }
    function assignmentExpression(operator, left, right) {
      return (0, _builder.default)("AssignmentExpression", ...arguments);
    }
    function binaryExpression(operator, left, right) {
      return (0, _builder.default)("BinaryExpression", ...arguments);
    }
    function interpreterDirective(value) {
      return (0, _builder.default)("InterpreterDirective", ...arguments);
    }
    function directive(value) {
      return (0, _builder.default)("Directive", ...arguments);
    }
    function directiveLiteral(value) {
      return (0, _builder.default)("DirectiveLiteral", ...arguments);
    }
    function blockStatement(body, directives) {
      return (0, _builder.default)("BlockStatement", ...arguments);
    }
    function breakStatement(label) {
      return (0, _builder.default)("BreakStatement", ...arguments);
    }
    function callExpression(callee, _arguments) {
      return (0, _builder.default)("CallExpression", ...arguments);
    }
    function catchClause(param, body) {
      return (0, _builder.default)("CatchClause", ...arguments);
    }
    function conditionalExpression(test, consequent, alternate) {
      return (0, _builder.default)("ConditionalExpression", ...arguments);
    }
    function continueStatement(label) {
      return (0, _builder.default)("ContinueStatement", ...arguments);
    }
    function debuggerStatement() {
      return (0, _builder.default)("DebuggerStatement", ...arguments);
    }
    function doWhileStatement(test, body) {
      return (0, _builder.default)("DoWhileStatement", ...arguments);
    }
    function emptyStatement() {
      return (0, _builder.default)("EmptyStatement", ...arguments);
    }
    function expressionStatement(expression) {
      return (0, _builder.default)("ExpressionStatement", ...arguments);
    }
    function file(program3, comments, tokens) {
      return (0, _builder.default)("File", ...arguments);
    }
    function forInStatement(left, right, body) {
      return (0, _builder.default)("ForInStatement", ...arguments);
    }
    function forStatement(init, test, update, body) {
      return (0, _builder.default)("ForStatement", ...arguments);
    }
    function functionDeclaration(id, params, body, generator, async) {
      return (0, _builder.default)("FunctionDeclaration", ...arguments);
    }
    function functionExpression(id, params, body, generator, async) {
      return (0, _builder.default)("FunctionExpression", ...arguments);
    }
    function identifier(name) {
      return (0, _builder.default)("Identifier", ...arguments);
    }
    function ifStatement(test, consequent, alternate) {
      return (0, _builder.default)("IfStatement", ...arguments);
    }
    function labeledStatement(label, body) {
      return (0, _builder.default)("LabeledStatement", ...arguments);
    }
    function stringLiteral(value) {
      return (0, _builder.default)("StringLiteral", ...arguments);
    }
    function numericLiteral(value) {
      return (0, _builder.default)("NumericLiteral", ...arguments);
    }
    function nullLiteral() {
      return (0, _builder.default)("NullLiteral", ...arguments);
    }
    function booleanLiteral(value) {
      return (0, _builder.default)("BooleanLiteral", ...arguments);
    }
    function regExpLiteral(pattern, flags) {
      return (0, _builder.default)("RegExpLiteral", ...arguments);
    }
    function logicalExpression(operator, left, right) {
      return (0, _builder.default)("LogicalExpression", ...arguments);
    }
    function memberExpression(object, property, computed, optional) {
      return (0, _builder.default)("MemberExpression", ...arguments);
    }
    function newExpression(callee, _arguments) {
      return (0, _builder.default)("NewExpression", ...arguments);
    }
    function program2(body, directives, sourceType, interpreter) {
      return (0, _builder.default)("Program", ...arguments);
    }
    function objectExpression(properties) {
      return (0, _builder.default)("ObjectExpression", ...arguments);
    }
    function objectMethod(kind, key, params, body, computed, generator, async) {
      return (0, _builder.default)("ObjectMethod", ...arguments);
    }
    function objectProperty(key, value, computed, shorthand, decorators) {
      return (0, _builder.default)("ObjectProperty", ...arguments);
    }
    function restElement(argument) {
      return (0, _builder.default)("RestElement", ...arguments);
    }
    function returnStatement(argument) {
      return (0, _builder.default)("ReturnStatement", ...arguments);
    }
    function sequenceExpression(expressions) {
      return (0, _builder.default)("SequenceExpression", ...arguments);
    }
    function parenthesizedExpression(expression) {
      return (0, _builder.default)("ParenthesizedExpression", ...arguments);
    }
    function switchCase(test, consequent) {
      return (0, _builder.default)("SwitchCase", ...arguments);
    }
    function switchStatement(discriminant, cases) {
      return (0, _builder.default)("SwitchStatement", ...arguments);
    }
    function thisExpression() {
      return (0, _builder.default)("ThisExpression", ...arguments);
    }
    function throwStatement(argument) {
      return (0, _builder.default)("ThrowStatement", ...arguments);
    }
    function tryStatement(block, handler, finalizer) {
      return (0, _builder.default)("TryStatement", ...arguments);
    }
    function unaryExpression(operator, argument, prefix) {
      return (0, _builder.default)("UnaryExpression", ...arguments);
    }
    function updateExpression(operator, argument, prefix) {
      return (0, _builder.default)("UpdateExpression", ...arguments);
    }
    function variableDeclaration(kind, declarations) {
      return (0, _builder.default)("VariableDeclaration", ...arguments);
    }
    function variableDeclarator(id, init) {
      return (0, _builder.default)("VariableDeclarator", ...arguments);
    }
    function whileStatement(test, body) {
      return (0, _builder.default)("WhileStatement", ...arguments);
    }
    function withStatement(object, body) {
      return (0, _builder.default)("WithStatement", ...arguments);
    }
    function assignmentPattern(left, right) {
      return (0, _builder.default)("AssignmentPattern", ...arguments);
    }
    function arrayPattern(elements) {
      return (0, _builder.default)("ArrayPattern", ...arguments);
    }
    function arrowFunctionExpression(params, body, async) {
      return (0, _builder.default)("ArrowFunctionExpression", ...arguments);
    }
    function classBody(body) {
      return (0, _builder.default)("ClassBody", ...arguments);
    }
    function classExpression(id, superClass, body, decorators) {
      return (0, _builder.default)("ClassExpression", ...arguments);
    }
    function classDeclaration(id, superClass, body, decorators) {
      return (0, _builder.default)("ClassDeclaration", ...arguments);
    }
    function exportAllDeclaration(source) {
      return (0, _builder.default)("ExportAllDeclaration", ...arguments);
    }
    function exportDefaultDeclaration(declaration) {
      return (0, _builder.default)("ExportDefaultDeclaration", ...arguments);
    }
    function exportNamedDeclaration(declaration, specifiers, source) {
      return (0, _builder.default)("ExportNamedDeclaration", ...arguments);
    }
    function exportSpecifier(local, exported) {
      return (0, _builder.default)("ExportSpecifier", ...arguments);
    }
    function forOfStatement(left, right, body, _await) {
      return (0, _builder.default)("ForOfStatement", ...arguments);
    }
    function importDeclaration(specifiers, source) {
      return (0, _builder.default)("ImportDeclaration", ...arguments);
    }
    function importDefaultSpecifier(local) {
      return (0, _builder.default)("ImportDefaultSpecifier", ...arguments);
    }
    function importNamespaceSpecifier(local) {
      return (0, _builder.default)("ImportNamespaceSpecifier", ...arguments);
    }
    function importSpecifier(local, imported) {
      return (0, _builder.default)("ImportSpecifier", ...arguments);
    }
    function metaProperty(meta, property) {
      return (0, _builder.default)("MetaProperty", ...arguments);
    }
    function classMethod(kind, key, params, body, computed, _static, generator, async) {
      return (0, _builder.default)("ClassMethod", ...arguments);
    }
    function objectPattern(properties) {
      return (0, _builder.default)("ObjectPattern", ...arguments);
    }
    function spreadElement(argument) {
      return (0, _builder.default)("SpreadElement", ...arguments);
    }
    function _super() {
      return (0, _builder.default)("Super", ...arguments);
    }
    function taggedTemplateExpression(tag, quasi) {
      return (0, _builder.default)("TaggedTemplateExpression", ...arguments);
    }
    function templateElement(value, tail) {
      return (0, _builder.default)("TemplateElement", ...arguments);
    }
    function templateLiteral(quasis, expressions) {
      return (0, _builder.default)("TemplateLiteral", ...arguments);
    }
    function yieldExpression(argument, delegate) {
      return (0, _builder.default)("YieldExpression", ...arguments);
    }
    function awaitExpression(argument) {
      return (0, _builder.default)("AwaitExpression", ...arguments);
    }
    function _import() {
      return (0, _builder.default)("Import", ...arguments);
    }
    function bigIntLiteral(value) {
      return (0, _builder.default)("BigIntLiteral", ...arguments);
    }
    function exportNamespaceSpecifier(exported) {
      return (0, _builder.default)("ExportNamespaceSpecifier", ...arguments);
    }
    function optionalMemberExpression(object, property, computed, optional) {
      return (0, _builder.default)("OptionalMemberExpression", ...arguments);
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _builder.default)("OptionalCallExpression", ...arguments);
    }
    function classProperty(key, value, typeAnnotation2, decorators, computed, _static) {
      return (0, _builder.default)("ClassProperty", ...arguments);
    }
    function classPrivateProperty(key, value, decorators, _static) {
      return (0, _builder.default)("ClassPrivateProperty", ...arguments);
    }
    function classPrivateMethod(kind, key, params, body, _static) {
      return (0, _builder.default)("ClassPrivateMethod", ...arguments);
    }
    function privateName(id) {
      return (0, _builder.default)("PrivateName", ...arguments);
    }
    function anyTypeAnnotation() {
      return (0, _builder.default)("AnyTypeAnnotation", ...arguments);
    }
    function arrayTypeAnnotation(elementType) {
      return (0, _builder.default)("ArrayTypeAnnotation", ...arguments);
    }
    function booleanTypeAnnotation() {
      return (0, _builder.default)("BooleanTypeAnnotation", ...arguments);
    }
    function booleanLiteralTypeAnnotation(value) {
      return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...arguments);
    }
    function nullLiteralTypeAnnotation() {
      return (0, _builder.default)("NullLiteralTypeAnnotation", ...arguments);
    }
    function classImplements(id, typeParameters) {
      return (0, _builder.default)("ClassImplements", ...arguments);
    }
    function declareClass(id, typeParameters, _extends, body) {
      return (0, _builder.default)("DeclareClass", ...arguments);
    }
    function declareFunction(id) {
      return (0, _builder.default)("DeclareFunction", ...arguments);
    }
    function declareInterface(id, typeParameters, _extends, body) {
      return (0, _builder.default)("DeclareInterface", ...arguments);
    }
    function declareModule(id, body, kind) {
      return (0, _builder.default)("DeclareModule", ...arguments);
    }
    function declareModuleExports(typeAnnotation2) {
      return (0, _builder.default)("DeclareModuleExports", ...arguments);
    }
    function declareTypeAlias(id, typeParameters, right) {
      return (0, _builder.default)("DeclareTypeAlias", ...arguments);
    }
    function declareOpaqueType(id, typeParameters, supertype) {
      return (0, _builder.default)("DeclareOpaqueType", ...arguments);
    }
    function declareVariable(id) {
      return (0, _builder.default)("DeclareVariable", ...arguments);
    }
    function declareExportDeclaration(declaration, specifiers, source) {
      return (0, _builder.default)("DeclareExportDeclaration", ...arguments);
    }
    function declareExportAllDeclaration(source) {
      return (0, _builder.default)("DeclareExportAllDeclaration", ...arguments);
    }
    function declaredPredicate(value) {
      return (0, _builder.default)("DeclaredPredicate", ...arguments);
    }
    function existsTypeAnnotation() {
      return (0, _builder.default)("ExistsTypeAnnotation", ...arguments);
    }
    function functionTypeAnnotation(typeParameters, params, rest, returnType) {
      return (0, _builder.default)("FunctionTypeAnnotation", ...arguments);
    }
    function functionTypeParam(name, typeAnnotation2) {
      return (0, _builder.default)("FunctionTypeParam", ...arguments);
    }
    function genericTypeAnnotation(id, typeParameters) {
      return (0, _builder.default)("GenericTypeAnnotation", ...arguments);
    }
    function inferredPredicate() {
      return (0, _builder.default)("InferredPredicate", ...arguments);
    }
    function interfaceExtends(id, typeParameters) {
      return (0, _builder.default)("InterfaceExtends", ...arguments);
    }
    function interfaceDeclaration(id, typeParameters, _extends, body) {
      return (0, _builder.default)("InterfaceDeclaration", ...arguments);
    }
    function interfaceTypeAnnotation(_extends, body) {
      return (0, _builder.default)("InterfaceTypeAnnotation", ...arguments);
    }
    function intersectionTypeAnnotation(types) {
      return (0, _builder.default)("IntersectionTypeAnnotation", ...arguments);
    }
    function mixedTypeAnnotation() {
      return (0, _builder.default)("MixedTypeAnnotation", ...arguments);
    }
    function emptyTypeAnnotation() {
      return (0, _builder.default)("EmptyTypeAnnotation", ...arguments);
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return (0, _builder.default)("NullableTypeAnnotation", ...arguments);
    }
    function numberLiteralTypeAnnotation(value) {
      return (0, _builder.default)("NumberLiteralTypeAnnotation", ...arguments);
    }
    function numberTypeAnnotation() {
      return (0, _builder.default)("NumberTypeAnnotation", ...arguments);
    }
    function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
      return (0, _builder.default)("ObjectTypeAnnotation", ...arguments);
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      return (0, _builder.default)("ObjectTypeInternalSlot", ...arguments);
    }
    function objectTypeCallProperty(value) {
      return (0, _builder.default)("ObjectTypeCallProperty", ...arguments);
    }
    function objectTypeIndexer(id, key, value, variance2) {
      return (0, _builder.default)("ObjectTypeIndexer", ...arguments);
    }
    function objectTypeProperty(key, value, variance2) {
      return (0, _builder.default)("ObjectTypeProperty", ...arguments);
    }
    function objectTypeSpreadProperty(argument) {
      return (0, _builder.default)("ObjectTypeSpreadProperty", ...arguments);
    }
    function opaqueType(id, typeParameters, supertype, impltype) {
      return (0, _builder.default)("OpaqueType", ...arguments);
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _builder.default)("QualifiedTypeIdentifier", ...arguments);
    }
    function stringLiteralTypeAnnotation(value) {
      return (0, _builder.default)("StringLiteralTypeAnnotation", ...arguments);
    }
    function stringTypeAnnotation() {
      return (0, _builder.default)("StringTypeAnnotation", ...arguments);
    }
    function symbolTypeAnnotation() {
      return (0, _builder.default)("SymbolTypeAnnotation", ...arguments);
    }
    function thisTypeAnnotation() {
      return (0, _builder.default)("ThisTypeAnnotation", ...arguments);
    }
    function tupleTypeAnnotation(types) {
      return (0, _builder.default)("TupleTypeAnnotation", ...arguments);
    }
    function typeofTypeAnnotation(argument) {
      return (0, _builder.default)("TypeofTypeAnnotation", ...arguments);
    }
    function typeAlias(id, typeParameters, right) {
      return (0, _builder.default)("TypeAlias", ...arguments);
    }
    function typeAnnotation(typeAnnotation2) {
      return (0, _builder.default)("TypeAnnotation", ...arguments);
    }
    function typeCastExpression(expression, typeAnnotation2) {
      return (0, _builder.default)("TypeCastExpression", ...arguments);
    }
    function typeParameter(bound, _default, variance2) {
      return (0, _builder.default)("TypeParameter", ...arguments);
    }
    function typeParameterDeclaration(params) {
      return (0, _builder.default)("TypeParameterDeclaration", ...arguments);
    }
    function typeParameterInstantiation(params) {
      return (0, _builder.default)("TypeParameterInstantiation", ...arguments);
    }
    function unionTypeAnnotation(types) {
      return (0, _builder.default)("UnionTypeAnnotation", ...arguments);
    }
    function variance(kind) {
      return (0, _builder.default)("Variance", ...arguments);
    }
    function voidTypeAnnotation() {
      return (0, _builder.default)("VoidTypeAnnotation", ...arguments);
    }
    function enumDeclaration(id, body) {
      return (0, _builder.default)("EnumDeclaration", ...arguments);
    }
    function enumBooleanBody(members) {
      return (0, _builder.default)("EnumBooleanBody", ...arguments);
    }
    function enumNumberBody(members) {
      return (0, _builder.default)("EnumNumberBody", ...arguments);
    }
    function enumStringBody(members) {
      return (0, _builder.default)("EnumStringBody", ...arguments);
    }
    function enumSymbolBody(members) {
      return (0, _builder.default)("EnumSymbolBody", ...arguments);
    }
    function enumBooleanMember(id) {
      return (0, _builder.default)("EnumBooleanMember", ...arguments);
    }
    function enumNumberMember(id, init) {
      return (0, _builder.default)("EnumNumberMember", ...arguments);
    }
    function enumStringMember(id, init) {
      return (0, _builder.default)("EnumStringMember", ...arguments);
    }
    function enumDefaultedMember(id) {
      return (0, _builder.default)("EnumDefaultedMember", ...arguments);
    }
    function indexedAccessType(objectType, indexType) {
      return (0, _builder.default)("IndexedAccessType", ...arguments);
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return (0, _builder.default)("OptionalIndexedAccessType", ...arguments);
    }
    function jsxAttribute(name, value) {
      return (0, _builder.default)("JSXAttribute", ...arguments);
    }
    function jsxClosingElement(name) {
      return (0, _builder.default)("JSXClosingElement", ...arguments);
    }
    function jsxElement(openingElement, closingElement, children, selfClosing) {
      return (0, _builder.default)("JSXElement", ...arguments);
    }
    function jsxEmptyExpression() {
      return (0, _builder.default)("JSXEmptyExpression", ...arguments);
    }
    function jsxExpressionContainer(expression) {
      return (0, _builder.default)("JSXExpressionContainer", ...arguments);
    }
    function jsxSpreadChild(expression) {
      return (0, _builder.default)("JSXSpreadChild", ...arguments);
    }
    function jsxIdentifier(name) {
      return (0, _builder.default)("JSXIdentifier", ...arguments);
    }
    function jsxMemberExpression(object, property) {
      return (0, _builder.default)("JSXMemberExpression", ...arguments);
    }
    function jsxNamespacedName(namespace, name) {
      return (0, _builder.default)("JSXNamespacedName", ...arguments);
    }
    function jsxOpeningElement(name, attributes, selfClosing) {
      return (0, _builder.default)("JSXOpeningElement", ...arguments);
    }
    function jsxSpreadAttribute(argument) {
      return (0, _builder.default)("JSXSpreadAttribute", ...arguments);
    }
    function jsxText(value) {
      return (0, _builder.default)("JSXText", ...arguments);
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      return (0, _builder.default)("JSXFragment", ...arguments);
    }
    function jsxOpeningFragment() {
      return (0, _builder.default)("JSXOpeningFragment", ...arguments);
    }
    function jsxClosingFragment() {
      return (0, _builder.default)("JSXClosingFragment", ...arguments);
    }
    function noop() {
      return (0, _builder.default)("Noop", ...arguments);
    }
    function placeholder(expectedNode, name) {
      return (0, _builder.default)("Placeholder", ...arguments);
    }
    function v8IntrinsicIdentifier(name) {
      return (0, _builder.default)("V8IntrinsicIdentifier", ...arguments);
    }
    function argumentPlaceholder() {
      return (0, _builder.default)("ArgumentPlaceholder", ...arguments);
    }
    function bindExpression(object, callee) {
      return (0, _builder.default)("BindExpression", ...arguments);
    }
    function importAttribute(key, value) {
      return (0, _builder.default)("ImportAttribute", ...arguments);
    }
    function decorator(expression) {
      return (0, _builder.default)("Decorator", ...arguments);
    }
    function doExpression(body, async) {
      return (0, _builder.default)("DoExpression", ...arguments);
    }
    function exportDefaultSpecifier(exported) {
      return (0, _builder.default)("ExportDefaultSpecifier", ...arguments);
    }
    function recordExpression(properties) {
      return (0, _builder.default)("RecordExpression", ...arguments);
    }
    function tupleExpression(elements) {
      return (0, _builder.default)("TupleExpression", ...arguments);
    }
    function decimalLiteral(value) {
      return (0, _builder.default)("DecimalLiteral", ...arguments);
    }
    function staticBlock(body) {
      return (0, _builder.default)("StaticBlock", ...arguments);
    }
    function moduleExpression(body) {
      return (0, _builder.default)("ModuleExpression", ...arguments);
    }
    function topicReference() {
      return (0, _builder.default)("TopicReference", ...arguments);
    }
    function pipelineTopicExpression(expression) {
      return (0, _builder.default)("PipelineTopicExpression", ...arguments);
    }
    function pipelineBareFunction(callee) {
      return (0, _builder.default)("PipelineBareFunction", ...arguments);
    }
    function pipelinePrimaryTopicReference() {
      return (0, _builder.default)("PipelinePrimaryTopicReference", ...arguments);
    }
    function tsParameterProperty(parameter) {
      return (0, _builder.default)("TSParameterProperty", ...arguments);
    }
    function tsDeclareFunction(id, typeParameters, params, returnType) {
      return (0, _builder.default)("TSDeclareFunction", ...arguments);
    }
    function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
      return (0, _builder.default)("TSDeclareMethod", ...arguments);
    }
    function tsQualifiedName(left, right) {
      return (0, _builder.default)("TSQualifiedName", ...arguments);
    }
    function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation2) {
      return (0, _builder.default)("TSCallSignatureDeclaration", ...arguments);
    }
    function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation2) {
      return (0, _builder.default)("TSConstructSignatureDeclaration", ...arguments);
    }
    function tsPropertySignature(key, typeAnnotation2, initializer) {
      return (0, _builder.default)("TSPropertySignature", ...arguments);
    }
    function tsMethodSignature(key, typeParameters, parameters, typeAnnotation2) {
      return (0, _builder.default)("TSMethodSignature", ...arguments);
    }
    function tsIndexSignature(parameters, typeAnnotation2) {
      return (0, _builder.default)("TSIndexSignature", ...arguments);
    }
    function tsAnyKeyword() {
      return (0, _builder.default)("TSAnyKeyword", ...arguments);
    }
    function tsBooleanKeyword() {
      return (0, _builder.default)("TSBooleanKeyword", ...arguments);
    }
    function tsBigIntKeyword() {
      return (0, _builder.default)("TSBigIntKeyword", ...arguments);
    }
    function tsIntrinsicKeyword() {
      return (0, _builder.default)("TSIntrinsicKeyword", ...arguments);
    }
    function tsNeverKeyword() {
      return (0, _builder.default)("TSNeverKeyword", ...arguments);
    }
    function tsNullKeyword() {
      return (0, _builder.default)("TSNullKeyword", ...arguments);
    }
    function tsNumberKeyword() {
      return (0, _builder.default)("TSNumberKeyword", ...arguments);
    }
    function tsObjectKeyword() {
      return (0, _builder.default)("TSObjectKeyword", ...arguments);
    }
    function tsStringKeyword() {
      return (0, _builder.default)("TSStringKeyword", ...arguments);
    }
    function tsSymbolKeyword() {
      return (0, _builder.default)("TSSymbolKeyword", ...arguments);
    }
    function tsUndefinedKeyword() {
      return (0, _builder.default)("TSUndefinedKeyword", ...arguments);
    }
    function tsUnknownKeyword() {
      return (0, _builder.default)("TSUnknownKeyword", ...arguments);
    }
    function tsVoidKeyword() {
      return (0, _builder.default)("TSVoidKeyword", ...arguments);
    }
    function tsThisType() {
      return (0, _builder.default)("TSThisType", ...arguments);
    }
    function tsFunctionType(typeParameters, parameters, typeAnnotation2) {
      return (0, _builder.default)("TSFunctionType", ...arguments);
    }
    function tsConstructorType(typeParameters, parameters, typeAnnotation2) {
      return (0, _builder.default)("TSConstructorType", ...arguments);
    }
    function tsTypeReference(typeName, typeParameters) {
      return (0, _builder.default)("TSTypeReference", ...arguments);
    }
    function tsTypePredicate(parameterName, typeAnnotation2, asserts) {
      return (0, _builder.default)("TSTypePredicate", ...arguments);
    }
    function tsTypeQuery(exprName) {
      return (0, _builder.default)("TSTypeQuery", ...arguments);
    }
    function tsTypeLiteral(members) {
      return (0, _builder.default)("TSTypeLiteral", ...arguments);
    }
    function tsArrayType(elementType) {
      return (0, _builder.default)("TSArrayType", ...arguments);
    }
    function tsTupleType(elementTypes) {
      return (0, _builder.default)("TSTupleType", ...arguments);
    }
    function tsOptionalType(typeAnnotation2) {
      return (0, _builder.default)("TSOptionalType", ...arguments);
    }
    function tsRestType(typeAnnotation2) {
      return (0, _builder.default)("TSRestType", ...arguments);
    }
    function tsNamedTupleMember(label, elementType, optional) {
      return (0, _builder.default)("TSNamedTupleMember", ...arguments);
    }
    function tsUnionType(types) {
      return (0, _builder.default)("TSUnionType", ...arguments);
    }
    function tsIntersectionType(types) {
      return (0, _builder.default)("TSIntersectionType", ...arguments);
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _builder.default)("TSConditionalType", ...arguments);
    }
    function tsInferType(typeParameter2) {
      return (0, _builder.default)("TSInferType", ...arguments);
    }
    function tsParenthesizedType(typeAnnotation2) {
      return (0, _builder.default)("TSParenthesizedType", ...arguments);
    }
    function tsTypeOperator(typeAnnotation2) {
      return (0, _builder.default)("TSTypeOperator", ...arguments);
    }
    function tsIndexedAccessType(objectType, indexType) {
      return (0, _builder.default)("TSIndexedAccessType", ...arguments);
    }
    function tsMappedType(typeParameter2, typeAnnotation2, nameType) {
      return (0, _builder.default)("TSMappedType", ...arguments);
    }
    function tsLiteralType(literal) {
      return (0, _builder.default)("TSLiteralType", ...arguments);
    }
    function tsExpressionWithTypeArguments(expression, typeParameters) {
      return (0, _builder.default)("TSExpressionWithTypeArguments", ...arguments);
    }
    function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
      return (0, _builder.default)("TSInterfaceDeclaration", ...arguments);
    }
    function tsInterfaceBody(body) {
      return (0, _builder.default)("TSInterfaceBody", ...arguments);
    }
    function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation2) {
      return (0, _builder.default)("TSTypeAliasDeclaration", ...arguments);
    }
    function tsAsExpression(expression, typeAnnotation2) {
      return (0, _builder.default)("TSAsExpression", ...arguments);
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      return (0, _builder.default)("TSTypeAssertion", ...arguments);
    }
    function tsEnumDeclaration(id, members) {
      return (0, _builder.default)("TSEnumDeclaration", ...arguments);
    }
    function tsEnumMember(id, initializer) {
      return (0, _builder.default)("TSEnumMember", ...arguments);
    }
    function tsModuleDeclaration(id, body) {
      return (0, _builder.default)("TSModuleDeclaration", ...arguments);
    }
    function tsModuleBlock(body) {
      return (0, _builder.default)("TSModuleBlock", ...arguments);
    }
    function tsImportType(argument, qualifier, typeParameters) {
      return (0, _builder.default)("TSImportType", ...arguments);
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _builder.default)("TSImportEqualsDeclaration", ...arguments);
    }
    function tsExternalModuleReference(expression) {
      return (0, _builder.default)("TSExternalModuleReference", ...arguments);
    }
    function tsNonNullExpression(expression) {
      return (0, _builder.default)("TSNonNullExpression", ...arguments);
    }
    function tsExportAssignment(expression) {
      return (0, _builder.default)("TSExportAssignment", ...arguments);
    }
    function tsNamespaceExportDeclaration(id) {
      return (0, _builder.default)("TSNamespaceExportDeclaration", ...arguments);
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return (0, _builder.default)("TSTypeAnnotation", ...arguments);
    }
    function tsTypeParameterInstantiation(params) {
      return (0, _builder.default)("TSTypeParameterInstantiation", ...arguments);
    }
    function tsTypeParameterDeclaration(params) {
      return (0, _builder.default)("TSTypeParameterDeclaration", ...arguments);
    }
    function tsTypeParameter(constraint, _default, name) {
      return (0, _builder.default)("TSTypeParameter", ...arguments);
    }
    function NumberLiteral(...args) {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
      return (0, _builder.default)("NumberLiteral", ...args);
    }
    function RegexLiteral(...args) {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
      return (0, _builder.default)("RegexLiteral", ...args);
    }
    function RestProperty(...args) {
      console.trace("The node type RestProperty has been renamed to RestElement");
      return (0, _builder.default)("RestProperty", ...args);
    }
    function SpreadProperty(...args) {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");
      return (0, _builder.default)("SpreadProperty", ...args);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cleanJSXElementLiteralChild;
    var _generated = require_generated2();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push((0, _generated.stringLiteral)(str));
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildChildren;
    var _generated = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child))
          child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNode2;
    var _definitions = require_definitions();
    function isNode2(node) {
      return !!(node && _definitions.VISITOR_KEYS[node.type]);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/asserts/assertNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/asserts/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertArrayExpression = assertArrayExpression;
    exports2.assertAssignmentExpression = assertAssignmentExpression;
    exports2.assertBinaryExpression = assertBinaryExpression;
    exports2.assertInterpreterDirective = assertInterpreterDirective;
    exports2.assertDirective = assertDirective;
    exports2.assertDirectiveLiteral = assertDirectiveLiteral;
    exports2.assertBlockStatement = assertBlockStatement;
    exports2.assertBreakStatement = assertBreakStatement;
    exports2.assertCallExpression = assertCallExpression;
    exports2.assertCatchClause = assertCatchClause;
    exports2.assertConditionalExpression = assertConditionalExpression;
    exports2.assertContinueStatement = assertContinueStatement;
    exports2.assertDebuggerStatement = assertDebuggerStatement;
    exports2.assertDoWhileStatement = assertDoWhileStatement;
    exports2.assertEmptyStatement = assertEmptyStatement;
    exports2.assertExpressionStatement = assertExpressionStatement;
    exports2.assertFile = assertFile;
    exports2.assertForInStatement = assertForInStatement;
    exports2.assertForStatement = assertForStatement;
    exports2.assertFunctionDeclaration = assertFunctionDeclaration;
    exports2.assertFunctionExpression = assertFunctionExpression;
    exports2.assertIdentifier = assertIdentifier;
    exports2.assertIfStatement = assertIfStatement;
    exports2.assertLabeledStatement = assertLabeledStatement;
    exports2.assertStringLiteral = assertStringLiteral;
    exports2.assertNumericLiteral = assertNumericLiteral;
    exports2.assertNullLiteral = assertNullLiteral;
    exports2.assertBooleanLiteral = assertBooleanLiteral;
    exports2.assertRegExpLiteral = assertRegExpLiteral;
    exports2.assertLogicalExpression = assertLogicalExpression;
    exports2.assertMemberExpression = assertMemberExpression;
    exports2.assertNewExpression = assertNewExpression;
    exports2.assertProgram = assertProgram;
    exports2.assertObjectExpression = assertObjectExpression;
    exports2.assertObjectMethod = assertObjectMethod;
    exports2.assertObjectProperty = assertObjectProperty;
    exports2.assertRestElement = assertRestElement;
    exports2.assertReturnStatement = assertReturnStatement;
    exports2.assertSequenceExpression = assertSequenceExpression;
    exports2.assertParenthesizedExpression = assertParenthesizedExpression;
    exports2.assertSwitchCase = assertSwitchCase;
    exports2.assertSwitchStatement = assertSwitchStatement;
    exports2.assertThisExpression = assertThisExpression;
    exports2.assertThrowStatement = assertThrowStatement;
    exports2.assertTryStatement = assertTryStatement;
    exports2.assertUnaryExpression = assertUnaryExpression;
    exports2.assertUpdateExpression = assertUpdateExpression;
    exports2.assertVariableDeclaration = assertVariableDeclaration;
    exports2.assertVariableDeclarator = assertVariableDeclarator;
    exports2.assertWhileStatement = assertWhileStatement;
    exports2.assertWithStatement = assertWithStatement;
    exports2.assertAssignmentPattern = assertAssignmentPattern;
    exports2.assertArrayPattern = assertArrayPattern;
    exports2.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports2.assertClassBody = assertClassBody;
    exports2.assertClassExpression = assertClassExpression;
    exports2.assertClassDeclaration = assertClassDeclaration;
    exports2.assertExportAllDeclaration = assertExportAllDeclaration;
    exports2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports2.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports2.assertExportSpecifier = assertExportSpecifier;
    exports2.assertForOfStatement = assertForOfStatement;
    exports2.assertImportDeclaration = assertImportDeclaration;
    exports2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports2.assertImportSpecifier = assertImportSpecifier;
    exports2.assertMetaProperty = assertMetaProperty;
    exports2.assertClassMethod = assertClassMethod;
    exports2.assertObjectPattern = assertObjectPattern;
    exports2.assertSpreadElement = assertSpreadElement;
    exports2.assertSuper = assertSuper;
    exports2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports2.assertTemplateElement = assertTemplateElement;
    exports2.assertTemplateLiteral = assertTemplateLiteral;
    exports2.assertYieldExpression = assertYieldExpression;
    exports2.assertAwaitExpression = assertAwaitExpression;
    exports2.assertImport = assertImport;
    exports2.assertBigIntLiteral = assertBigIntLiteral;
    exports2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports2.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports2.assertOptionalCallExpression = assertOptionalCallExpression;
    exports2.assertClassProperty = assertClassProperty;
    exports2.assertClassPrivateProperty = assertClassPrivateProperty;
    exports2.assertClassPrivateMethod = assertClassPrivateMethod;
    exports2.assertPrivateName = assertPrivateName;
    exports2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports2.assertClassImplements = assertClassImplements;
    exports2.assertDeclareClass = assertDeclareClass;
    exports2.assertDeclareFunction = assertDeclareFunction;
    exports2.assertDeclareInterface = assertDeclareInterface;
    exports2.assertDeclareModule = assertDeclareModule;
    exports2.assertDeclareModuleExports = assertDeclareModuleExports;
    exports2.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports2.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports2.assertDeclareVariable = assertDeclareVariable;
    exports2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports2.assertDeclaredPredicate = assertDeclaredPredicate;
    exports2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports2.assertFunctionTypeParam = assertFunctionTypeParam;
    exports2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports2.assertInferredPredicate = assertInferredPredicate;
    exports2.assertInterfaceExtends = assertInterfaceExtends;
    exports2.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports2.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports2.assertObjectTypeProperty = assertObjectTypeProperty;
    exports2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports2.assertOpaqueType = assertOpaqueType;
    exports2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports2.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports2.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports2.assertTypeAlias = assertTypeAlias;
    exports2.assertTypeAnnotation = assertTypeAnnotation;
    exports2.assertTypeCastExpression = assertTypeCastExpression;
    exports2.assertTypeParameter = assertTypeParameter;
    exports2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports2.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports2.assertVariance = assertVariance;
    exports2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports2.assertEnumDeclaration = assertEnumDeclaration;
    exports2.assertEnumBooleanBody = assertEnumBooleanBody;
    exports2.assertEnumNumberBody = assertEnumNumberBody;
    exports2.assertEnumStringBody = assertEnumStringBody;
    exports2.assertEnumSymbolBody = assertEnumSymbolBody;
    exports2.assertEnumBooleanMember = assertEnumBooleanMember;
    exports2.assertEnumNumberMember = assertEnumNumberMember;
    exports2.assertEnumStringMember = assertEnumStringMember;
    exports2.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports2.assertIndexedAccessType = assertIndexedAccessType;
    exports2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports2.assertJSXAttribute = assertJSXAttribute;
    exports2.assertJSXClosingElement = assertJSXClosingElement;
    exports2.assertJSXElement = assertJSXElement;
    exports2.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports2.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports2.assertJSXSpreadChild = assertJSXSpreadChild;
    exports2.assertJSXIdentifier = assertJSXIdentifier;
    exports2.assertJSXMemberExpression = assertJSXMemberExpression;
    exports2.assertJSXNamespacedName = assertJSXNamespacedName;
    exports2.assertJSXOpeningElement = assertJSXOpeningElement;
    exports2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports2.assertJSXText = assertJSXText;
    exports2.assertJSXFragment = assertJSXFragment;
    exports2.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports2.assertJSXClosingFragment = assertJSXClosingFragment;
    exports2.assertNoop = assertNoop;
    exports2.assertPlaceholder = assertPlaceholder;
    exports2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports2.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports2.assertBindExpression = assertBindExpression;
    exports2.assertImportAttribute = assertImportAttribute;
    exports2.assertDecorator = assertDecorator;
    exports2.assertDoExpression = assertDoExpression;
    exports2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports2.assertRecordExpression = assertRecordExpression;
    exports2.assertTupleExpression = assertTupleExpression;
    exports2.assertDecimalLiteral = assertDecimalLiteral;
    exports2.assertStaticBlock = assertStaticBlock;
    exports2.assertModuleExpression = assertModuleExpression;
    exports2.assertTopicReference = assertTopicReference;
    exports2.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports2.assertPipelineBareFunction = assertPipelineBareFunction;
    exports2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports2.assertTSParameterProperty = assertTSParameterProperty;
    exports2.assertTSDeclareFunction = assertTSDeclareFunction;
    exports2.assertTSDeclareMethod = assertTSDeclareMethod;
    exports2.assertTSQualifiedName = assertTSQualifiedName;
    exports2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports2.assertTSPropertySignature = assertTSPropertySignature;
    exports2.assertTSMethodSignature = assertTSMethodSignature;
    exports2.assertTSIndexSignature = assertTSIndexSignature;
    exports2.assertTSAnyKeyword = assertTSAnyKeyword;
    exports2.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports2.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports2.assertTSNeverKeyword = assertTSNeverKeyword;
    exports2.assertTSNullKeyword = assertTSNullKeyword;
    exports2.assertTSNumberKeyword = assertTSNumberKeyword;
    exports2.assertTSObjectKeyword = assertTSObjectKeyword;
    exports2.assertTSStringKeyword = assertTSStringKeyword;
    exports2.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports2.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports2.assertTSVoidKeyword = assertTSVoidKeyword;
    exports2.assertTSThisType = assertTSThisType;
    exports2.assertTSFunctionType = assertTSFunctionType;
    exports2.assertTSConstructorType = assertTSConstructorType;
    exports2.assertTSTypeReference = assertTSTypeReference;
    exports2.assertTSTypePredicate = assertTSTypePredicate;
    exports2.assertTSTypeQuery = assertTSTypeQuery;
    exports2.assertTSTypeLiteral = assertTSTypeLiteral;
    exports2.assertTSArrayType = assertTSArrayType;
    exports2.assertTSTupleType = assertTSTupleType;
    exports2.assertTSOptionalType = assertTSOptionalType;
    exports2.assertTSRestType = assertTSRestType;
    exports2.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports2.assertTSUnionType = assertTSUnionType;
    exports2.assertTSIntersectionType = assertTSIntersectionType;
    exports2.assertTSConditionalType = assertTSConditionalType;
    exports2.assertTSInferType = assertTSInferType;
    exports2.assertTSParenthesizedType = assertTSParenthesizedType;
    exports2.assertTSTypeOperator = assertTSTypeOperator;
    exports2.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports2.assertTSMappedType = assertTSMappedType;
    exports2.assertTSLiteralType = assertTSLiteralType;
    exports2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports2.assertTSInterfaceBody = assertTSInterfaceBody;
    exports2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports2.assertTSAsExpression = assertTSAsExpression;
    exports2.assertTSTypeAssertion = assertTSTypeAssertion;
    exports2.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports2.assertTSEnumMember = assertTSEnumMember;
    exports2.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports2.assertTSModuleBlock = assertTSModuleBlock;
    exports2.assertTSImportType = assertTSImportType;
    exports2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports2.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports2.assertTSNonNullExpression = assertTSNonNullExpression;
    exports2.assertTSExportAssignment = assertTSExportAssignment;
    exports2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports2.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports2.assertTSTypeParameter = assertTSTypeParameter;
    exports2.assertExpression = assertExpression;
    exports2.assertBinary = assertBinary;
    exports2.assertScopable = assertScopable;
    exports2.assertBlockParent = assertBlockParent;
    exports2.assertBlock = assertBlock;
    exports2.assertStatement = assertStatement;
    exports2.assertTerminatorless = assertTerminatorless;
    exports2.assertCompletionStatement = assertCompletionStatement;
    exports2.assertConditional = assertConditional;
    exports2.assertLoop = assertLoop;
    exports2.assertWhile = assertWhile;
    exports2.assertExpressionWrapper = assertExpressionWrapper;
    exports2.assertFor = assertFor;
    exports2.assertForXStatement = assertForXStatement;
    exports2.assertFunction = assertFunction;
    exports2.assertFunctionParent = assertFunctionParent;
    exports2.assertPureish = assertPureish;
    exports2.assertDeclaration = assertDeclaration;
    exports2.assertPatternLike = assertPatternLike;
    exports2.assertLVal = assertLVal;
    exports2.assertTSEntityName = assertTSEntityName;
    exports2.assertLiteral = assertLiteral;
    exports2.assertImmutable = assertImmutable;
    exports2.assertUserWhitespacable = assertUserWhitespacable;
    exports2.assertMethod = assertMethod;
    exports2.assertObjectMember = assertObjectMember;
    exports2.assertProperty = assertProperty;
    exports2.assertUnaryLike = assertUnaryLike;
    exports2.assertPattern = assertPattern;
    exports2.assertClass = assertClass;
    exports2.assertModuleDeclaration = assertModuleDeclaration;
    exports2.assertExportDeclaration = assertExportDeclaration;
    exports2.assertModuleSpecifier = assertModuleSpecifier;
    exports2.assertPrivate = assertPrivate;
    exports2.assertFlow = assertFlow;
    exports2.assertFlowType = assertFlowType;
    exports2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports2.assertFlowDeclaration = assertFlowDeclaration;
    exports2.assertFlowPredicate = assertFlowPredicate;
    exports2.assertEnumBody = assertEnumBody;
    exports2.assertEnumMember = assertEnumMember;
    exports2.assertJSX = assertJSX;
    exports2.assertTSTypeElement = assertTSTypeElement;
    exports2.assertTSType = assertTSType;
    exports2.assertTSBaseType = assertTSBaseType;
    exports2.assertNumberLiteral = assertNumberLiteral;
    exports2.assertRegexLiteral = assertRegexLiteral;
    exports2.assertRestProperty = assertRestProperty;
    exports2.assertSpreadProperty = assertSpreadProperty;
    var _is = require_is();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      assert("ModuleDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      console.trace("The node type RestProperty has been renamed to RestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");
      assert("SpreadProperty", node, opts);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTypeAnnotationBasedOnTypeof;
    var _generated = require_generated2();
    function createTypeAnnotationBasedOnTypeof(type) {
      if (type === "string") {
        return (0, _generated.stringTypeAnnotation)();
      } else if (type === "number") {
        return (0, _generated.numberTypeAnnotation)();
      } else if (type === "undefined") {
        return (0, _generated.voidTypeAnnotation)();
      } else if (type === "boolean") {
        return (0, _generated.booleanTypeAnnotation)();
      } else if (type === "function") {
        return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
      } else if (type === "object") {
        return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
      } else if (type === "symbol") {
        return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
      } else if (type === "bigint") {
        return (0, _generated.anyTypeAnnotation)();
      } else {
        throw new Error("Invalid typeof value: " + type);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _generated = require_generated();
    function getQualifiedName(node) {
      return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodes) {
      const generics = {};
      const bases = {};
      const typeGroups = [];
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
          bases[node.type] = node;
          continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
          if (typeGroups.indexOf(node.types) < 0) {
            nodes = nodes.concat(node.types);
            typeGroups.push(node.types);
          }
          continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
          const name = getQualifiedName(node.id);
          if (generics[name]) {
            let existing = generics[name];
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics[name] = node;
          }
          continue;
        }
        types.push(node);
      }
      for (const type of Object.keys(bases)) {
        types.push(bases[type]);
      }
      for (const name of Object.keys(generics)) {
        types.push(generics[name]);
      }
      return types;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createFlowUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types) {
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _generated = require_generated();
    function removeTypeDuplicates(nodes) {
      const generics = {};
      const bases = {};
      const typeGroups = [];
      const types = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _generated.isTSBaseType)(node)) {
          bases[node.type] = node;
          continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
          if (typeGroups.indexOf(node.types) < 0) {
            nodes = nodes.concat(node.types);
            typeGroups.push(node.types);
          }
          continue;
        }
        types.push(node);
      }
      for (const type of Object.keys(bases)) {
        types.push(bases[type]);
      }
      for (const name of Object.keys(generics)) {
        types.push(generics[name]);
      }
      return types;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTSUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    function createTSUnionType(typeAnnotations) {
      const types = typeAnnotations.map((type) => type.typeAnnotation);
      const flattened = (0, _removeTypeDuplicates.default)(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.tsUnionType)(flattened);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _index.arrayExpression;
      }
    });
    Object.defineProperty(exports2, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _index.assignmentExpression;
      }
    });
    Object.defineProperty(exports2, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _index.binaryExpression;
      }
    });
    Object.defineProperty(exports2, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _index.interpreterDirective;
      }
    });
    Object.defineProperty(exports2, "Directive", {
      enumerable: true,
      get: function() {
        return _index.directive;
      }
    });
    Object.defineProperty(exports2, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _index.directiveLiteral;
      }
    });
    Object.defineProperty(exports2, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _index.blockStatement;
      }
    });
    Object.defineProperty(exports2, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _index.breakStatement;
      }
    });
    Object.defineProperty(exports2, "CallExpression", {
      enumerable: true,
      get: function() {
        return _index.callExpression;
      }
    });
    Object.defineProperty(exports2, "CatchClause", {
      enumerable: true,
      get: function() {
        return _index.catchClause;
      }
    });
    Object.defineProperty(exports2, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _index.conditionalExpression;
      }
    });
    Object.defineProperty(exports2, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _index.continueStatement;
      }
    });
    Object.defineProperty(exports2, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _index.debuggerStatement;
      }
    });
    Object.defineProperty(exports2, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _index.doWhileStatement;
      }
    });
    Object.defineProperty(exports2, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _index.emptyStatement;
      }
    });
    Object.defineProperty(exports2, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _index.expressionStatement;
      }
    });
    Object.defineProperty(exports2, "File", {
      enumerable: true,
      get: function() {
        return _index.file;
      }
    });
    Object.defineProperty(exports2, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _index.forInStatement;
      }
    });
    Object.defineProperty(exports2, "ForStatement", {
      enumerable: true,
      get: function() {
        return _index.forStatement;
      }
    });
    Object.defineProperty(exports2, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _index.functionDeclaration;
      }
    });
    Object.defineProperty(exports2, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.functionExpression;
      }
    });
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _index.identifier;
      }
    });
    Object.defineProperty(exports2, "IfStatement", {
      enumerable: true,
      get: function() {
        return _index.ifStatement;
      }
    });
    Object.defineProperty(exports2, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _index.labeledStatement;
      }
    });
    Object.defineProperty(exports2, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _index.stringLiteral;
      }
    });
    Object.defineProperty(exports2, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _index.numericLiteral;
      }
    });
    Object.defineProperty(exports2, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _index.nullLiteral;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteral;
      }
    });
    Object.defineProperty(exports2, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _index.regExpLiteral;
      }
    });
    Object.defineProperty(exports2, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _index.logicalExpression;
      }
    });
    Object.defineProperty(exports2, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _index.memberExpression;
      }
    });
    Object.defineProperty(exports2, "NewExpression", {
      enumerable: true,
      get: function() {
        return _index.newExpression;
      }
    });
    Object.defineProperty(exports2, "Program", {
      enumerable: true,
      get: function() {
        return _index.program;
      }
    });
    Object.defineProperty(exports2, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _index.objectExpression;
      }
    });
    Object.defineProperty(exports2, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _index.objectMethod;
      }
    });
    Object.defineProperty(exports2, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _index.objectProperty;
      }
    });
    Object.defineProperty(exports2, "RestElement", {
      enumerable: true,
      get: function() {
        return _index.restElement;
      }
    });
    Object.defineProperty(exports2, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _index.returnStatement;
      }
    });
    Object.defineProperty(exports2, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _index.sequenceExpression;
      }
    });
    Object.defineProperty(exports2, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _index.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports2, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _index.switchCase;
      }
    });
    Object.defineProperty(exports2, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _index.switchStatement;
      }
    });
    Object.defineProperty(exports2, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _index.thisExpression;
      }
    });
    Object.defineProperty(exports2, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _index.throwStatement;
      }
    });
    Object.defineProperty(exports2, "TryStatement", {
      enumerable: true,
      get: function() {
        return _index.tryStatement;
      }
    });
    Object.defineProperty(exports2, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _index.unaryExpression;
      }
    });
    Object.defineProperty(exports2, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _index.updateExpression;
      }
    });
    Object.defineProperty(exports2, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _index.variableDeclaration;
      }
    });
    Object.defineProperty(exports2, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _index.variableDeclarator;
      }
    });
    Object.defineProperty(exports2, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _index.whileStatement;
      }
    });
    Object.defineProperty(exports2, "WithStatement", {
      enumerable: true,
      get: function() {
        return _index.withStatement;
      }
    });
    Object.defineProperty(exports2, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _index.assignmentPattern;
      }
    });
    Object.defineProperty(exports2, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _index.arrayPattern;
      }
    });
    Object.defineProperty(exports2, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports2, "ClassBody", {
      enumerable: true,
      get: function() {
        return _index.classBody;
      }
    });
    Object.defineProperty(exports2, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _index.classExpression;
      }
    });
    Object.defineProperty(exports2, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _index.classDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportSpecifier;
      }
    });
    Object.defineProperty(exports2, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _index.forOfStatement;
      }
    });
    Object.defineProperty(exports2, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.importDeclaration;
      }
    });
    Object.defineProperty(exports2, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importSpecifier;
      }
    });
    Object.defineProperty(exports2, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _index.metaProperty;
      }
    });
    Object.defineProperty(exports2, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _index.classMethod;
      }
    });
    Object.defineProperty(exports2, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _index.objectPattern;
      }
    });
    Object.defineProperty(exports2, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _index.spreadElement;
      }
    });
    Object.defineProperty(exports2, "Super", {
      enumerable: true,
      get: function() {
        return _index.super;
      }
    });
    Object.defineProperty(exports2, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _index.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports2, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _index.templateElement;
      }
    });
    Object.defineProperty(exports2, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _index.templateLiteral;
      }
    });
    Object.defineProperty(exports2, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _index.yieldExpression;
      }
    });
    Object.defineProperty(exports2, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _index.awaitExpression;
      }
    });
    Object.defineProperty(exports2, "Import", {
      enumerable: true,
      get: function() {
        return _index.import;
      }
    });
    Object.defineProperty(exports2, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _index.bigIntLiteral;
      }
    });
    Object.defineProperty(exports2, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports2, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalCallExpression;
      }
    });
    Object.defineProperty(exports2, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _index.classProperty;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _index.classPrivateProperty;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _index.classPrivateMethod;
      }
    });
    Object.defineProperty(exports2, "PrivateName", {
      enumerable: true,
      get: function() {
        return _index.privateName;
      }
    });
    Object.defineProperty(exports2, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _index.classImplements;
      }
    });
    Object.defineProperty(exports2, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _index.declareClass;
      }
    });
    Object.defineProperty(exports2, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.declareFunction;
      }
    });
    Object.defineProperty(exports2, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _index.declareInterface;
      }
    });
    Object.defineProperty(exports2, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _index.declareModule;
      }
    });
    Object.defineProperty(exports2, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _index.declareModuleExports;
      }
    });
    Object.defineProperty(exports2, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _index.declareTypeAlias;
      }
    });
    Object.defineProperty(exports2, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _index.declareOpaqueType;
      }
    });
    Object.defineProperty(exports2, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _index.declareVariable;
      }
    });
    Object.defineProperty(exports2, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _index.declaredPredicate;
      }
    });
    Object.defineProperty(exports2, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _index.functionTypeParam;
      }
    });
    Object.defineProperty(exports2, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _index.inferredPredicate;
      }
    });
    Object.defineProperty(exports2, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _index.interfaceExtends;
      }
    });
    Object.defineProperty(exports2, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _index.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _index.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports2, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _index.opaqueType;
      }
    });
    Object.defineProperty(exports2, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _index.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _index.typeAlias;
      }
    });
    Object.defineProperty(exports2, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _index.typeCastExpression;
      }
    });
    Object.defineProperty(exports2, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _index.typeParameter;
      }
    });
    Object.defineProperty(exports2, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "Variance", {
      enumerable: true,
      get: function() {
        return _index.variance;
      }
    });
    Object.defineProperty(exports2, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.enumDeclaration;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanBody;
      }
    });
    Object.defineProperty(exports2, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _index.enumNumberBody;
      }
    });
    Object.defineProperty(exports2, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _index.enumStringBody;
      }
    });
    Object.defineProperty(exports2, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _index.enumSymbolBody;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanMember;
      }
    });
    Object.defineProperty(exports2, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _index.enumNumberMember;
      }
    });
    Object.defineProperty(exports2, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _index.enumStringMember;
      }
    });
    Object.defineProperty(exports2, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _index.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports2, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.indexedAccessType;
      }
    });
    Object.defineProperty(exports2, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingElement;
      }
    });
    Object.defineProperty(exports2, "JSXElement", {
      enumerable: true,
      get: function() {
        return _index.jsxElement;
      }
    });
    Object.defineProperty(exports2, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports2, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _index.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports2, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _index.jsxIdentifier;
      }
    });
    Object.defineProperty(exports2, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports2, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _index.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXText", {
      enumerable: true,
      get: function() {
        return _index.jsxText;
      }
    });
    Object.defineProperty(exports2, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxFragment;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports2, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports2, "Noop", {
      enumerable: true,
      get: function() {
        return _index.noop;
      }
    });
    Object.defineProperty(exports2, "Placeholder", {
      enumerable: true,
      get: function() {
        return _index.placeholder;
      }
    });
    Object.defineProperty(exports2, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _index.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports2, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _index.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports2, "BindExpression", {
      enumerable: true,
      get: function() {
        return _index.bindExpression;
      }
    });
    Object.defineProperty(exports2, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _index.importAttribute;
      }
    });
    Object.defineProperty(exports2, "Decorator", {
      enumerable: true,
      get: function() {
        return _index.decorator;
      }
    });
    Object.defineProperty(exports2, "DoExpression", {
      enumerable: true,
      get: function() {
        return _index.doExpression;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _index.recordExpression;
      }
    });
    Object.defineProperty(exports2, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _index.tupleExpression;
      }
    });
    Object.defineProperty(exports2, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _index.decimalLiteral;
      }
    });
    Object.defineProperty(exports2, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _index.staticBlock;
      }
    });
    Object.defineProperty(exports2, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _index.moduleExpression;
      }
    });
    Object.defineProperty(exports2, "TopicReference", {
      enumerable: true,
      get: function() {
        return _index.topicReference;
      }
    });
    Object.defineProperty(exports2, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _index.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports2, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _index.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports2, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _index.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports2, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _index.tsParameterProperty;
      }
    });
    Object.defineProperty(exports2, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports2, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports2, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _index.tsQualifiedName;
      }
    });
    Object.defineProperty(exports2, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _index.tsPropertySignature;
      }
    });
    Object.defineProperty(exports2, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _index.tsMethodSignature;
      }
    });
    Object.defineProperty(exports2, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _index.tsIndexSignature;
      }
    });
    Object.defineProperty(exports2, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports2, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports2, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports2, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNullKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports2, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports2, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsStringKeyword;
      }
    });
    Object.defineProperty(exports2, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports2, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports2, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports2, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports2, "TSThisType", {
      enumerable: true,
      get: function() {
        return _index.tsThisType;
      }
    });
    Object.defineProperty(exports2, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _index.tsFunctionType;
      }
    });
    Object.defineProperty(exports2, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _index.tsConstructorType;
      }
    });
    Object.defineProperty(exports2, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _index.tsTypeReference;
      }
    });
    Object.defineProperty(exports2, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _index.tsTypePredicate;
      }
    });
    Object.defineProperty(exports2, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _index.tsTypeQuery;
      }
    });
    Object.defineProperty(exports2, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _index.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports2, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _index.tsArrayType;
      }
    });
    Object.defineProperty(exports2, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _index.tsTupleType;
      }
    });
    Object.defineProperty(exports2, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _index.tsOptionalType;
      }
    });
    Object.defineProperty(exports2, "TSRestType", {
      enumerable: true,
      get: function() {
        return _index.tsRestType;
      }
    });
    Object.defineProperty(exports2, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _index.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports2, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _index.tsUnionType;
      }
    });
    Object.defineProperty(exports2, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _index.tsIntersectionType;
      }
    });
    Object.defineProperty(exports2, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _index.tsConditionalType;
      }
    });
    Object.defineProperty(exports2, "TSInferType", {
      enumerable: true,
      get: function() {
        return _index.tsInferType;
      }
    });
    Object.defineProperty(exports2, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _index.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports2, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _index.tsTypeOperator;
      }
    });
    Object.defineProperty(exports2, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _index.tsMappedType;
      }
    });
    Object.defineProperty(exports2, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _index.tsLiteralType;
      }
    });
    Object.defineProperty(exports2, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _index.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports2, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _index.tsAsExpression;
      }
    });
    Object.defineProperty(exports2, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports2, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _index.tsEnumMember;
      }
    });
    Object.defineProperty(exports2, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _index.tsModuleBlock;
      }
    });
    Object.defineProperty(exports2, "TSImportType", {
      enumerable: true,
      get: function() {
        return _index.tsImportType;
      }
    });
    Object.defineProperty(exports2, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _index.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports2, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _index.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports2, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _index.tsExportAssignment;
      }
    });
    Object.defineProperty(exports2, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameter;
      }
    });
    Object.defineProperty(exports2, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _index.numberLiteral;
      }
    });
    Object.defineProperty(exports2, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _index.regexLiteral;
      }
    });
    Object.defineProperty(exports2, "RestProperty", {
      enumerable: true,
      get: function() {
        return _index.restProperty;
      }
    });
    Object.defineProperty(exports2, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.spreadProperty;
      }
    });
    var _index = require_generated2();
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneNode;
    var _definitions = require_definitions();
    var _generated = require_generated();
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj2, deep, withoutLoc) {
      if (obj2 && typeof obj2.type === "string") {
        return cloneNode(obj2, deep, withoutLoc);
      }
      return obj2;
    }
    function cloneIfNodeOrArray(obj2, deep, withoutLoc) {
      if (Array.isArray(obj2)) {
        return obj2.map((node) => cloneIfNode(node, deep, withoutLoc));
      }
      return cloneIfNode(obj2, deep, withoutLoc);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      if (!node)
        return node;
      const {
        type
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (has(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
        }
      } else if (!has(_definitions.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
          if (has(node, field)) {
            if (deep) {
              newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (has(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (has(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
      }
      if (has(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
      }
      if (has(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
      }
      if (has(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map(({
        type,
        value,
        loc
      }) => {
        if (withoutLoc) {
          return {
            type,
            value,
            loc: null
          };
        }
        return {
          type,
          value,
          loc
        };
      });
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/clone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/addComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node)
        return node;
      const key = `${type}Comments`;
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key] = node[key].concat(comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/addComment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComment;
    var _addComments = require_addComments();
    function addComment(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/utils/inherit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/inheritsComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/comments/removeComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeComments;
    var _constants = require_constants4();
    function removeComments(node) {
      _constants.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/constants/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSBASETYPE_TYPES = exports2.TSTYPE_TYPES = exports2.TSTYPEELEMENT_TYPES = exports2.JSX_TYPES = exports2.ENUMMEMBER_TYPES = exports2.ENUMBODY_TYPES = exports2.FLOWPREDICATE_TYPES = exports2.FLOWDECLARATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = exports2.FLOWTYPE_TYPES = exports2.FLOW_TYPES = exports2.PRIVATE_TYPES = exports2.MODULESPECIFIER_TYPES = exports2.EXPORTDECLARATION_TYPES = exports2.MODULEDECLARATION_TYPES = exports2.CLASS_TYPES = exports2.PATTERN_TYPES = exports2.UNARYLIKE_TYPES = exports2.PROPERTY_TYPES = exports2.OBJECTMEMBER_TYPES = exports2.METHOD_TYPES = exports2.USERWHITESPACABLE_TYPES = exports2.IMMUTABLE_TYPES = exports2.LITERAL_TYPES = exports2.TSENTITYNAME_TYPES = exports2.LVAL_TYPES = exports2.PATTERNLIKE_TYPES = exports2.DECLARATION_TYPES = exports2.PUREISH_TYPES = exports2.FUNCTIONPARENT_TYPES = exports2.FUNCTION_TYPES = exports2.FORXSTATEMENT_TYPES = exports2.FOR_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = exports2.WHILE_TYPES = exports2.LOOP_TYPES = exports2.CONDITIONAL_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = exports2.TERMINATORLESS_TYPES = exports2.STATEMENT_TYPES = exports2.BLOCK_TYPES = exports2.BLOCKPARENT_TYPES = exports2.SCOPABLE_TYPES = exports2.BINARY_TYPES = exports2.EXPRESSION_TYPES = void 0;
    var _definitions = require_definitions();
    var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
    exports2.EXPRESSION_TYPES = EXPRESSION_TYPES;
    var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
    exports2.BINARY_TYPES = BINARY_TYPES;
    var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
    exports2.SCOPABLE_TYPES = SCOPABLE_TYPES;
    var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
    exports2.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
    exports2.BLOCK_TYPES = BLOCK_TYPES;
    var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
    exports2.STATEMENT_TYPES = STATEMENT_TYPES;
    var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
    exports2.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    exports2.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
    exports2.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
    exports2.LOOP_TYPES = LOOP_TYPES;
    var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
    exports2.WHILE_TYPES = WHILE_TYPES;
    var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    exports2.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
    exports2.FOR_TYPES = FOR_TYPES;
    var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
    exports2.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
    exports2.FUNCTION_TYPES = FUNCTION_TYPES;
    var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
    exports2.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
    exports2.PUREISH_TYPES = PUREISH_TYPES;
    var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
    exports2.DECLARATION_TYPES = DECLARATION_TYPES;
    var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
    exports2.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
    exports2.LVAL_TYPES = LVAL_TYPES;
    var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
    exports2.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
    exports2.LITERAL_TYPES = LITERAL_TYPES;
    var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
    exports2.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    exports2.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
    exports2.METHOD_TYPES = METHOD_TYPES;
    var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
    exports2.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
    exports2.PROPERTY_TYPES = PROPERTY_TYPES;
    var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
    exports2.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
    exports2.PATTERN_TYPES = PATTERN_TYPES;
    var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
    exports2.CLASS_TYPES = CLASS_TYPES;
    var MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
    exports2.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
    var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    exports2.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    exports2.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
    exports2.PRIVATE_TYPES = PRIVATE_TYPES;
    var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
    exports2.FLOW_TYPES = FLOW_TYPES;
    var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
    exports2.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    exports2.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    exports2.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    exports2.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
    exports2.ENUMBODY_TYPES = ENUMBODY_TYPES;
    var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
    exports2.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
    exports2.JSX_TYPES = JSX_TYPES;
    var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    exports2.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
    exports2.TSTYPE_TYPES = TSTYPE_TYPES;
    var TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
    exports2.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBlock;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _generated.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _generated.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _generated.isStatement)(node)) {
          if ((0, _generated.isFunction)(parent)) {
            node = (0, _generated2.returnStatement)(node);
          } else {
            node = (0, _generated2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _generated2.blockStatement)(blockNodes);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/ensureBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      return node[key] = (0, _toBlock.default)(node[key], node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib6();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (const c of input) {
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name)) {
        name = `_${name}`;
      }
      return name || "_";
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier.default)(name);
      if (name === "eval" || name === "arguments")
        name = "_" + name;
      return name;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toComputedKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toComputedKey;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _generated.isIdentifier)(key))
        key = (0, _generated2.stringLiteral)(key.name);
      return key;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _generated = require_generated();
    var _default = toExpression;
    exports2.default = _default;
    function toExpression(node) {
      if ((0, _generated.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _generated.isExpression)(node)) {
        return node;
      }
      if ((0, _generated.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _generated.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _generated.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/traverse/traverseFast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverseFast;
    var _definitions = require_definitions();
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      const keys = _definitions.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      opts = opts || {};
      enter(node, opts);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            traverseFast(node2, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/removeProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeProperties;
    var _constants = require_constants4();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
    function removeProperties(node, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node[key] != null)
          node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key[0] === "_" && node[key] != null)
          node[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node);
      for (const sym of symbols) {
        node[sym] = null;
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toKeyAlias;
    var _generated = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _generated.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _generated.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getBindingIdentifiers;
    var _generated = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly) {
      let search = [].concat(node);
      const ids = Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id)
          continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
          if ((0, _generated.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _generated.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _generated.isFunctionExpression)(id)) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (id[key]) {
              search = search.concat(id[key]);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, scope, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _generated.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _generated.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _generated.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _generated.isVariableDeclaration)(node)) {
          if (node.kind !== "var")
            return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _generated2.sequenceExpression)(exprs);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length))
        return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
      if (!result)
        return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/toStatement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _default = toStatement;
    exports2.default = _default;
    function toStatement(node, ignore) {
      if ((0, _generated.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _generated.isAssignmentExpression)(node)) {
        return (0, _generated2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/converters/valueToNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _generated = require_generated2();
    var _default = valueToNode;
    exports2.default = _default;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _generated.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _generated.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _generated.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _generated.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _generated.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _generated.numericLiteral)(0);
          } else {
            numerator = (0, _generated.numericLiteral)(1);
          }
          result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _generated.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _generated.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _generated.identifier)(key);
          } else {
            nodeKey = (0, _generated.stringLiteral)(key);
          }
          props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = appendToMemberExpression;
    var _generated = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/inherits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherits2;
    var _constants = require_constants4();
    var _inheritsComments = require_inheritsComments();
    function inherits2(child, parent) {
      if (!child || !parent)
        return child;
      for (const key of _constants.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone")
          child[key] = parent[key];
      }
      for (const key of _constants.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = prependToMemberExpression;
    var _generated = require_generated2();
    function prependToMemberExpression(member, prepend) {
      member.object = (0, _generated.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = getOuterBindingIdentifiers;
    exports2.default = _default;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/traverse/traverse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverse2;
    var _definitions = require_definitions();
    function traverse2(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys = _definitions.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      if (enter)
        enter(node, ancestors, state);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child)
              continue;
            ancestors.push({
              node,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit)
        exit(node, ancestors, state);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isBinding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0)
              return true;
          } else {
            if (val === node)
              return true;
          }
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isLet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLet;
    var _generated = require_generated();
    var _constants = require_constants4();
    function isLet(node) {
      return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBlockScoped;
    var _generated = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isImmutable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isImmutable;
    var _isType = require_isType();
    var _generated = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable"))
        return true;
      if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNodesEquivalent;
    var _definitions = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _definitions.VISITOR_KEYS[a.type];
      for (const field of fields) {
        if (typeof a[field] !== typeof b[field]) {
          return false;
        }
        if (a[field] == null && b[field] == null) {
          continue;
        } else if (a[field] == null || b[field] == null) {
          return false;
        }
        if (Array.isArray(a[field])) {
          if (!Array.isArray(b[field])) {
            return false;
          }
          if (a[field].length !== b[field].length) {
            return false;
          }
          for (let i = 0; i < a[field].length; i++) {
            if (!isNodesEquivalent(a[field][i], b[field][i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(a[field])) {
            if (a[field][key] !== b[field][key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(a[field], b[field])) {
          return false;
        }
      }
      return true;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isReferenced.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "JSXMemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.params.includes(node)) {
            return false;
          }
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassPrivateProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          if (parent.value === node) {
            return !grandparent || grandparent.type !== "ObjectPattern";
          }
          return true;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isScope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isScope;
    var _generated = require_generated();
    function isScope(node, parent) {
      if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {
        return true;
      }
      return (0, _generated.isScopable)(node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSpecifierDefault;
    var _generated = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/validators/isVar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isVar;
    var _generated = require_generated();
    var _constants = require_constants4();
    function isVar(node) {
      return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/ast-types/generated/index.js
var require_generated5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/ast-types/generated/index.js"() {
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/index.js
var require_lib7 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-types-npm-7.15.0-20151d256a-6d6bcdfce9.zip/node_modules/@babel/types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true
    };
    Object.defineProperty(exports2, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports2, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports2, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports2, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports2, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports2, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports2, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports2, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports2, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports2, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports2, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports2, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports2, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports2, "toSequenceExpression", {
      enumerable: true,
      get: function() {
        return _toSequenceExpression.default;
      }
    });
    Object.defineProperty(exports2, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports2, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    Object.defineProperty(exports2, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports2, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports2, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports2, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports2, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports2, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports2, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports2, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports2, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports2, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports2, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports2, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports2, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports2, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports2, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports2, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports2, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports2, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports2, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports2, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports2, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    exports2.react = void 0;
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _generated = require_generated3();
    Object.keys(_generated).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _generated[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _generated[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _generated2 = require_generated2();
    Object.keys(_generated2).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _generated2[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _generated2[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _uppercase[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _generated3 = require_generated4();
    Object.keys(_generated3).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _generated3[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _generated3[key];
        }
      });
    });
    var _constants = require_constants4();
    Object.keys(_constants).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _constants[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _constants[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toSequenceExpression = require_toSequenceExpression();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _definitions = require_definitions();
    Object.keys(_definitions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _definitions[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _definitions[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _traverse[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _generated4 = require_generated();
    Object.keys(_generated4).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _generated4[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _generated4[key];
        }
      });
    });
    var _generated5 = require_generated5();
    Object.keys(_generated5).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _generated5[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _generated5[key];
        }
      });
    });
    var react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports2.react = react;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/whitespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.list = exports2.nodes = void 0;
    var t2 = require_lib7();
    var {
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier: isIdentifier2,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral
    } = t2;
    function crawl(node, state = {}) {
      if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
        crawl(node.object, state);
        if (node.computed)
          crawl(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawl(node.left, state);
        crawl(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawl(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier2(node)) {
        state.hasHelper = state.hasHelper || isHelper(node.callee);
      }
      return state;
    }
    function isHelper(node) {
      if (isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier2(node)) {
        return node.name === "require" || node.name[0] === "_";
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier2(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }
    function isType(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier2(node) || isMemberExpression(node);
    }
    var nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return {
            before: state.hasFunction,
            after: true
          };
        }
      },
      SwitchCase(node, parent) {
        return {
          before: !!node.consequent.length || parent.cases[0] === node,
          after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
        };
      },
      LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return {
            after: true
          };
        }
      },
      Literal(node) {
        if (isStringLiteral(node) && node.value === "use strict") {
          return {
            after: true
          };
        }
      },
      CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return {
            before: true,
            after: true
          };
        }
      },
      OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return {
            before: true,
            after: true
          };
        }
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return {
              before: true,
              after: true
            };
          }
        }
      },
      IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return {
            before: true,
            after: true
          };
        }
      }
    };
    exports2.nodes = nodes;
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      if (parent.properties[0] === node) {
        return {
          before: true
        };
      }
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return {
          before: true
        };
      }
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return {
          before: true
        };
      }
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return {
          before: true
        };
      }
    };
    var list = {
      VariableDeclaration(node) {
        return node.declarations.map((decl) => decl.init);
      },
      ArrayExpression(node) {
        return node.elements;
      },
      ObjectExpression(node) {
        return node.properties;
      }
    };
    exports2.list = list;
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      if (typeof amounts === "boolean") {
        amounts = {
          after: amounts,
          before: amounts
        };
      }
      [type].concat(t2.FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        nodes[type2] = function() {
          return amounts;
        };
      });
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/parentheses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.UpdateExpression = UpdateExpression;
    exports2.ObjectExpression = ObjectExpression;
    exports2.DoExpression = DoExpression;
    exports2.Binary = Binary;
    exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSIntersectionType = exports2.TSUnionType = TSUnionType;
    exports2.TSInferType = TSInferType;
    exports2.BinaryExpression = BinaryExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.AwaitExpression = exports2.YieldExpression = YieldExpression;
    exports2.ClassExpression = ClassExpression;
    exports2.UnaryLike = UnaryLike;
    exports2.FunctionExpression = FunctionExpression;
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.OptionalCallExpression = exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.LogicalExpression = LogicalExpression;
    exports2.Identifier = Identifier;
    var t2 = require_lib7();
    var {
      isArrayTypeAnnotation,
      isArrowFunctionExpression,
      isAssignmentExpression,
      isAwaitExpression,
      isBinary,
      isBinaryExpression,
      isCallExpression,
      isClassDeclaration,
      isClassExpression,
      isConditional,
      isConditionalExpression,
      isExportDeclaration,
      isExportDefaultDeclaration,
      isExpressionStatement,
      isFor,
      isForInStatement,
      isForOfStatement,
      isForStatement,
      isIfStatement,
      isIndexedAccessType,
      isIntersectionTypeAnnotation,
      isLogicalExpression,
      isMemberExpression,
      isNewExpression,
      isNullableTypeAnnotation,
      isObjectPattern,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isReturnStatement,
      isSequenceExpression,
      isSwitchStatement,
      isTSArrayType,
      isTSAsExpression,
      isTSIntersectionType,
      isTSNonNullExpression,
      isTSOptionalType,
      isTSRestType,
      isTSTypeAssertion,
      isTSUnionType,
      isTaggedTemplateExpression,
      isThrowStatement,
      isTypeAnnotation,
      isUnaryLike,
      isUnionTypeAnnotation,
      isVariableDeclarator,
      isWhileStatement,
      isYieldExpression
    } = t2;
    var PRECEDENCE = {
      "||": 0,
      "??": 0,
      "&&": 1,
      "|": 2,
      "^": 3,
      "&": 4,
      "==": 5,
      "===": 5,
      "!=": 5,
      "!==": 5,
      "<": 6,
      ">": 6,
      "<=": 6,
      ">=": 6,
      in: 6,
      instanceof: 6,
      ">>": 7,
      "<<": 7,
      ">>>": 7,
      "+": 8,
      "-": 8,
      "*": 9,
      "/": 9,
      "%": 9,
      "**": 10
    };
    var isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;
    var hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, printStack) {
      return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function ObjectExpression(node, parent, printStack) {
      return isFirstInContext(printStack, {
        expressionStatement: true,
        arrowBody: true
      });
    }
    function DoExpression(node, parent, printStack) {
      return !node.async && isFirstInContext(printStack, {
        expressionStatement: true
      });
    }
    function Binary(node, parent) {
      if (node.operator === "**" && isBinaryExpression(parent, {
        operator: "**"
      })) {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
        return true;
      }
      if (isBinary(parent)) {
        const parentOp = parent.operator;
        const parentPos = PRECEDENCE[parentOp];
        const nodeOp = node.operator;
        const nodePos = PRECEDENCE[nodeOp];
        if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
          return true;
        }
      }
    }
    function UnionTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent, {
        objectType: node
      });
    }
    function TSAsExpression() {
      return true;
    }
    function TSTypeAssertion() {
      return true;
    }
    function TSUnionType(node, parent) {
      return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
    }
    function TSInferType(node, parent) {
      return isTSArrayType(parent) || isTSOptionalType(parent);
    }
    function BinaryExpression(node, parent) {
      return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
    }
    function SequenceExpression(node, parent) {
      if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
        return false;
      }
      return true;
    }
    function YieldExpression(node, parent) {
      return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
    }
    function ClassExpression(node, parent, printStack) {
      return isFirstInContext(printStack, {
        expressionStatement: true,
        exportDefault: true
      });
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
        operator: "**",
        left: node
      }) || isClassExtendsClause(node, parent);
    }
    function FunctionExpression(node, parent, printStack) {
      return isFirstInContext(printStack, {
        expressionStatement: true,
        exportDefault: true
      });
    }
    function ArrowFunctionExpression(node, parent) {
      return isExportDeclaration(parent) || ConditionalExpression(node, parent);
    }
    function ConditionalExpression(node, parent) {
      if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
        test: node
      }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent, {
        callee: node
      }) || isMemberExpression(parent, {
        object: node
      });
    }
    function AssignmentExpression(node, parent) {
      if (isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }
    function LogicalExpression(node, parent) {
      switch (node.operator) {
        case "||":
          if (!isLogicalExpression(parent))
            return false;
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return isLogicalExpression(parent, {
            operator: "??"
          });
        case "??":
          return isLogicalExpression(parent) && parent.operator !== "??";
      }
    }
    function Identifier(node, parent, printStack) {
      if (node.name === "let") {
        const isFollowedByBracket = isMemberExpression(parent, {
          object: node,
          computed: true
        }) || isOptionalMemberExpression(parent, {
          object: node,
          computed: true,
          optional: false
        });
        return isFirstInContext(printStack, {
          expressionStatement: isFollowedByBracket,
          forHead: isFollowedByBracket,
          forInHead: isFollowedByBracket,
          forOfHead: true
        });
      }
      return node.name === "async" && isForOfStatement(parent) && node === parent.left;
    }
    function isFirstInContext(printStack, {
      expressionStatement = false,
      arrowBody = false,
      exportDefault = false,
      forHead = false,
      forInHead = false,
      forOfHead = false
    }) {
      let i = printStack.length - 1;
      let node = printStack[i];
      i--;
      let parent = printStack[i];
      while (i >= 0) {
        if (expressionStatement && isExpressionStatement(parent, {
          expression: node
        }) || exportDefault && isExportDefaultDeclaration(parent, {
          declaration: node
        }) || arrowBody && isArrowFunctionExpression(parent, {
          body: node
        }) || forHead && isForStatement(parent, {
          init: node
        }) || forInHead && isForInStatement(parent, {
          left: node
        }) || forOfHead && isForOfStatement(parent, {
          left: node
        })) {
          return true;
        }
        if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
          test: node
        }) || isBinary(parent, {
          left: node
        }) || isAssignmentExpression(parent, {
          left: node
        })) {
          node = parent;
          i--;
          parent = printStack[i];
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/index.js
var require_node5 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.needsWhitespace = needsWhitespace;
    exports2.needsWhitespaceBefore = needsWhitespaceBefore;
    exports2.needsWhitespaceAfter = needsWhitespaceAfter;
    exports2.needsParens = needsParens;
    var whitespace = require_whitespace();
    var parens = require_parentheses();
    var t2 = require_lib7();
    var {
      isCallExpression,
      isExpressionStatement,
      isMemberExpression,
      isNewExpression
    } = t2;
    function expandAliases(obj2) {
      const newObj = {};
      function add(type, func) {
        const fn = newObj[type];
        newObj[type] = fn ? function(node, parent, stack) {
          const result = fn(node, parent, stack);
          return result == null ? func(node, parent, stack) : result;
        } : func;
      }
      for (const type of Object.keys(obj2)) {
        const aliases = t2.FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj2[type]);
          }
        } else {
          add(type, obj2[type]);
        }
      }
      return newObj;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    var expandedWhitespaceList = expandAliases(whitespace.list);
    function find(obj2, node, parent, printStack) {
      const fn = obj2[node.type];
      return fn ? fn(node, parent, printStack) : null;
    }
    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }
      return isMemberExpression(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      if (!node)
        return 0;
      if (isExpressionStatement(node)) {
        node = node.expression;
      }
      let linesInfo = find(expandedWhitespaceNodes, node, parent);
      if (!linesInfo) {
        const items = find(expandedWhitespaceList, node, parent);
        if (items) {
          for (let i = 0; i < items.length; i++) {
            linesInfo = needsWhitespace(items[i], node, type);
            if (linesInfo)
              break;
          }
        }
      }
      if (typeof linesInfo === "object" && linesInfo !== null) {
        return linesInfo[type] || 0;
      }
      return 0;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, "before");
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, "after");
    }
    function needsParens(node, parent, printStack) {
      if (!parent)
        return false;
      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node))
          return true;
      }
      return find(expandedParens, node, parent, printStack);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateElement = TemplateElement;
    exports2.TemplateLiteral = TemplateLiteral;
    var t2 = require_lib7();
    function TaggedTemplateExpression(node) {
      this.print(node.tag, node);
      this.print(node.typeParameters, node);
      this.print(node.quasi, node);
    }
    function TemplateElement(node, parent) {
      const isFirst = parent.quasis[0] === node;
      const isLast = parent.quasis[parent.quasis.length - 1] === node;
      const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
      this.token(value);
    }
    function TemplateLiteral(node) {
      const quasis = node.quasis;
      for (let i = 0; i < quasis.length; i++) {
        this.print(quasis[i], node);
        if (i + 1 < quasis.length) {
          this.print(node.expressions[i], node);
        }
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UnaryExpression = UnaryExpression;
    exports2.DoExpression = DoExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.NewExpression = NewExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.ThisExpression = ThisExpression;
    exports2.Super = Super;
    exports2.Decorator = Decorator;
    exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.OptionalCallExpression = OptionalCallExpression;
    exports2.CallExpression = CallExpression;
    exports2.Import = Import;
    exports2.EmptyStatement = EmptyStatement;
    exports2.ExpressionStatement = ExpressionStatement;
    exports2.AssignmentPattern = AssignmentPattern;
    exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = AssignmentExpression;
    exports2.BindExpression = BindExpression;
    exports2.MemberExpression = MemberExpression;
    exports2.MetaProperty = MetaProperty;
    exports2.PrivateName = PrivateName;
    exports2.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports2.ModuleExpression = ModuleExpression;
    exports2.AwaitExpression = exports2.YieldExpression = void 0;
    var t2 = require_lib7();
    var n = require_node5();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression
    } = t2;
    function UnaryExpression(node) {
      if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
        this.word(node.operator);
        this.space();
      } else {
        this.token(node.operator);
      }
      this.print(node.argument, node);
    }
    function DoExpression(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node.body, node);
    }
    function ParenthesizedExpression(node) {
      this.token("(");
      this.print(node.expression, node);
      this.token(")");
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument, node);
      } else {
        this.startTerminatorless(true);
        this.print(node.argument, node);
        this.endTerminatorless();
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test, node);
      this.space();
      this.token("?");
      this.space();
      this.print(node.consequent, node);
      this.space();
      this.token(":");
      this.space();
      this.print(node.alternate, node);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee, node);
      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      if (node.optional) {
        this.token("?.");
      }
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function SequenceExpression(node) {
      this.printList(node.expressions, node);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function Decorator(node) {
      this.token("@");
      this.print(node.expression, node);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      this.print(node.object, node);
      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (node.optional) {
        this.token("?.");
      }
      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        if (!node.optional) {
          this.token(".");
        }
        this.print(node.property, node);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      if (node.optional) {
        this.token("?.");
      }
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function CallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function Import() {
      this.word("import");
    }
    function buildYieldAwait(keyword) {
      return function(node) {
        this.word(keyword);
        if (node.delegate) {
          this.token("*");
        }
        if (node.argument) {
          this.space();
          const terminatorState = this.startTerminatorless();
          this.print(node.argument, node);
          this.endTerminatorless(terminatorState);
        }
      };
    }
    var YieldExpression = buildYieldAwait("yield");
    exports2.YieldExpression = YieldExpression;
    var AwaitExpression = buildYieldAwait("await");
    exports2.AwaitExpression = AwaitExpression;
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.print(node.expression, node);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left, node);
      if (node.left.optional)
        this.token("?");
      this.print(node.left.typeAnnotation, node);
      this.space();
      this.token("=");
      this.space();
      this.print(node.right, node);
    }
    function AssignmentExpression(node, parent) {
      const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);
      if (parens) {
        this.token("(");
      }
      this.print(node.left, node);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
      }
      this.space();
      this.print(node.right, node);
      if (parens) {
        this.token(")");
      }
    }
    function BindExpression(node) {
      this.print(node.object, node);
      this.token("::");
      this.print(node.callee, node);
    }
    function MemberExpression(node) {
      this.print(node.object, node);
      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        this.token(".");
        this.print(node.property, node);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta, node);
      this.token(".");
      this.print(node.property, node);
    }
    function PrivateName(node) {
      this.token("#");
      this.print(node.id, node);
    }
    function V8IntrinsicIdentifier(node) {
      this.token("%");
      this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module");
      this.space();
      this.token("{");
      if (node.body.body.length === 0) {
        this.token("}");
      } else {
        this.newline();
        this.printSequence(node.body.body, node, {
          indent: true
        });
        this.rightBrace();
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/statements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WithStatement = WithStatement;
    exports2.IfStatement = IfStatement;
    exports2.ForStatement = ForStatement;
    exports2.WhileStatement = WhileStatement;
    exports2.DoWhileStatement = DoWhileStatement;
    exports2.LabeledStatement = LabeledStatement;
    exports2.TryStatement = TryStatement;
    exports2.CatchClause = CatchClause;
    exports2.SwitchStatement = SwitchStatement;
    exports2.SwitchCase = SwitchCase;
    exports2.DebuggerStatement = DebuggerStatement;
    exports2.VariableDeclaration = VariableDeclaration;
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.ThrowStatement = exports2.BreakStatement = exports2.ReturnStatement = exports2.ContinueStatement = exports2.ForOfStatement = exports2.ForInStatement = void 0;
    var t2 = require_lib7();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = t2;
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.token("(");
      this.print(node.object, node);
      this.token(")");
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.space();
      const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.token("{");
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent, node);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.token("}");
      }
      if (node.alternate) {
        if (this.endsWith(125))
          this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate, node);
      }
    }
    function getLastStatement(statement) {
      if (!isStatement(statement.body))
        return statement;
      return getLastStatement(statement.body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.token("(");
      this.inForStatementInitCounter++;
      this.print(node.init, node);
      this.inForStatementInitCounter--;
      this.token(";");
      if (node.test) {
        this.space();
        this.print(node.test, node);
      }
      this.token(";");
      if (node.update) {
        this.space();
        this.print(node.update, node);
      }
      this.token(")");
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.printBlock(node);
    }
    var buildForXStatement = function(op) {
      return function(node) {
        this.word("for");
        this.space();
        if (op === "of" && node.await) {
          this.word("await");
          this.space();
        }
        this.token("(");
        this.print(node.left, node);
        this.space();
        this.word(op);
        this.space();
        this.print(node.right, node);
        this.token(")");
        this.printBlock(node);
      };
    };
    var ForInStatement = buildForXStatement("in");
    exports2.ForInStatement = ForInStatement;
    var ForOfStatement = buildForXStatement("of");
    exports2.ForOfStatement = ForOfStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body, node);
      this.space();
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.semicolon();
    }
    function buildLabelStatement(prefix, key = "label") {
      return function(node) {
        this.word(prefix);
        const label = node[key];
        if (label) {
          this.space();
          const isLabel = key == "label";
          const terminatorState = this.startTerminatorless(isLabel);
          this.print(label, node);
          this.endTerminatorless(terminatorState);
        }
        this.semicolon();
      };
    }
    var ContinueStatement = buildLabelStatement("continue");
    exports2.ContinueStatement = ContinueStatement;
    var ReturnStatement = buildLabelStatement("return", "argument");
    exports2.ReturnStatement = ReturnStatement;
    var BreakStatement = buildLabelStatement("break");
    exports2.BreakStatement = BreakStatement;
    var ThrowStatement = buildLabelStatement("throw", "argument");
    exports2.ThrowStatement = ThrowStatement;
    function LabeledStatement(node) {
      this.print(node.label, node);
      this.token(":");
      this.space();
      this.print(node.body, node);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block, node);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0], node);
      } else {
        this.print(node.handler, node);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer, node);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.token("(");
        this.print(node.param, node);
        this.print(node.param.typeAnnotation, node);
        this.token(")");
        this.space();
      }
      this.print(node.body, node);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.token("(");
      this.print(node.discriminant, node);
      this.token(")");
      this.space();
      this.token("{");
      this.printSequence(node.cases, node, {
        indent: true,
        addNewlines(leading, cas) {
          if (!leading && node.cases[node.cases.length - 1] === cas)
            return -1;
        }
      });
      this.token("}");
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test, node);
        this.token(":");
      } else {
        this.word("default");
        this.token(":");
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, node, {
          indent: true
        });
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function variableDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith(10)) {
        for (let i = 0; i < 4; i++)
          this.space(true);
      }
    }
    function constDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith(10)) {
        for (let i = 0; i < 6; i++)
          this.space(true);
      }
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this.word(node.kind);
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      let separator;
      if (hasInits) {
        separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
      }
      this.printList(node.declarations, node, {
        separator
      });
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node)
            return;
        } else {
          if (parent.left === node)
            return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id, node);
      if (node.definite)
        this.token("!");
      this.print(node.id.typeAnnotation, node);
      if (node.init) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.init, node);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClassExpression = exports2.ClassDeclaration = ClassDeclaration;
    exports2.ClassBody = ClassBody;
    exports2.ClassProperty = ClassProperty;
    exports2.ClassPrivateProperty = ClassPrivateProperty;
    exports2.ClassMethod = ClassMethod;
    exports2.ClassPrivateMethod = ClassPrivateMethod;
    exports2._classMethodHead = _classMethodHead;
    exports2.StaticBlock = StaticBlock;
    var t2 = require_lib7();
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = t2;
    function ClassDeclaration(node, parent) {
      if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
        this.printJoin(node.decorators, node);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id, node);
      }
      this.print(node.typeParameters, node);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass, node);
        this.print(node.superTypeParameters, node);
      }
      if (node.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements, node);
      }
      this.space();
      this.print(node.body, node);
    }
    function ClassBody(node) {
      this.token("{");
      this.printInnerComments(node);
      if (node.body.length === 0) {
        this.token("}");
      } else {
        this.newline();
        this.indent();
        this.printSequence(node.body, node);
        this.dedent();
        if (!this.endsWith(10))
          this.newline();
        this.rightBrace();
      }
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators, node);
      this.source("end", node.key.loc);
      this.tsPrintClassMemberModifiers(node, true);
      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        this._variance(node);
        this.print(node.key, node);
      }
      if (node.optional) {
        this.token("?");
      }
      if (node.definite) {
        this.token("!");
      }
      this.print(node.typeAnnotation, node);
      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators, node);
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.key, node);
      this.print(node.typeAnnotation, node);
      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators, node);
      this.source("end", node.key.loc);
      this.tsPrintClassMemberModifiers(node, false);
      this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static");
      this.space();
      this.token("{");
      if (node.body.length === 0) {
        this.token("}");
      } else {
        this.newline();
        this.printSequence(node.body, node, {
          indent: true
        });
        this.rightBrace();
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/methods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._params = _params;
    exports2._parameters = _parameters;
    exports2._param = _param;
    exports2._methodHead = _methodHead;
    exports2._predicate = _predicate;
    exports2._functionHead = _functionHead;
    exports2.FunctionDeclaration = exports2.FunctionExpression = FunctionExpression;
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    var t2 = require_lib7();
    var {
      isIdentifier: isIdentifier2
    } = t2;
    function _params(node) {
      this.print(node.typeParameters, node);
      this.token("(");
      this._parameters(node.params, node);
      this.token(")");
      this.print(node.returnType, node);
    }
    function _parameters(parameters, parent) {
      for (let i = 0; i < parameters.length; i++) {
        this._param(parameters[i], parent);
        if (i < parameters.length - 1) {
          this.token(",");
          this.space();
        }
      }
    }
    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional)
        this.token("?");
      this.print(parameter.typeAnnotation, parameter);
    }
    function _methodHead(node) {
      const kind = node.kind;
      const key = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this._catchUp("start", key.loc);
        this.word("async");
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.token("*");
        }
      }
      if (node.computed) {
        this.token("[");
        this.print(key, node);
        this.token("]");
      } else {
        this.print(key, node);
      }
      if (node.optional) {
        this.token("?");
      }
      this._params(node);
    }
    function _predicate(node) {
      if (node.predicate) {
        if (!node.returnType) {
          this.token(":");
        }
        this.space();
        this.print(node.predicate, node);
      }
    }
    function _functionHead(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }
      this.word("function");
      if (node.generator)
        this.token("*");
      this.space();
      if (node.id) {
        this.print(node.id, node);
      }
      this._params(node);
      this._predicate(node);
    }
    function FunctionExpression(node) {
      this._functionHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ArrowFunctionExpression(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }
      const firstParam = node.params[0];
      if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && isIdentifier2(firstParam) && !hasTypesOrComments(node, firstParam)) {
        this.print(firstParam, node);
      } else {
        this._params(node);
      }
      this._predicate(node);
      this.space();
      this.token("=>");
      this.space();
      this.print(node.body, node);
    }
    function hasTypesOrComments(node, param) {
      var _param$leadingComment, _param$trailingCommen;
      return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ImportSpecifier = ImportSpecifier;
    exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports2.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports2.ExportSpecifier = ExportSpecifier;
    exports2.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports2.ExportAllDeclaration = ExportAllDeclaration;
    exports2.ExportNamedDeclaration = ExportNamedDeclaration;
    exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports2.ImportDeclaration = ImportDeclaration;
    exports2.ImportAttribute = ImportAttribute;
    exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    var t2 = require_lib7();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = t2;
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported, node);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local, node);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local, node);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported, node);
    }
    function ExportSpecifier(node) {
      this.print(node.local, node);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported, node);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
    function ExportAllDeclaration(node) {
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.token("*");
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
      this.printAssertions(node);
      this.semicolon();
    }
    function ExportNamedDeclaration(node) {
      if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
        this.printJoin(node.declaration.decorators, node);
      }
      this.word("export");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }
    function ExportDefaultDeclaration(node) {
      if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
        this.printJoin(node.declaration.decorators, node);
      }
      this.word("export");
      this.space();
      this.word("default");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }
    function ExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar))
          this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          this.token("{");
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, node);
            this.space();
          }
          this.token("}");
        }
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source, node);
          this.printAssertions(node);
        }
        this.semicolon();
      }
    }
    function ImportDeclaration(node) {
      this.word("import");
      this.space();
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      if (specifiers != null && specifiers.length) {
        for (; ; ) {
          const first = specifiers[0];
          if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length) {
          this.token("{");
          this.space();
          this.printList(specifiers, node);
          this.space();
          this.token("}");
        }
        this.space();
        this.word("from");
        this.space();
      }
      this.print(node.source, node);
      this.printAssertions(node);
      {
        var _node$attributes;
        if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
          this.space();
          this.word("with");
          this.space();
          this.printList(node.attributes, node);
        }
      }
      this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key);
      this.token(":");
      this.space();
      this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/jsesc-npm-2.5.2-c5acb78804-4dc1907711.zip/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/jsesc-npm-2.5.2-c5acb78804-4dc1907711.zip/node_modules/jsesc/jsesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var toString = object.toString;
    var isArray = Array.isArray;
    var isBuffer = Buffer.isBuffer;
    var isObject2 = (value) => {
      return toString.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString.call(value) == "[object Number]";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString.call(value) == "[object Set]";
    };
    var singleEscapes = {
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /["'\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument)) {
          if (json) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }
            return "0x" + hexadecimal;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const string = argument;
      let index = -1;
      const length = string.length;
      result = "";
      while (++index < length) {
        const character = string.charAt(index);
        if (options.es6) {
          const first = string.charCodeAt(index);
          if (first >= 55296 && first <= 56319 && length > index + 1) {
            const second = string.charCodeAt(index + 1);
            if (second >= 56320 && second <= 57343) {
              const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
              let hexadecimal2 = codePoint.toString(16);
              if (!lowercaseHex) {
                hexadecimal2 = hexadecimal2.toUpperCase();
              }
              result += "\\u{" + hexadecimal2 + "}";
              ++index;
              continue;
            }
          }
        }
        if (!options.escapeEverything) {
          if (regexWhitelist.test(character)) {
            result += character;
            continue;
          }
          if (character == '"') {
            result += quote == character ? '\\"' : character;
            continue;
          }
          if (character == "`") {
            result += quote == character ? "\\`" : character;
            continue;
          }
          if (character == "'") {
            result += quote == character ? "\\'" : character;
            continue;
          }
        }
        if (character == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
          result += "\\0";
          continue;
        }
        if (regexSingleEscape.test(character)) {
          result += singleEscapes[character];
          continue;
        }
        const charCode = character.charCodeAt(0);
        if (options.minimal && charCode != 8232 && charCode != 8233) {
          result += character;
          continue;
        }
        let hexadecimal = charCode.toString(16);
        if (!lowercaseHex) {
          hexadecimal = hexadecimal.toUpperCase();
        }
        const longhand = hexadecimal.length > 2 || json;
        const escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
        result += escaped;
        continue;
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        return result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      return result;
    };
    jsesc.version = "2.5.2";
    module2.exports = jsesc;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/types.js
var require_types2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Identifier = Identifier;
    exports2.ArgumentPlaceholder = ArgumentPlaceholder;
    exports2.SpreadElement = exports2.RestElement = RestElement;
    exports2.ObjectPattern = exports2.ObjectExpression = ObjectExpression;
    exports2.ObjectMethod = ObjectMethod;
    exports2.ObjectProperty = ObjectProperty;
    exports2.ArrayPattern = exports2.ArrayExpression = ArrayExpression;
    exports2.RecordExpression = RecordExpression;
    exports2.TupleExpression = TupleExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.StringLiteral = StringLiteral;
    exports2.BigIntLiteral = BigIntLiteral;
    exports2.DecimalLiteral = DecimalLiteral;
    exports2.TopicReference = TopicReference;
    exports2.PipelineTopicExpression = PipelineTopicExpression;
    exports2.PipelineBareFunction = PipelineBareFunction;
    exports2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    var t2 = require_lib7();
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier: isIdentifier2
    } = t2;
    function Identifier(node) {
      this.exactSource(node.loc, () => {
        this.word(node.name);
      });
    }
    function ArgumentPlaceholder() {
      this.token("?");
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument, node);
    }
    function ObjectExpression(node) {
      const props = node.properties;
      this.token("{");
      this.printInnerComments(node);
      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.token("}");
    }
    function ObjectMethod(node) {
      this.printJoin(node.decorators, node);
      this._methodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ObjectProperty(node) {
      this.printJoin(node.decorators, node);
      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier2(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value, node);
          return;
        }
        this.print(node.key, node);
        if (node.shorthand && isIdentifier2(node.key) && isIdentifier2(node.value) && node.key.name === node.value.name) {
          return;
        }
      }
      this.token(":");
      this.space();
      this.print(node.value, node);
    }
    function ArrayExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      this.token("[");
      this.printInnerComments(node);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0)
            this.space();
          this.print(elem, node);
          if (i < len - 1)
            this.token(",");
        } else {
          this.token(",");
        }
      }
      this.token("]");
    }
    function RecordExpression(node) {
      const props = node.properties;
      let startToken;
      let endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#{";
        endToken = "}";
      } else {
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      }
      this.token(startToken);
      this.printInnerComments(node);
      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true
        });
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      }
      this.token(startToken);
      this.printInnerComments(node);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0)
            this.space();
          this.print(elem, node);
          if (i < len - 1)
            this.token(",");
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value + "";
      if (opts.numbers) {
        this.number(_jsesc(node.value, opts));
      } else if (raw == null) {
        this.number(value);
      } else if (this.format.minified) {
        this.number(raw.length < value.length ? raw : value);
      } else {
        this.number(raw);
      }
    }
    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
        json: true
      }));
      return this.token(val);
    }
    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw != null) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    function DecimalLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw != null) {
        this.word(raw);
        return;
      }
      this.word(node.value + "m");
    }
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      switch (topicToken) {
        case "#":
          this.token("#");
          break;
        default: {
          const givenTopicTokenJSON = JSON.stringify(topicToken);
          const message = `The "topicToken" generator option must be "#" (${givenTopicTokenJSON} received instead).`;
          throw new Error(message);
        }
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression, node);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee, node);
    }
    function PipelinePrimaryTopicReference() {
      this.token("#");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AnyTypeAnnotation = AnyTypeAnnotation;
    exports2.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports2.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports2.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports2.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports2.DeclareClass = DeclareClass;
    exports2.DeclareFunction = DeclareFunction;
    exports2.InferredPredicate = InferredPredicate;
    exports2.DeclaredPredicate = DeclaredPredicate;
    exports2.DeclareInterface = DeclareInterface;
    exports2.DeclareModule = DeclareModule;
    exports2.DeclareModuleExports = DeclareModuleExports;
    exports2.DeclareTypeAlias = DeclareTypeAlias;
    exports2.DeclareOpaqueType = DeclareOpaqueType;
    exports2.DeclareVariable = DeclareVariable;
    exports2.DeclareExportDeclaration = DeclareExportDeclaration;
    exports2.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports2.EnumDeclaration = EnumDeclaration;
    exports2.EnumBooleanBody = EnumBooleanBody;
    exports2.EnumNumberBody = EnumNumberBody;
    exports2.EnumStringBody = EnumStringBody;
    exports2.EnumSymbolBody = EnumSymbolBody;
    exports2.EnumDefaultedMember = EnumDefaultedMember;
    exports2.EnumBooleanMember = EnumBooleanMember;
    exports2.EnumNumberMember = EnumNumberMember;
    exports2.EnumStringMember = EnumStringMember;
    exports2.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.FunctionTypeParam = FunctionTypeParam;
    exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = InterfaceExtends;
    exports2._interfaceish = _interfaceish;
    exports2._variance = _variance;
    exports2.InterfaceDeclaration = InterfaceDeclaration;
    exports2.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports2.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports2.MixedTypeAnnotation = MixedTypeAnnotation;
    exports2.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.NumberTypeAnnotation = NumberTypeAnnotation;
    exports2.StringTypeAnnotation = StringTypeAnnotation;
    exports2.ThisTypeAnnotation = ThisTypeAnnotation;
    exports2.TupleTypeAnnotation = TupleTypeAnnotation;
    exports2.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports2.TypeAlias = TypeAlias;
    exports2.TypeAnnotation = TypeAnnotation;
    exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = TypeParameterInstantiation;
    exports2.TypeParameter = TypeParameter;
    exports2.OpaqueType = OpaqueType;
    exports2.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports2.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports2.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports2.ObjectTypeIndexer = ObjectTypeIndexer;
    exports2.ObjectTypeProperty = ObjectTypeProperty;
    exports2.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports2.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    exports2.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.Variance = Variance;
    exports2.VoidTypeAnnotation = VoidTypeAnnotation;
    exports2.IndexedAccessType = IndexedAccessType;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    var t2 = require_lib7();
    var _modules = require_modules();
    var _types2 = require_types2();
    var {
      isDeclareExportDeclaration,
      isStatement
    } = t2;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, node);
      this.token("[");
      this.token("]");
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation.typeAnnotation, node);
      if (node.predicate) {
        this.space();
        this.print(node.predicate, node);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.token("%");
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.token("%");
      this.word("checks");
      this.token("(");
      this.print(node.value, node);
      this.token(")");
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id, node);
      this.space();
      this.print(node.body, node);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.token(".");
      this.word("exports");
      this.print(node.typeAnnotation, node);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation, node);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.apply(this, arguments);
    }
    function DeclareExportAllDeclaration() {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.apply(this, arguments);
    }
    function EnumDeclaration(node) {
      const {
        id,
        body
      } = node;
      this.word("enum");
      this.space();
      this.print(id, node);
      this.print(body, node);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }
      context.space();
    }
    function enumBody(context, node) {
      const {
        members
      } = node;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member, node);
        context.newline();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      const {
        id
      } = node;
      this.print(id, node);
      this.token(",");
    }
    function enumInitializedMember(context, node) {
      const {
        id,
        init
      } = node;
      context.print(id, node);
      context.space();
      context.token("=");
      context.space();
      context.print(init, node);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar))
          this.semicolon();
      } else {
        this.token("{");
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers, node);
          this.space();
        }
        this.token("}");
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source, node);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.token("*");
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters, node);
      this.token("(");
      if (node.this) {
        this.word("this");
        this.token(":");
        this.space();
        this.print(node.this.typeAnnotation, node);
        if (node.params.length || node.rest) {
          this.token(",");
          this.space();
        }
      }
      this.printList(node.params, node);
      if (node.rest) {
        if (node.params.length) {
          this.token(",");
          this.space();
        }
        this.token("...");
        this.print(node.rest, node);
      }
      this.token(")");
      if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
        this.token(":");
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType, node);
    }
    function FunctionTypeParam(node) {
      this.print(node.name, node);
      if (node.optional)
        this.token("?");
      if (node.name) {
        this.token(":");
        this.space();
      }
      this.print(node.typeAnnotation, node);
    }
    function InterfaceExtends(node) {
      this.print(node.id, node);
      this.print(node.typeParameters, node);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id, node);
      this.print(node.typeParameters, node);
      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends, node);
      }
      if (node.mixins && node.mixins.length) {
        this.space();
        this.word("mixins");
        this.space();
        this.printList(node.mixins, node);
      }
      if (node.implements && node.implements.length) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements, node);
      }
      this.space();
      this.print(node.body, node);
    }
    function _variance(node) {
      if (node.variance) {
        if (node.variance.kind === "plus") {
          this.token("+");
        } else if (node.variance.kind === "minus") {
          this.token("-");
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator() {
      this.space();
      this.token("&");
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      this.word("interface");
      if (node.extends && node.extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends, node);
      }
      this.space();
      this.print(node.body, node);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, node, {
        separator: andSeparator
      });
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.token("[");
      this.printList(node.types, node);
      this.token("]");
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument, node);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);
      this.space();
      this.token("=");
      this.space();
      this.print(node.right, node);
      this.semicolon();
    }
    function TypeAnnotation(node) {
      this.token(":");
      this.space();
      if (node.optional)
        this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function TypeParameterInstantiation(node) {
      this.token("<");
      this.printList(node.params, node, {});
      this.token(">");
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound, node);
      }
      if (node.default) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.default, node);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);
      if (node.supertype) {
        this.token(":");
        this.space();
        this.print(node.supertype, node);
      }
      if (node.impltype) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.impltype, node);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token("{|");
      } else {
        this.token("{");
      }
      const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      if (props.length) {
        this.space();
        this.printJoin(props, node, {
          addNewlines(leading) {
            if (leading && !props[0])
              return 1;
          },
          indent: true,
          statement: true,
          iterator: () => {
            if (props.length !== 1 || node.inexact) {
              this.token(",");
              this.space();
            }
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.token("}");
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.token("[");
      this.token("[");
      this.print(node.id, node);
      this.token("]");
      this.token("]");
      if (node.optional)
        this.token("?");
      if (!node.method) {
        this.token(":");
        this.space();
      }
      this.print(node.value, node);
    }
    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.value, node);
    }
    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.token("[");
      if (node.id) {
        this.print(node.id, node);
        this.token(":");
        this.space();
      }
      this.print(node.key, node);
      this.token("]");
      this.token(":");
      this.space();
      this.print(node.value, node);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key, node);
      if (node.optional)
        this.token("?");
      if (!node.method) {
        this.token(":");
        this.space();
      }
      this.print(node.value, node);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument, node);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification, node);
      this.token(".");
      this.print(node.id, node);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator() {
      this.space();
      this.token("|");
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, node, {
        separator: orSeparator
      });
    }
    function TypeCastExpression(node) {
      this.token("(");
      this.print(node.expression, node);
      this.print(node.typeAnnotation, node);
      this.token(")");
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.token("+");
      } else {
        this.token("-");
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, node);
      this.token("[");
      this.print(node.indexType, node);
      this.token("]");
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType, node);
      if (node.optional) {
        this.token("?.");
      }
      this.token("[");
      this.print(node.indexType, node);
      this.token("]");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.File = File;
    exports2.Program = Program;
    exports2.BlockStatement = BlockStatement;
    exports2.Directive = Directive;
    exports2.DirectiveLiteral = DirectiveLiteral;
    exports2.InterpreterDirective = InterpreterDirective;
    exports2.Placeholder = Placeholder;
    var t2 = require_lib7();
    function File(node) {
      if (node.program) {
        this.print(node.program.interpreter, node);
      }
      this.print(node.program, node);
    }
    function Program(node) {
      this.printInnerComments(node, false);
      this.printSequence(node.directives, node);
      if (node.directives && node.directives.length)
        this.newline();
      this.printSequence(node.body, node);
    }
    function BlockStatement(node) {
      var _node$directives;
      this.token("{");
      this.printInnerComments(node);
      const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (node.body.length || hasDirectives) {
        this.newline();
        this.printSequence(node.directives, node, {
          indent: true
        });
        if (hasDirectives)
          this.newline();
        this.printSequence(node.body, node, {
          indent: true
        });
        this.removeTrailingNewline();
        this.source("end", node.loc);
        if (!this.endsWith(10))
          this.newline();
        this.rightBrace();
      } else {
        this.source("end", node.loc);
        this.token("}");
      }
    }
    function Directive(node) {
      this.print(node.value, node);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (raw != null) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}
`);
    }
    function Placeholder(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");
      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/jsx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSXAttribute = JSXAttribute;
    exports2.JSXIdentifier = JSXIdentifier;
    exports2.JSXNamespacedName = JSXNamespacedName;
    exports2.JSXMemberExpression = JSXMemberExpression;
    exports2.JSXSpreadAttribute = JSXSpreadAttribute;
    exports2.JSXExpressionContainer = JSXExpressionContainer;
    exports2.JSXSpreadChild = JSXSpreadChild;
    exports2.JSXText = JSXText;
    exports2.JSXElement = JSXElement;
    exports2.JSXOpeningElement = JSXOpeningElement;
    exports2.JSXClosingElement = JSXClosingElement;
    exports2.JSXEmptyExpression = JSXEmptyExpression;
    exports2.JSXFragment = JSXFragment;
    exports2.JSXOpeningFragment = JSXOpeningFragment;
    exports2.JSXClosingFragment = JSXClosingFragment;
    var t2 = require_lib7();
    function JSXAttribute(node) {
      this.print(node.name, node);
      if (node.value) {
        this.token("=");
        this.print(node.value, node);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace, node);
      this.token(":");
      this.print(node.name, node);
    }
    function JSXMemberExpression(node) {
      this.print(node.object, node);
      this.token(".");
      this.print(node.property, node);
    }
    function JSXSpreadAttribute(node) {
      this.token("{");
      this.token("...");
      this.print(node.argument, node);
      this.token("}");
    }
    function JSXExpressionContainer(node) {
      this.token("{");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXSpreadChild(node) {
      this.token("{");
      this.token("...");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXText(node) {
      const raw = this.getPossibleRaw(node);
      if (raw != null) {
        this.token(raw);
      } else {
        this.token(node.value);
      }
    }
    function JSXElement(node) {
      const open = node.openingElement;
      this.print(open, node);
      if (open.selfClosing)
        return;
      this.indent();
      for (const child of node.children) {
        this.print(child, node);
      }
      this.dedent();
      this.print(node.closingElement, node);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.token("<");
      this.print(node.name, node);
      this.print(node.typeParameters, node);
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, node, {
          separator: spaceSeparator
        });
      }
      if (node.selfClosing) {
        this.space();
        this.token("/>");
      } else {
        this.token(">");
      }
    }
    function JSXClosingElement(node) {
      this.token("</");
      this.print(node.name, node);
      this.token(">");
    }
    function JSXEmptyExpression(node) {
      this.printInnerComments(node);
    }
    function JSXFragment(node) {
      this.print(node.openingFragment, node);
      this.indent();
      for (const child of node.children) {
        this.print(child, node);
      }
      this.dedent();
      this.print(node.closingFragment, node);
    }
    function JSXOpeningFragment() {
      this.token("<");
      this.token(">");
    }
    function JSXClosingFragment() {
      this.token("</");
      this.token(">");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/typescript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSTypeAnnotation = TSTypeAnnotation;
    exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports2.TSTypeParameter = TSTypeParameter;
    exports2.TSParameterProperty = TSParameterProperty;
    exports2.TSDeclareFunction = TSDeclareFunction;
    exports2.TSDeclareMethod = TSDeclareMethod;
    exports2.TSQualifiedName = TSQualifiedName;
    exports2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports2.TSPropertySignature = TSPropertySignature;
    exports2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports2.TSMethodSignature = TSMethodSignature;
    exports2.TSIndexSignature = TSIndexSignature;
    exports2.TSAnyKeyword = TSAnyKeyword;
    exports2.TSBigIntKeyword = TSBigIntKeyword;
    exports2.TSUnknownKeyword = TSUnknownKeyword;
    exports2.TSNumberKeyword = TSNumberKeyword;
    exports2.TSObjectKeyword = TSObjectKeyword;
    exports2.TSBooleanKeyword = TSBooleanKeyword;
    exports2.TSStringKeyword = TSStringKeyword;
    exports2.TSSymbolKeyword = TSSymbolKeyword;
    exports2.TSVoidKeyword = TSVoidKeyword;
    exports2.TSUndefinedKeyword = TSUndefinedKeyword;
    exports2.TSNullKeyword = TSNullKeyword;
    exports2.TSNeverKeyword = TSNeverKeyword;
    exports2.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports2.TSThisType = TSThisType;
    exports2.TSFunctionType = TSFunctionType;
    exports2.TSConstructorType = TSConstructorType;
    exports2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports2.TSTypeReference = TSTypeReference;
    exports2.TSTypePredicate = TSTypePredicate;
    exports2.TSTypeQuery = TSTypeQuery;
    exports2.TSTypeLiteral = TSTypeLiteral;
    exports2.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
    exports2.tsPrintBraced = tsPrintBraced;
    exports2.TSArrayType = TSArrayType;
    exports2.TSTupleType = TSTupleType;
    exports2.TSOptionalType = TSOptionalType;
    exports2.TSRestType = TSRestType;
    exports2.TSNamedTupleMember = TSNamedTupleMember;
    exports2.TSUnionType = TSUnionType;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSInferType = TSInferType;
    exports2.TSParenthesizedType = TSParenthesizedType;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSIndexedAccessType = TSIndexedAccessType;
    exports2.TSMappedType = TSMappedType;
    exports2.TSLiteralType = TSLiteralType;
    exports2.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
    exports2.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports2.TSInterfaceBody = TSInterfaceBody;
    exports2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSEnumDeclaration = TSEnumDeclaration;
    exports2.TSEnumMember = TSEnumMember;
    exports2.TSModuleDeclaration = TSModuleDeclaration;
    exports2.TSModuleBlock = TSModuleBlock;
    exports2.TSImportType = TSImportType;
    exports2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports2.TSExternalModuleReference = TSExternalModuleReference;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TSExportAssignment = TSExportAssignment;
    exports2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    exports2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    var t2 = require_lib7();
    function TSTypeAnnotation(node) {
      this.token(":");
      this.space();
      if (node.optional)
        this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function TSTypeParameterInstantiation(node) {
      this.token("<");
      this.printList(node.params, node, {});
      this.token(">");
    }
    function TSTypeParameter(node) {
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint, node);
      }
      if (node.default) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.default, node);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node);
      this.token(";");
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.token(";");
    }
    function TSQualifiedName(node) {
      this.print(node.left, node);
      this.token(".");
      this.print(node.right, node);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSPropertySignature(node) {
      const {
        readonly,
        initializer
      } = node;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation, node);
      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }
      this.token(";");
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.token("[");
      }
      this.print(node.key, node);
      if (node.computed) {
        this.token("]");
      }
      if (node.optional) {
        this.token("?");
      }
    }
    function TSMethodSignature(node) {
      const {
        kind
      } = node;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSIndexSignature(node) {
      const {
        readonly,
        static: isStatic
      } = node;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.token("[");
      this._parameters(node.parameters, node);
      this.token("]");
      this.print(node.typeAnnotation, node);
      this.token(";");
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      const {
        typeParameters,
        parameters
      } = node;
      this.print(typeParameters, node);
      this.token("(");
      this._parameters(parameters, node);
      this.token(")");
      this.space();
      this.token("=>");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation, node);
    }
    function TSTypeReference(node) {
      this.print(node.typeName, node);
      this.print(node.typeParameters, node);
    }
    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node.parameterName);
      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
    }
    function TSTypeLiteral(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
    }
    function tsPrintTypeLiteralOrInterfaceBody(members, node) {
      this.tsPrintBraced(members, node);
    }
    function tsPrintBraced(members, node) {
      this.token("{");
      if (members.length) {
        this.indent();
        this.newline();
        for (const member of members) {
          this.print(member, node);
          this.newline();
        }
        this.dedent();
        this.rightBrace();
      } else {
        this.token("}");
      }
    }
    function TSArrayType(node) {
      this.print(node.elementType, node);
      this.token("[]");
    }
    function TSTupleType(node) {
      this.token("[");
      this.printList(node.elementTypes, node);
      this.token("]");
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation, node);
      this.token("?");
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation, node);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label, node);
      if (node.optional)
        this.token("?");
      this.token(":");
      this.space();
      this.print(node.elementType, node);
    }
    function TSUnionType(node) {
      this.tsPrintUnionOrIntersectionType(node, "|");
    }
    function TSIntersectionType(node) {
      this.tsPrintUnionOrIntersectionType(node, "&");
    }
    function tsPrintUnionOrIntersectionType(node, sep) {
      this.printJoin(node.types, node, {
        separator() {
          this.space();
          this.token(sep);
          this.space();
        }
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.token("?");
      this.space();
      this.print(node.trueType);
      this.space();
      this.token(":");
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.token("infer");
      this.space();
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.token("(");
      this.print(node.typeAnnotation, node);
      this.token(")");
    }
    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation, node);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, node);
      this.token("[");
      this.print(node.indexType, node);
      this.token("]");
    }
    function TSMappedType(node) {
      const {
        nameType,
        optional,
        readonly,
        typeParameter
      } = node;
      this.token("{");
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.token("[");
      this.word(typeParameter.name);
      this.space();
      this.word("in");
      this.space();
      this.print(typeParameter.constraint, typeParameter);
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType, node);
      }
      this.token("]");
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.token("?");
      }
      this.token(":");
      this.space();
      this.print(node.typeAnnotation, node);
      this.space();
      this.token("}");
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSLiteralType(node) {
      this.print(node.literal, node);
    }
    function TSExpressionWithTypeArguments(node) {
      this.print(node.expression, node);
      this.print(node.typeParameters, node);
    }
    function TSInterfaceDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz, node);
      }
      this.space();
      this.print(body, node);
    }
    function TSInterfaceBody(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
    }
    function TSTypeAliasDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      this.space();
      this.token("=");
      this.space();
      this.print(typeAnnotation, node);
      this.token(";");
    }
    function TSAsExpression(node) {
      const {
        expression,
        typeAnnotation
      } = node;
      this.print(expression, node);
      this.space();
      this.word("as");
      this.space();
      this.print(typeAnnotation, node);
    }
    function TSTypeAssertion(node) {
      const {
        typeAnnotation,
        expression
      } = node;
      this.token("<");
      this.print(typeAnnotation, node);
      this.token(">");
      this.space();
      this.print(expression, node);
    }
    function TSEnumDeclaration(node) {
      const {
        declare,
        const: isConst,
        id,
        members
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id, node);
      this.space();
      this.tsPrintBraced(members, node);
    }
    function TSEnumMember(node) {
      const {
        id,
        initializer
      } = node;
      this.print(id, node);
      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }
      this.token(",");
    }
    function TSModuleDeclaration(node) {
      const {
        declare,
        id
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (!node.global) {
        this.word(id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id, node);
      if (!node.body) {
        this.token(";");
        return;
      }
      let body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.token(".");
        this.print(body.id, body);
        body = body.body;
      }
      this.space();
      this.print(body, node);
    }
    function TSModuleBlock(node) {
      this.tsPrintBraced(node.body, node);
    }
    function TSImportType(node) {
      const {
        argument,
        qualifier,
        typeParameters
      } = node;
      this.word("import");
      this.token("(");
      this.print(argument, node);
      this.token(")");
      if (qualifier) {
        this.token(".");
        this.print(qualifier, node);
      }
      if (typeParameters) {
        this.print(typeParameters, node);
      }
    }
    function TSImportEqualsDeclaration(node) {
      const {
        isExport,
        id,
        moduleReference
      } = node;
      if (isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id, node);
      this.space();
      this.token("=");
      this.space();
      this.print(moduleReference, node);
      this.token(";");
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression, node);
      this.token(")");
    }
    function TSNonNullExpression(node) {
      this.print(node.expression, node);
      this.token("!");
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.token("=");
      this.space();
      this.print(node.expression, node);
      this.token(";");
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id, node);
    }
    function tsPrintSignatureDeclarationBase(node) {
      const {
        typeParameters,
        parameters
      } = node;
      this.print(typeParameters, node);
      this.token("(");
      this._parameters(parameters, node);
      this.token(")");
      this.print(node.typeAnnotation, node);
    }
    function tsPrintClassMemberModifiers(node, isField) {
      if (isField && node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.override) {
        this.word("override");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      if (isField && node.readonly) {
        this.word("readonly");
        this.space();
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/index.js
var require_generators2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/generators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _templateLiterals[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _expressions[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _statements[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _classes[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _methods[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _modules[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = require_types2();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _types[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _flow[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _base[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _jsx[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _typescript[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buffer = require_buffer();
    var n = require_node5();
    var t2 = require_lib7();
    var generatorFunctions = require_generators2();
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var NON_DECIMAL_LITERAL = /^0[box]/;
    var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
    var {
      isProgram,
      isFile,
      isEmptyStatement
    } = t2;
    var {
      needsParens,
      needsWhitespaceAfter,
      needsWhitespaceBefore
    } = n;
    var Printer = class {
      constructor(format, map) {
        this.inForStatementInitCounter = 0;
        this._printStack = [];
        this._indent = 0;
        this._insideAux = false;
        this._parenPushNewlineState = null;
        this._noLineTerminator = false;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = new WeakSet();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this.format = format;
        this._buf = new _buffer.default(map);
      }
      generate(ast) {
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        if (this.format.compact || this.format.concise)
          return;
        this._indent++;
      }
      dedent() {
        if (this.format.compact || this.format.concise)
          return;
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        this._append(";", !force);
      }
      rightBrace() {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.token("}");
      }
      space(force = false) {
        if (this.format.compact)
          return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str) {
        if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._maybeAddAuxComment();
        this._append(str);
        this._endsWithWord = true;
      }
      number(str) {
        this.word(str);
        this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str) {
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (str === "--" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._maybeAddAuxComment();
        this._append(str);
      }
      newline(i = 1) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
        const charBeforeNewline = this.endsWithCharAndNewline();
        if (charBeforeNewline === 10)
          return;
        if (charBeforeNewline === 123 || charBeforeNewline === 58) {
          i--;
        }
        if (i <= 0)
          return;
        for (let j = 0; j < i; j++) {
          this._newline();
        }
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      withSource(prop, loc, cb) {
        this._catchUp(prop, loc);
        this._buf.withSource(prop, loc, cb);
      }
      _space() {
        this._append(" ", true);
      }
      _newline() {
        this._append("\n", true);
      }
      _append(str, queue = false) {
        this._maybeAddParen(str);
        this._maybeIndent(str);
        if (queue)
          this._buf.queue(str);
        else
          this._buf.append(str);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(str) {
        if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {
          this._buf.queue(this._getIndent());
        }
      }
      _maybeAddParen(str) {
        const parenPushNewlineState = this._parenPushNewlineState;
        if (!parenPushNewlineState)
          return;
        let i;
        for (i = 0; i < str.length && str[i] === " "; i++)
          continue;
        if (i === str.length) {
          return;
        }
        const cha = str[i];
        if (cha !== "\n") {
          if (cha !== "/" || i + 1 === str.length) {
            this._parenPushNewlineState = null;
            return;
          }
          const chaPost = str[i + 1];
          if (chaPost === "*") {
            if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
              return;
            }
          } else if (chaPost !== "/") {
            this._parenPushNewlineState = null;
            return;
          }
        }
        this.token("(");
        this.indent();
        parenPushNewlineState.printed = true;
      }
      _catchUp(prop, loc) {
        if (!this.format.retainLines)
          return;
        const pos = loc ? loc[prop] : null;
        if ((pos == null ? void 0 : pos.line) != null) {
          const count = pos.line - this._buf.getCurrentLine();
          for (let i = 0; i < count; i++) {
            this._newline();
          }
        }
      }
      _getIndent() {
        return this.format.indent.style.repeat(this._indent);
      }
      startTerminatorless(isLabel = false) {
        if (isLabel) {
          this._noLineTerminator = true;
          return null;
        } else {
          return this._parenPushNewlineState = {
            printed: false
          };
        }
      }
      endTerminatorless(state) {
        this._noLineTerminator = false;
        if (state != null && state.printed) {
          this.dedent();
          this.newline();
          this.token(")");
        }
      }
      print(node, parent) {
        if (!node)
          return;
        const oldConcise = this.format.concise;
        if (node._compact) {
          this.format.concise = true;
        }
        const printMethod = this[node.type];
        if (!printMethod) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);
        }
        this._printStack.push(node);
        const oldInAux = this._insideAux;
        this._insideAux = !node.loc;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        let shouldPrintParens = needsParens(node, parent, this._printStack);
        if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
          shouldPrintParens = true;
        }
        if (shouldPrintParens)
          this.token("(");
        this._printLeadingComments(node);
        const loc = isProgram(node) || isFile(node) ? null : node.loc;
        this.withSource("start", loc, () => {
          printMethod.call(this, node, parent);
        });
        this._printTrailingComments(node);
        if (shouldPrintParens)
          this.token(")");
        this._printStack.pop();
        this.format.concise = oldConcise;
        this._insideAux = oldInAux;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode)
          this._printAuxBeforeComment();
        if (!this._insideAux)
          this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode)
          return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode)
          return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
      }
      getPossibleRaw(node) {
        const extra = node.extra;
        if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, parent, opts = {}) {
        if (!(nodes != null && nodes.length))
          return;
        if (opts.indent)
          this.indent();
        const newlineOpts = {
          addNewlines: opts.addNewlines
        };
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node)
            continue;
          if (opts.statement)
            this._printNewline(true, node, parent, newlineOpts);
          this.print(node, parent);
          if (opts.iterator) {
            opts.iterator(node, i);
          }
          if (opts.separator && i < nodes.length - 1) {
            opts.separator.call(this);
          }
          if (opts.statement)
            this._printNewline(false, node, parent, newlineOpts);
        }
        if (opts.indent)
          this.dedent();
      }
      printAndIndentOnComments(node, parent) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent)
          this.indent();
        this.print(node, parent);
        if (indent)
          this.dedent();
      }
      printBlock(parent) {
        const node = parent.body;
        if (!isEmptyStatement(node)) {
          this.space();
        }
        this.print(node, parent);
      }
      _printTrailingComments(node) {
        this._printComments(this._getComments(false, node));
      }
      _printLeadingComments(node) {
        this._printComments(this._getComments(true, node), true);
      }
      printInnerComments(node, indent = true) {
        var _node$innerComments;
        if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length))
          return;
        if (indent)
          this.indent();
        this._printComments(node.innerComments);
        if (indent)
          this.dedent();
      }
      printSequence(nodes, parent, opts = {}) {
        opts.statement = true;
        return this.printJoin(nodes, parent, opts);
      }
      printList(items, parent, opts = {}) {
        if (opts.separator == null) {
          opts.separator = commaSeparator;
        }
        return this.printJoin(items, parent, opts);
      }
      _printNewline(leading, node, parent, opts) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
        let lines = 0;
        if (this._buf.hasContent()) {
          if (!leading)
            lines++;
          if (opts.addNewlines)
            lines += opts.addNewlines(leading, node) || 0;
          const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
          if (needs(node, parent))
            lines++;
        }
        this.newline(Math.min(2, lines));
      }
      _getComments(leading, node) {
        return node && (leading ? node.leadingComments : node.trailingComments) || [];
      }
      _printComment(comment, skipNewLines) {
        if (!this.format.shouldPrintComment(comment.value))
          return;
        if (comment.ignore)
          return;
        if (this._printedComments.has(comment))
          return;
        this._printedComments.add(comment);
        const isBlockComment = comment.type === "CommentBlock";
        const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent())
          this.newline(1);
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123) {
          this.space();
        }
        let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}
` : `/*${comment.value}*/`;
        if (isBlockComment && this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
          if (offset) {
            const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }
          const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
          val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
        }
        if (this.endsWith(47))
          this._space();
        this.withSource("start", comment.loc, () => {
          this._append(val);
        });
        if (printNewLines)
          this.newline(1);
      }
      _printComments(comments, inlinePureAnnotation) {
        if (!(comments != null && comments.length))
          return;
        if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
          this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));
        } else {
          for (const comment of comments) {
            this._printComment(comment);
          }
        }
      }
      printAssertions(node) {
        var _node$assertions;
        if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
          this.space();
          this.word("assert");
          this.space();
          this.token("{");
          this.space();
          this.printList(node.assertions, node);
          this.space();
          this.token("}");
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      Printer.prototype.Noop = function Noop() {
      };
    }
    var _default = Printer;
    exports2.default = _default;
    function commaSeparator() {
      this.token(",");
      this.space();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/index.js
var require_lib8 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-generator-npm-7.15.0-5b452bffe0-ef227c4c39.zip/node_modules/@babel/generator/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generate2;
    exports2.CodeGenerator = void 0;
    var _sourceMap = require_source_map4();
    var _printer = require_printer();
    var Generator = class extends _printer.default {
      constructor(ast, opts = {}, code) {
        const format = normalizeOptions(code, opts);
        const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        super(format, map);
        this.ast = void 0;
        this.ast = ast;
      }
      generate() {
        return super.generate(this.ast);
      }
    };
    function normalizeOptions(code, opts) {
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  ",
          base: 0
        },
        decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
        topicToken: opts.topicToken
      };
      {
        format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
      }
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
      }
      if (format.compact === "auto") {
        format.compact = code.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }
      return format;
    }
    var CodeGenerator = class {
      constructor(ast, opts, code) {
        this._generator = void 0;
        this._generator = new Generator(ast, opts, code);
      }
      generate() {
        return this._generator.generate();
      }
    };
    exports2.CodeGenerator = CodeGenerator;
    function generate2(ast, opts, code) {
      const gen = new Generator(ast, opts, code);
      return gen.generate();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ForAwaitStatement = exports2.NumericLiteralTypeAnnotation = exports2.ExistentialTypeParam = exports2.SpreadProperty = exports2.RestProperty = exports2.Flow = exports2.Pure = exports2.Generated = exports2.User = exports2.Var = exports2.BlockScoped = exports2.Referenced = exports2.Scope = exports2.Expression = exports2.Statement = exports2.BindingIdentifier = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = void 0;
    var t2 = require_lib7();
    var ReferencedIdentifier = {
      types: ["Identifier", "JSXIdentifier"],
      checkPath(path, opts) {
        const {
          node,
          parent
        } = path;
        if (!t2.isIdentifier(node, opts) && !t2.isJSXMemberExpression(parent, opts)) {
          if (t2.isJSXIdentifier(node, opts)) {
            if (t2.react.isCompatTag(node.name))
              return false;
          } else {
            return false;
          }
        }
        return t2.isReferenced(node, parent, path.parentPath.parent);
      }
    };
    exports2.ReferencedIdentifier = ReferencedIdentifier;
    var ReferencedMemberExpression = {
      types: ["MemberExpression"],
      checkPath({
        node,
        parent
      }) {
        return t2.isMemberExpression(node) && t2.isReferenced(node, parent);
      }
    };
    exports2.ReferencedMemberExpression = ReferencedMemberExpression;
    var BindingIdentifier = {
      types: ["Identifier"],
      checkPath(path) {
        const {
          node,
          parent
        } = path;
        const grandparent = path.parentPath.parent;
        return t2.isIdentifier(node) && t2.isBinding(node, parent, grandparent);
      }
    };
    exports2.BindingIdentifier = BindingIdentifier;
    var Statement = {
      types: ["Statement"],
      checkPath({
        node,
        parent
      }) {
        if (t2.isStatement(node)) {
          if (t2.isVariableDeclaration(node)) {
            if (t2.isForXStatement(parent, {
              left: node
            }))
              return false;
            if (t2.isForStatement(parent, {
              init: node
            }))
              return false;
          }
          return true;
        } else {
          return false;
        }
      }
    };
    exports2.Statement = Statement;
    var Expression = {
      types: ["Expression"],
      checkPath(path) {
        if (path.isIdentifier()) {
          return path.isReferencedIdentifier();
        } else {
          return t2.isExpression(path.node);
        }
      }
    };
    exports2.Expression = Expression;
    var Scope = {
      types: ["Scopable", "Pattern"],
      checkPath(path) {
        return t2.isScope(path.node, path.parent);
      }
    };
    exports2.Scope = Scope;
    var Referenced = {
      checkPath(path) {
        return t2.isReferenced(path.node, path.parent);
      }
    };
    exports2.Referenced = Referenced;
    var BlockScoped = {
      checkPath(path) {
        return t2.isBlockScoped(path.node);
      }
    };
    exports2.BlockScoped = BlockScoped;
    var Var = {
      types: ["VariableDeclaration"],
      checkPath(path) {
        return t2.isVar(path.node);
      }
    };
    exports2.Var = Var;
    var User = {
      checkPath(path) {
        return path.node && !!path.node.loc;
      }
    };
    exports2.User = User;
    var Generated = {
      checkPath(path) {
        return !path.isUser();
      }
    };
    exports2.Generated = Generated;
    var Pure = {
      checkPath(path, opts) {
        return path.scope.isPure(path.node, opts);
      }
    };
    exports2.Pure = Pure;
    var Flow = {
      types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
      checkPath({
        node
      }) {
        if (t2.isFlow(node)) {
          return true;
        } else if (t2.isImportDeclaration(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else if (t2.isExportDeclaration(node)) {
          return node.exportKind === "type";
        } else if (t2.isImportSpecifier(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else {
          return false;
        }
      }
    };
    exports2.Flow = Flow;
    var RestProperty = {
      types: ["RestElement"],
      checkPath(path) {
        return path.parentPath && path.parentPath.isObjectPattern();
      }
    };
    exports2.RestProperty = RestProperty;
    var SpreadProperty = {
      types: ["RestElement"],
      checkPath(path) {
        return path.parentPath && path.parentPath.isObjectExpression();
      }
    };
    exports2.SpreadProperty = SpreadProperty;
    var ExistentialTypeParam = {
      types: ["ExistsTypeAnnotation"]
    };
    exports2.ExistentialTypeParam = ExistentialTypeParam;
    var NumericLiteralTypeAnnotation = {
      types: ["NumberLiteralTypeAnnotation"]
    };
    exports2.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
    var ForAwaitStatement = {
      types: ["ForOfStatement"],
      checkPath({
        node
      }) {
        return node.await === true;
      }
    };
    exports2.ForAwaitStatement = ForAwaitStatement;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue)
          return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path) {
        this.constant = false;
        if (this.constantViolations.indexOf(path) !== -1) {
          return;
        }
        this.constantViolations.push(path);
      }
      reference(path) {
        if (this.referencePaths.indexOf(path) !== -1) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports2.default = Binding;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-split-export-declaration-npm-7.14.5-193bcc5a6e-93437025a3.zip/node_modules/@babel/helper-split-export-declaration/lib/index.js
var require_lib9 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-split-export-declaration-npm-7.14.5-193bcc5a6e-93437025a3.zip/node_modules/@babel/helper-split-export-declaration/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = splitExportDeclaration;
    var t2 = require_lib7();
    function splitExportDeclaration(exportDeclaration) {
      if (!exportDeclaration.isExportDeclaration()) {
        throw new Error("Only export declarations can be split.");
      }
      const isDefault = exportDeclaration.isExportDefaultDeclaration();
      const declaration = exportDeclaration.get("declaration");
      const isClassDeclaration = declaration.isClassDeclaration();
      if (isDefault) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
            declaration.node.id = t2.cloneNode(id);
          }
        }
        const updatedDeclaration = standaloneDeclaration ? declaration : t2.variableDeclaration("var", [t2.variableDeclarator(t2.cloneNode(id), declaration.node)]);
        const updatedExportDeclaration = t2.exportNamedDeclaration(null, [t2.exportSpecifier(t2.cloneNode(id), t2.identifier("default"))]);
        exportDeclaration.insertAfter(updatedExportDeclaration);
        exportDeclaration.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(exportDeclaration);
        }
        return exportDeclaration;
      }
      if (exportDeclaration.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name) => {
        return t2.exportSpecifier(t2.identifier(name), t2.identifier(name));
      });
      const aliasDeclar = t2.exportNamedDeclaration(null, specifiers);
      exportDeclaration.insertAfter(aliasDeclar);
      exportDeclaration.replaceWith(declaration.node);
      return exportDeclaration;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _binding = require_binding();
    var _helperSplitExportDeclaration = require_lib9();
    var t2 = require_lib7();
    var renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          skipAllButComputedMethodKey(path);
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration())
          return;
        const ids = path.getOuterBindingIdentifiers();
        for (const name in ids) {
          if (name === state.oldName)
            ids[name].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
          return;
        }
        (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return;
        if (!path.isFunctionDeclaration() && !path.isClassDeclaration())
          return;
        if (this.binding.kind !== "hoisted")
          return;
        path.node.id = t2.identifier(this.oldName);
        path.node._blockHoist = 3;
        path.replaceWith(t2.variableDeclaration("let", [t2.variableDeclarator(t2.identifier(this.newName), t2.toExpression(path.node))]));
      }
      maybeConvertFromClassFunctionExpression(path) {
        return;
        if (!path.isFunctionExpression() && !path.isClassExpression())
          return;
        if (this.binding.kind !== "local")
          return;
        path.node.id = t2.identifier(this.oldName);
        this.binding.scope.parent.push({
          id: t2.identifier(this.newName)
        });
        path.replaceWith(t2.assignmentExpression("=", t2.identifier(this.newName), path.node));
      }
      rename(block) {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path
        } = binding;
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = block || scope.block;
        if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
          blockToTraverse.cases.forEach((c) => {
            scope.traverse(c, renameVisitor, this);
          });
        } else {
          scope.traverse(blockToTraverse, renameVisitor, this);
        }
        if (!block) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
          this.maybeConvertFromClassFunctionExpression(parentDeclar);
        }
      }
    };
    exports2.default = Renamer;
    function skipAllButComputedMethodKey(path) {
      if (!path.isMethod() || !path.node.computed) {
        path.skip();
        return;
      }
      const keys = t2.VISITOR_KEYS[path.type];
      for (const key of keys) {
        if (key !== "key")
          path.skipKey(key);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/globals-npm-11.12.0-1fa7f41a6c-67051a45ec.zip/node_modules/globals/globals.json
var require_globals = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/globals-npm-11.12.0-1fa7f41a6c-67051a45ec.zip/node_modules/globals/globals.json"(exports2, module2) {
    module2.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/globals-npm-11.12.0-1fa7f41a6c-67051a45ec.zip/node_modules/globals/index.js
var require_globals2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/globals-npm-11.12.0-1fa7f41a6c-67051a45ec.zip/node_modules/globals/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_globals();
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    exports2.scope = exports2.path = void 0;
    var path = new WeakMap();
    exports2.path = path;
    var scope = new WeakMap();
    exports2.scope = scope;
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports2.path = path = new WeakMap();
    }
    function clearScope() {
      exports2.scope = scope = new WeakMap();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/scope/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib16();
    var _binding = require_binding();
    var _globals = require_globals2();
    var t2 = require_lib7();
    var _cache = require_cache();
    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (t2.isModuleDeclaration(node)) {
            if ((t2.isExportAllDeclaration(node) || t2.isExportNamedDeclaration(node) || t2.isImportDeclaration(node)) && node.source) {
              gatherNodeParts(node.source, parts);
            } else if ((t2.isExportNamedDeclaration(node) || t2.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
              for (const e of node.specifiers)
                gatherNodeParts(e, parts);
            } else if ((t2.isExportDefaultDeclaration(node) || t2.isExportNamedDeclaration(node)) && node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (t2.isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (t2.isLiteral(node)) {
            parts.push(node.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          parts.push(node.name);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      For(path) {
        for (const key of t2.FOR_INIT_KEYS) {
          const declar = path.get(key);
          if (declar.isVar()) {
            const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
            parentScope.registerBinding("var", declar);
          }
        }
      },
      Declaration(path) {
        if (path.isBlockScoped())
          return;
        if (path.isImportDeclaration())
          return;
        if (path.isExportDeclaration())
          return;
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        state.references.push(path);
      },
      ForXStatement(path, state) {
        const left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        }
      },
      ExportDeclaration: {
        exit(path) {
          const {
            node,
            scope
          } = path;
          if (t2.isExportAllDeclaration(node))
            return;
          const declar = node.declaration;
          if (t2.isClassDeclaration(declar) || t2.isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id)
              return;
            const binding = scope.getBinding(id.name);
            if (binding)
              binding.reference(path);
          } else if (t2.isVariableDeclaration(declar)) {
            for (const decl of declar.declarations) {
              for (const name of Object.keys(t2.getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                if (binding)
                  binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path)
          scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name = id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[t2.NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
        const params = path.get("params");
        for (const param of params) {
          path.scope.registerBinding("param", param);
        }
      },
      ClassExpression(path) {
        if (path.has("id") && !path.get("id").node[t2.NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path);
        }
      }
    };
    var uid = 0;
    var Scope = class {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.labels = void 0;
        this.inited = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node
        } = path;
        const cached = _cache.scope.get(node);
        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }
        _cache.scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          const isKey = path.key === "key";
          path = path.parentPath;
          if (isKey && path.isMethod())
            path = path.parentPath;
          if (path && path.isScope())
            parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      get parentBlock() {
        return this.path.parent;
      }
      get hub() {
        return this.path.hub;
      }
      traverse(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      }
      generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        this.push({
          id
        });
        return t2.cloneNode(id);
      }
      generateUidIdentifier(name) {
        return t2.identifier(this.generateUid(name));
      }
      generateUid(name = "temp") {
        name = t2.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = this._generateUid(name, i);
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program2 = this.getProgramParent();
        program2.references[uid2] = true;
        program2.uids[uid2] = true;
        return uid2;
      }
      _generateUid(name, i) {
        let id = name;
        if (i > 1)
          id += i;
        return `_${id}`;
      }
      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return t2.identifier(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (t2.isThisExpression(node) || t2.isSuper(node)) {
          return true;
        }
        if (t2.isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id
            });
            return t2.cloneNode(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param")
          return;
        if (local.kind === "local")
          return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");
        if (duplicate) {
          throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
      }
      rename(oldName, newName, block) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName = newName || this.generateUidIdentifier(oldName).name;
          return new _renamer.default(binding, oldName, newName).rename(block);
        }
      }
      _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      toArray(node, i, arrayLikeIsIterable) {
        if (t2.isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }
        if (t2.isArrayExpression(node)) {
          return node;
        }
        if (t2.isIdentifier(node, {
          name: "arguments"
        })) {
          return t2.callExpression(t2.memberExpression(t2.memberExpression(t2.memberExpression(t2.identifier("Array"), t2.identifier("prototype")), t2.identifier("slice")), t2.identifier("call")), [node]);
        }
        let helperName;
        const args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (i) {
          args.push(t2.numericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return t2.callExpression(this.hub.addHelper(helperName), args);
      }
      hasLabel(name) {
        return !!this.getLabel(name);
      }
      getLabel(name) {
        return this.labels.get(name);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get("declarations");
          for (const declar of declarations) {
            this.registerBinding(path.node.kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          const specifiers = path.get("specifiers");
          for (const specifier of specifiers) {
            this.registerBinding("module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
      buildUndefinedNode() {
        return t2.unaryExpression("void", t2.numericLiteral(0), true);
      }
      registerConstantViolation(path) {
        const ids = path.getBindingIdentifiers();
        for (const name of Object.keys(ids)) {
          const binding = this.getBinding(name);
          if (binding)
            binding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind)
          throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          const declarators = path.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        for (const name of Object.keys(ids)) {
          parent.references[name] = true;
          for (const id of ids[name]) {
            const local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === id)
                continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }
            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name) {
        let scope = this;
        do {
          if (scope.uids[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name) {
        let scope = this;
        do {
          if (scope.globals[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
      isPure(node, constantsOnly) {
        if (t2.isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding)
            return false;
          if (constantsOnly)
            return binding.constant;
          return true;
        } else if (t2.isClass(node)) {
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (t2.isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly))
              return false;
          }
          return true;
        } else if (t2.isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (t2.isArrayExpression(node)) {
          for (const elem of node.elements) {
            if (!this.isPure(elem, constantsOnly))
              return false;
          }
          return true;
        } else if (t2.isObjectExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly))
              return false;
          }
          return true;
        } else if (t2.isMethod(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          if (node.kind === "get" || node.kind === "set")
            return false;
          return true;
        } else if (t2.isProperty(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          return this.isPure(node.value, constantsOnly);
        } else if (t2.isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (t2.isTaggedTemplateExpression(node)) {
          return t2.matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
        } else if (t2.isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly))
              return false;
          }
          return true;
        } else {
          return t2.isPureish(node);
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null)
            return data;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null)
            scope.data[key] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path = this.path;
        this.references = Object.create(null);
        this.bindings = Object.create(null);
        this.globals = Object.create(null);
        this.uids = Object.create(null);
        this.data = Object.create(null);
        const programParent = this.getProgramParent();
        if (programParent.crawling)
          return;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path.type !== "Program" && collectorVisitor._exploded) {
          for (const visit of collectorVisitor.enter) {
            visit(path, state);
          }
          const typeVisitors = collectorVisitor[path.type];
          if (typeVisitors) {
            for (const visit of typeVisitors.enter) {
              visit(path, state);
            }
          }
        }
        path.traverse(collectorVisitor, state);
        this.crawling = false;
        for (const path2 of state.assignments) {
          const ids = path2.getBindingIdentifiers();
          for (const name of Object.keys(ids)) {
            if (path2.scope.getBinding(name))
              continue;
            programParent.addGlobal(ids[name]);
          }
          path2.scope.registerConstantViolation(path2);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path2 of state.constantViolations) {
          path2.scope.registerConstantViolation(path2);
        }
      }
      push(opts) {
        let path = this.path;
        if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        const unique = opts.unique;
        const kind = opts.kind || "var";
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          const declar = t2.variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer("body", [declar]);
          if (!unique)
            path.setData(dataKey, declarPath);
        }
        const declarator = t2.variableDeclarator(opts.id, opts.init);
        declarPath.node.declarations.push(declarator);
        this.registerBinding(kind, declarPath.get("declarations").pop());
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = Object.create(null);
        let scope = this;
        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      getAllBindingsOfKind(...kinds) {
        const ids = Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              if (binding.kind === kind)
                ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      }
      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
      getBinding(name) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param") {
            } else {
              return binding;
            }
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name) {
        return this.bindings[name];
      }
      getBindingIdentifier(name) {
        var _this$getBinding;
        return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
      }
      getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
      hasBinding(name, noGlobals) {
        if (!name)
          return false;
        if (this.hasOwnBinding(name))
          return true;
        if (this.parentHasBinding(name, noGlobals))
          return true;
        if (this.hasUid(name))
          return true;
        if (!noGlobals && Scope.globals.includes(name))
          return true;
        if (!noGlobals && Scope.contextVariables.includes(name))
          return true;
        return false;
      }
      parentHasBinding(name, noGlobals) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
      }
      moveBindingTo(name, scope) {
        const info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }
      removeOwnBinding(name) {
        delete this.bindings[name];
      }
      removeBinding(name) {
        var _this$getBinding2;
        (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
        let scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
    };
    exports2.default = Scope;
    Scope.globals = Object.keys(_globals.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findParent = findParent;
    exports2.find = find;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getAncestry = getAncestry;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    exports2.inType = inType;
    var t2 = require_lib7();
    var _index = require_path2();
    function findParent(callback) {
      let path = this;
      while (path = path.parentPath) {
        if (callback(path))
          return path;
      }
      return null;
    }
    function find(callback) {
      let path = this;
      do {
        if (callback(path))
          return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = t2.VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path) => {
        const ancestry = [];
        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop:
        for (let i = 0; i < minDepth; i++) {
          const shouldMatch = first[i];
          for (const ancestry of ancestries) {
            if (ancestry[i] !== shouldMatch) {
              break depthLoop;
            }
          }
          lastCommonIndex = i;
          lastCommon = shouldMatch;
        }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path = this;
      const paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      while (path) {
        for (const type of candidateTypes) {
          if (path.node.type === type)
            return true;
        }
        path = path.parentPath;
      }
      return false;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var t2 = require_lib7();
    function _default(node) {
      if (!this.isReferenced())
        return;
      const binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }
      if (node.name === "undefined") {
        return t2.voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return t2.numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name) {
      const types = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path, name);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => testConstantViolations.indexOf(path2) < 0);
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations = constantViolations.concat(functionConstantViolations);
        for (const violation of constantViolations) {
          types.push(violation.getTypeAnnotation());
        }
      }
      if (!types.length) {
        return;
      }
      if (t2.isTSTypeAnnotation(types[0]) && t2.createTSUnionType) {
        return t2.createTSUnionType(types);
      }
      if (t2.createFlowUnionType) {
        return t2.createFlowUnionType(types);
      }
      return t2.createUnionTypeAnnotation(types);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown")
          functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path) {
      const operator = path.node.operator;
      const right = path.get("right").resolve();
      const left = path.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name
      })) {
        target = right;
      } else if (right.isIdentifier({
        name
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (t2.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return t2.numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==")
        return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath)
        return;
      if (!typeofPath.get("argument").isIdentifier({
        name
      }))
        return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral())
        return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string")
        return;
      return t2.createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name) {
      let parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name) !== binding)
            return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name) {
      const ifStatement = getParentConditionalPath(binding, path, name);
      if (!ifStatement)
        return;
      const test = ifStatement.get("test");
      const paths = [test];
      const types = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name, path2);
          if (type)
            types.push(type);
        }
      }
      if (types.length) {
        if (t2.isTSTypeAnnotation(types[0]) && t2.createTSUnionType) {
          return {
            typeAnnotation: t2.createTSUnionType(types),
            ifStatement
          };
        }
        if (t2.createFlowUnionType) {
          return {
            typeAnnotation: t2.createFlowUnionType(types),
            ifStatement
          };
        }
        return {
          typeAnnotation: t2.createUnionTypeAnnotation(types),
          ifStatement
        };
      }
      return getConditionalAnnotation(ifStatement, name);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.NewExpression = NewExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.UnaryExpression = UnaryExpression;
    exports2.BinaryExpression = BinaryExpression;
    exports2.LogicalExpression = LogicalExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.StringLiteral = StringLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.NullLiteral = NullLiteral;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.ObjectExpression = ObjectExpression;
    exports2.ArrayExpression = ArrayExpression;
    exports2.RestElement = RestElement;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = Func;
    exports2.CallExpression = CallExpression;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    var t2 = require_lib7();
    var _infererReference = require_inferer_reference();
    function VariableDeclarator() {
      var _type;
      const id = this.get("id");
      if (!id.isIdentifier())
        return;
      const init = this.get("init");
      let type = init.getTypeAnnotation();
      if (((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation") {
        if (init.isCallExpression() && init.get("callee").isIdentifier({
          name: "Array"
        }) && !init.scope.hasBinding("Array", true)) {
          type = ArrayExpression();
        }
      }
      return type;
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function NewExpression(node) {
      if (this.get("callee").isIdentifier()) {
        return t2.genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return t2.stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      const operator = node.operator;
      if (operator === "void") {
        return t2.voidTypeAnnotation();
      } else if (t2.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t2.numberTypeAnnotation();
      } else if (t2.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t2.stringTypeAnnotation();
      } else if (t2.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t2.booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      const operator = node.operator;
      if (t2.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t2.numberTypeAnnotation();
      } else if (t2.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t2.booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return t2.numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return t2.stringTypeAnnotation();
        }
        return t2.unionTypeAnnotation([t2.stringTypeAnnotation(), t2.numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      if (t2.isTSTypeAnnotation(argumentTypes[0]) && t2.createTSUnionType) {
        return t2.createTSUnionType(argumentTypes);
      }
      if (t2.createFlowUnionType) {
        return t2.createFlowUnionType(argumentTypes);
      }
      return t2.createUnionTypeAnnotation(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      if (t2.isTSTypeAnnotation(argumentTypes[0]) && t2.createTSUnionType) {
        return t2.createTSUnionType(argumentTypes);
      }
      if (t2.createFlowUnionType) {
        return t2.createFlowUnionType(argumentTypes);
      }
      return t2.createUnionTypeAnnotation(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      const operator = node.operator;
      if (operator === "++" || operator === "--") {
        return t2.numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return t2.stringTypeAnnotation();
    }
    function NumericLiteral() {
      return t2.numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return t2.booleanTypeAnnotation();
    }
    function NullLiteral() {
      return t2.nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return t2.genericTypeAnnotation(t2.identifier("RegExp"));
    }
    function ObjectExpression() {
      return t2.genericTypeAnnotation(t2.identifier("Object"));
    }
    function ArrayExpression() {
      return t2.genericTypeAnnotation(t2.identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return t2.genericTypeAnnotation(t2.identifier("Function"));
    }
    var isArrayFrom = t2.buildMatchMemberExpression("Array.from");
    var isObjectKeys = t2.buildMatchMemberExpression("Object.keys");
    var isObjectValues = t2.buildMatchMemberExpression("Object.values");
    var isObjectEntries = t2.buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return t2.arrayTypeAnnotation(t2.stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee)) {
        return t2.arrayTypeAnnotation(t2.anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return t2.arrayTypeAnnotation(t2.tupleTypeAnnotation([t2.stringTypeAnnotation(), t2.anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        if (callee.is("async")) {
          if (callee.is("generator")) {
            return t2.genericTypeAnnotation(t2.identifier("AsyncIterator"));
          } else {
            return t2.genericTypeAnnotation(t2.identifier("Promise"));
          }
        } else {
          if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.isGenericType = isGenericType;
    var inferers = require_inferers();
    var t2 = require_lib7();
    function getTypeAnnotation() {
      if (this.typeAnnotation)
        return this.typeAnnotation;
      let type = this._getTypeAnnotation() || t2.anyTypeAnnotation();
      if (t2.isTypeAnnotation(type))
        type = type.typeAnnotation;
      return this.typeAnnotation = type;
    }
    var typeAnnotationInferringNodes = new WeakSet();
    function _getTypeAnnotation() {
      const node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return t2.stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return t2.anyTypeAnnotation();
          }
          return t2.voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node)) {
        return;
      }
      typeAnnotationInferringNodes.add(node);
      try {
        var _inferer;
        let inferer = inferers[node.type];
        if (inferer) {
          return inferer.call(this, node);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return t2.isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return t2.isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return t2.isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return t2.isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return t2.isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return t2.isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return t2.isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name) {
      const type = this.getTypeAnnotation();
      if (t2.isAnyTypeAnnotation(type))
        return true;
      if (t2.isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (t2.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!t2.isAnyTypeAnnotation(left) && t2.isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      return t2.isGenericTypeAnnotation(type) && t2.isIdentifier(type.id, {
        name: genericName
      });
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/js-tokens-npm-4.0.0-0ac852e9e2-8a95213a5a.zip/node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/js-tokens-npm-4.0.0-0ac852e9e2-8a95213a5a.zip/node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/escape-string-regexp-npm-1.0.5-3284de402f-6092fda75c.zip/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/escape-string-regexp-npm-1.0.5-3284de402f-6092fda75c.zip/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-name-npm-1.1.3-728b7b5d39-09c5d3e33d.zip/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-name-npm-1.1.3-728b7b5d39-09c5d3e33d.zip/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t2 = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t2, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t2];
        case 3:
          return [p, q, v];
        case 4:
          return [t2, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/route.js
var require_route = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/color-convert-npm-1.9.3-1fe690075e-fd7a64a17c.zip/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/ansi-styles-npm-3.2.1-8cb8107983-d85ade01c1.zip/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/ansi-styles-npm-3.2.1-8cb8107983-d85ade01c1.zip/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/has-flag-npm-3.0.0-16ac11fe05-4a15638b45.zip/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/has-flag-npm-3.0.0-16ac11fe05-4a15638b45.zip/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/supports-color-npm-5.5.0-183ac537bc-95f6f4ba5a.zip/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/supports-color-npm-5.5.0-183ac537bc-95f6f4ba5a.zip/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/chalk-npm-2.4.2-3ea16dd91e-ec3661d38f.zip/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/chalk-npm-2.4.2-3ea16dd91e-ec3661d38f.zip/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape2(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape2(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/chalk-npm-2.4.2-3ea16dd91e-ec3661d38f.zip/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/chalk-npm-2.4.2-3ea16dd91e-ec3661d38f.zip/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template2 = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = new Set(["gray"]);
    var styles = Object.create(null);
    function applyOptions(obj2, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj2.level = options.level === void 0 ? scLevel : options.level;
      obj2.enabled = "enabled" in options ? options.enabled : obj2.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template2(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-highlight-npm-7.14.5-4a18106cbc-4e4b22fb88.zip/node_modules/@babel/highlight/lib/index.js
var require_lib10 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-highlight-npm-7.14.5-4a18106cbc-4e4b22fb88.zip/node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shouldHighlight = shouldHighlight;
    exports2.getChalk = getChalk;
    exports2.default = highlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib6();
    var _chalk = require_chalk();
    var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (shouldHighlight(options)) {
        const chalk = getChalk(options);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-code-frame-npm-7.14.5-4dc9115988-0adbe4f8d9.zip/node_modules/@babel/code-frame/lib/index.js
var require_lib11 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-code-frame-npm-7.14.5-4dc9115988-0adbe4f8d9.zip/node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = require_lib10();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-hoist-variables-npm-7.14.5-e24b531b4d-35af58eebf.zip/node_modules/@babel/helper-hoist-variables/lib/index.js
var require_lib12 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-hoist-variables-npm-7.14.5-e24b531b4d-35af58eebf.zip/node_modules/@babel/helper-hoist-variables/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = hoistVariables;
    var t2 = require_lib7();
    var visitor = {
      Scope(path, state) {
        if (state.kind === "let")
          path.skip();
      },
      FunctionParent(path) {
        path.skip();
      },
      VariableDeclaration(path, state) {
        if (state.kind && path.node.kind !== state.kind)
          return;
        const nodes = [];
        const declarations = path.get("declarations");
        let firstId;
        for (const declar of declarations) {
          firstId = declar.node.id;
          if (declar.node.init) {
            nodes.push(t2.expressionStatement(t2.assignmentExpression("=", declar.node.id, declar.node.init)));
          }
          for (const name of Object.keys(declar.getBindingIdentifiers())) {
            state.emit(t2.identifier(name), name, declar.node.init !== null);
          }
        }
        if (path.parentPath.isFor({
          left: path.node
        })) {
          path.replaceWith(firstId);
        } else {
          path.replaceWithMultiple(nodes);
        }
      }
    };
    function hoistVariables(path, emit, kind = "var") {
      path.traverse(visitor, {
        kind,
        emit
      });
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    exports2.replaceWith = replaceWith;
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    var _codeFrame = require_lib11();
    var _index = require_lib16();
    var _index2 = require_path2();
    var _cache = require_cache();
    var _parser = require_lib();
    var t2 = require_lib7();
    var _helperHoistVariables = require_lib12();
    function replaceWithMultiple(nodes) {
      var _pathCache$get;
      this.resync();
      nodes = this._verifyNodeList(nodes);
      t2.inheritLeadingComments(nodes[0], this.node);
      t2.inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      this.resync();
      try {
        replacement = `(${replacement})`;
        replacement = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      replacement = replacement.program.body[0].expression;
      _index.default.removeProperties(replacement);
      return this.replaceWith(replacement);
    }
    function replaceWith(replacement) {
      this.resync();
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      if (replacement instanceof _index2.default) {
        replacement = replacement.node;
      }
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !t2.isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && t2.isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = t2.expressionStatement(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && t2.isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        t2.inheritsComments(replacement, oldNode);
        t2.removeComments(oldNode);
      }
      this._replaceWith(replacement);
      this.type = replacement.type;
      this.setScope();
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _pathCache$get2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        t2.validate(this.parent, this.key, [node]);
      } else {
        t2.validate(this.parent, this.key, node);
      }
      this.debug(`Replace with ${node == null ? void 0 : node.type}`);
      (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      this.resync();
      const toSequenceExpression = t2.toSequenceExpression(nodes, this.scope);
      if (toSequenceExpression) {
        return this.replaceWith(toSequenceExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
      const isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
      const container = t2.arrowFunctionExpression([], t2.blockStatement(nodes));
      this.replaceWith(t2.callExpression(container, []));
      const callee = this.get("callee");
      (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
        this.scope.push({
          id
        });
      }, "var");
      const completionRecords = this.get("callee").getCompletionRecords();
      for (const path of completionRecords) {
        if (!path.isExpressionStatement())
          continue;
        const loop = path.findParent((path2) => path2.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", t2.returnStatement(t2.cloneNode(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = t2.identifier(uid.name);
          }
          path.get("expression").replaceWith(t2.assignmentExpression("=", t2.cloneNode(uid), path.node.expression));
        } else {
          path.replaceWith(t2.returnStatement(path.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", t2.FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", t2.FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(t2.awaitExpression(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(t2.yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function replaceInline(nodes) {
      this.resync();
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = this._verifyNodeList(nodes);
          const paths = this._containerInsertAfter(nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluateTruthy = evaluateTruthy;
    exports2.evaluate = evaluate;
    var VALID_CALLEES = ["String", "Number", "Math"];
    var INVALID_METHODS = ["random"];
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident)
        return !!res.value;
    }
    function deopt(path, state) {
      if (!state.confident)
        return;
      state.deoptPath = path;
      state.confident = false;
    }
    function evaluateCached(path, state) {
      const {
        node
      } = path;
      const {
        seen
      } = state;
      if (seen.has(node)) {
        const existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen.set(node, item);
        const val = _evaluate(path, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path, state) {
      if (!state.confident)
        return;
      if (path.isSequenceExpression()) {
        const exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
      }
      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        const object = path.get("tag.object");
        const {
          node: {
            name
          }
        } = object;
        const property = path.get("tag.property");
        if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
      }
      if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get("test"), state);
        if (!state.confident)
          return;
        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: path.node
      })) {
        const property = path.get("property");
        const object = path.get("object");
        if (object.isLiteral() && property.isIdentifier()) {
          const value = object.node.value;
          const type = typeof value;
          if (type === "number" || type === "string") {
            return value[property.node.name];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        if (binding && binding.constantViolations.length > 0) {
          return deopt(binding.path, state);
        }
        if (binding && path.node.start < binding.path.node.end) {
          return deopt(binding.path, state);
        }
        if (binding != null && binding.hasValue) {
          return binding.value;
        } else {
          if (path.node.name === "undefined") {
            return binding ? deopt(binding.path, state) : void 0;
          } else if (path.node.name === "Infinity") {
            return binding ? deopt(binding.path, state) : Infinity;
          } else if (path.node.name === "NaN") {
            return binding ? deopt(binding.path, state) : NaN;
          }
          const resolved = path.resolve();
          if (resolved === path) {
            return deopt(path, state);
          } else {
            return evaluateCached(resolved, state);
          }
        }
      }
      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (path.node.operator === "void") {
          return void 0;
        }
        const argument = path.get("argument");
        if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident)
          return;
        switch (path.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            return deopt(elemValue.deopt, state);
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        const obj2 = {};
        const props = path.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            return deopt(prop, state);
          }
          const keyPath = prop.get("key");
          let key = keyPath;
          if (prop.node.computed) {
            key = key.evaluate();
            if (!key.confident) {
              return deopt(key.deopt, state);
            }
            key = key.value;
          } else if (key.isIdentifier()) {
            key = key.node.name;
          } else {
            key = key.node.value;
          }
          const valuePath = prop.get("value");
          let value = valuePath.evaluate();
          if (!value.confident) {
            return deopt(value.deopt, state);
          }
          value = value.value;
          obj2[key] = value;
        }
        return obj2;
      }
      if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path.get("right"), state);
        const rightConfident = state.confident;
        switch (path.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident)
              return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident)
              return;
            return left && right;
        }
      }
      if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get("left"), state);
        if (!state.confident)
          return;
        const right = evaluateCached(path.get("right"), state);
        if (!state.confident)
          return;
        switch (path.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path.isCallExpression()) {
        const callee = path.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object = callee.get("object");
          const property = callee.get("property");
          if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {
            context = global[object.node.name];
            func = context[property.node.name];
          }
          if (object.isLiteral() && property.isIdentifier()) {
            const type = typeof object.node.value;
            if (type === "string" || type === "number") {
              context = object.node.value;
              func = context[property.node.name];
            }
          }
        }
        if (func) {
          const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident)
            return;
          return func.apply(context, args);
        }
      }
      deopt(path, state);
    }
    function evaluateQuasis(path, quasis, state, raw = false) {
      let str = "";
      let i = 0;
      const exprs = path.get("expressions");
      for (const elem of quasis) {
        if (!state.confident)
          break;
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr)
          str += String(evaluateCached(expr, state));
      }
      if (!state.confident)
        return;
      return str;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: new Map()
      };
      let value = evaluateCached(this, state);
      if (!state.confident)
        value = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value
      };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-get-function-arity-npm-7.14.5-e6a90e49c5-a60779918b.zip/node_modules/@babel/helper-get-function-arity/lib/index.js
var require_lib13 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-get-function-arity-npm-7.14.5-e6a90e49c5-a60779918b.zip/node_modules/@babel/helper-get-function-arity/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var t2 = require_lib7();
    function _default(node) {
      const params = node.params;
      for (let i = 0; i < params.length; i++) {
        const param = params[i];
        if (t2.isAssignmentPattern(param) || t2.isRestElement(param)) {
          return i;
        }
      }
      return params.length;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/formatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.program = exports2.expression = exports2.statement = exports2.statements = exports2.smart = void 0;
    var t2 = require_lib7();
    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {
        },
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    exports2.smart = smart;
    var statements = makeStatementFormatter((body) => body);
    exports2.statements = statements;
    var statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    exports2.statement = statement;
    var expression = {
      code: (str) => `(
${str}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: ({
        program: program3
      }) => {
        const [stmt] = program3.body;
        t2.assertExpressionStatement(stmt);
        return stmt.expression;
      }
    };
    exports2.expression = expression;
    var program2 = {
      code: (str) => str,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
    exports2.program = program2;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.merge = merge;
    exports2.validate = validate;
    exports2.normalizeReplacements = normalizeReplacements;
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function merge(a, b) {
      const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      const _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/parse.js
var require_parse6 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = parseAndBuildMetadata;
    var t2 = require_lib7();
    var _parser = require_lib();
    var _codeFrame = require_lib11();
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code, opts) {
      const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts;
      const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
      t2.removePropertiesDeep(ast, {
        preserveComments
      });
      formatter.validate(ast);
      const syntactic = {
        placeholders: [],
        placeholderNames: new Set()
      };
      const legacy = {
        placeholders: [],
        placeholderNames: new Set()
      };
      const isLegacyRef = {
        value: void 0
      };
      t2.traverse(ast, placeholderVisitorHandler, {
        syntactic,
        legacy,
        isLegacyRef,
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      });
      return Object.assign({
        ast
      }, isLegacyRef.value ? legacy : syntactic);
    }
    function placeholderVisitorHandler(node, ancestors, state) {
      var _state$placeholderWhi;
      let name;
      if (t2.isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        } else {
          name = node.name.name;
          state.isLegacyRef.value = false;
        }
      } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
        return;
      } else if (t2.isIdentifier(node) || t2.isJSXIdentifier(node)) {
        name = node.name;
        state.isLegacyRef.value = true;
      } else if (t2.isStringLiteral(node)) {
        name = node.value;
        state.isLegacyRef.value = true;
      } else {
        return;
      }
      if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
        return;
      }
      ancestors = ancestors.slice();
      const {
        node: parent,
        key
      } = ancestors[ancestors.length - 1];
      let type;
      if (t2.isStringLiteral(node) || t2.isPlaceholder(node, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (t2.isNewExpression(parent) && key === "arguments" || t2.isCallExpression(parent) && key === "arguments" || t2.isFunction(parent) && key === "params") {
        type = "param";
      } else if (t2.isExpressionStatement(parent) && !t2.isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (t2.isStatement(node) && t2.isPlaceholder(node)) {
        type = "statement";
      } else {
        type = "other";
      }
      const {
        placeholders,
        placeholderNames
      } = state.isLegacyRef.value ? state.legacy : state.syntactic;
      placeholders.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name)
      });
      placeholderNames.add(name);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        const {
          key: key2,
          index: index2
        } = ancestors[i];
        if (index2 === void 0) {
          parent = parent[key2];
        } else {
          parent = parent[key2][index2];
        }
      }
      const {
        key,
        index
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key,
        index
      };
    }
    function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
      const plugins = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
      }
      parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/populate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = populatePlaceholders;
    var t2 = require_lib7();
    function populatePlaceholders(metadata, replacements) {
      const ast = t2.cloneNode(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach((placeholder) => {
          if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        });
        Object.keys(replacements).forEach((key) => {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error(`Unknown substitution "${key}" given`);
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
          e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
          throw e;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map((node) => t2.cloneNode(node));
        } else if (typeof replacement === "object") {
          replacement = t2.cloneNode(replacement);
        }
      }
      const {
        parent,
        key,
        index
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = t2.stringLiteral(replacement);
        }
        if (!replacement || !t2.isStringLiteral(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index === void 0) {
          if (!replacement) {
            replacement = t2.emptyStatement();
          } else if (Array.isArray(replacement)) {
            replacement = t2.blockStatement(replacement);
          } else if (typeof replacement === "string") {
            replacement = t2.expressionStatement(t2.identifier(replacement));
          } else if (!t2.isStatement(replacement)) {
            replacement = t2.expressionStatement(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = t2.identifier(replacement);
            }
            if (!t2.isStatement(replacement)) {
              replacement = t2.expressionStatement(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = t2.identifier(replacement);
        }
        if (index === void 0)
          throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = t2.identifier(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      if (index === void 0) {
        t2.validate(parent, key, replacement);
        parent[key] = replacement;
      } else {
        const items = parent[key].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index, 1);
          } else if (Array.isArray(replacement)) {
            items.splice(index, 1, ...replacement);
          } else {
            items[index] = replacement;
          }
        } else {
          items[index] = replacement;
        }
        t2.validate(parent, key, items);
        parent[key] = items;
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/string.js
var require_string3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = stringTemplate;
    var _options = require_options();
    var _parse = require_parse6();
    var _populate = require_populate();
    function stringTemplate(formatter, code, opts) {
      code = formatter.code(code);
      let metadata;
      return (arg) => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata)
          metadata = (0, _parse.default)(formatter, code, opts);
        return formatter.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = literalTemplate;
    var _options = require_options();
    var _parse = require_parse6();
    var _populate = require_populate();
    function literalTemplate(formatter, tpl, opts) {
      const {
        metadata,
        names
      } = buildLiteralData(formatter, tpl, opts);
      return (arg) => {
        const defaultReplacements = {};
        arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
          const replacements = (0, _options.normalizeReplacements)(arg2);
          if (replacements) {
            Object.keys(replacements).forEach((key) => {
              if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      let names;
      let nameSet;
      let metadata;
      let prefix = "";
      do {
        prefix += "$";
        const result = buildTemplateCode(tpl, prefix);
        names = result.names;
        nameSet = new Set(names);
        metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
          parser: opts.parser,
          placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
          placeholderPattern: opts.placeholderPattern,
          preserveComments: opts.preserveComments,
          syntacticPlaceholders: opts.syntacticPlaceholders
        });
      } while (metadata.placeholders.some((placeholder) => placeholder.isDuplicate && nameSet.has(placeholder.name)));
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      const names = [];
      let code = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix}${i - 1}`;
        names.push(value);
        code += value + tpl[i];
      }
      return {
        names,
        code
      };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/builder.js
var require_builder2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTemplateBuilder;
    var _options = require_options();
    var _string = require_string3();
    var _literal = require_literal();
    var NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      const templateFnCache = new WeakMap();
      const templateAstCache = new WeakMap();
      const cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1)
            throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0)
            throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1)
              throw new Error("Unexpected extra params.");
            return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += `
    =============
${rootStack}`;
          throw err;
        }
      };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/index.js
var require_lib14 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-template-npm-7.14.5-98e7aff771-4939199c5b.zip/node_modules/@babel/template/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.program = exports2.expression = exports2.statements = exports2.statement = exports2.smart = void 0;
    var formatters = require_formatters();
    var _builder = require_builder2();
    var smart = (0, _builder.default)(formatters.smart);
    exports2.smart = smart;
    var statement = (0, _builder.default)(formatters.statement);
    exports2.statement = statement;
    var statements = (0, _builder.default)(formatters.statements);
    exports2.statements = statements;
    var expression = (0, _builder.default)(formatters.expression);
    exports2.expression = expression;
    var program2 = (0, _builder.default)(formatters.program);
    exports2.program = program2;
    var _default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program: program2,
      ast: smart.ast
    });
    exports2.default = _default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-function-name-npm-7.14.5-5fe13634f6-fd8ffa82f7.zip/node_modules/@babel/helper-function-name/lib/index.js
var require_lib15 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-helper-function-name-npm-7.14.5-5fe13634f6-fd8ffa82f7.zip/node_modules/@babel/helper-function-name/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var _helperGetFunctionArity = require_lib13();
    var _template = require_lib14();
    var t2 = require_lib7();
    var buildPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
    var buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
    var visitor = {
      "ReferencedIdentifier|BindingIdentifier"(path, state) {
        if (path.node.name !== state.name)
          return;
        const localDeclar = path.scope.getBindingIdentifier(state.name);
        if (localDeclar !== state.outerDeclar)
          return;
        state.selfReference = true;
        path.stop();
      }
    };
    function getNameFromLiteralId(id) {
      if (t2.isNullLiteral(id)) {
        return "null";
      }
      if (t2.isRegExpLiteral(id)) {
        return `_${id.pattern}_${id.flags}`;
      }
      if (t2.isTemplateLiteral(id)) {
        return id.quasis.map((quasi) => quasi.value.raw).join("");
      }
      if (id.value !== void 0) {
        return id.value + "";
      }
      return "";
    }
    function wrap(state, method, id, scope) {
      if (state.selfReference) {
        if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
          scope.rename(id.name);
        } else {
          if (!t2.isFunction(method))
            return;
          let build = buildPropertyMethodAssignmentWrapper;
          if (method.generator) {
            build = buildGeneratorPropertyMethodAssignmentWrapper;
          }
          const template2 = build({
            FUNCTION: method,
            FUNCTION_ID: id,
            FUNCTION_KEY: scope.generateUidIdentifier(id.name)
          }).expression;
          const params = template2.callee.body.body[0].params;
          for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {
            params.push(scope.generateUidIdentifier("x"));
          }
          return template2;
        }
      }
      method.id = id;
      scope.getProgramParent().references[id.name] = true;
    }
    function visit(node, name, scope) {
      const state = {
        selfAssignment: false,
        selfReference: false,
        outerDeclar: scope.getBindingIdentifier(name),
        references: [],
        name
      };
      const binding = scope.getOwnBinding(name);
      if (binding) {
        if (binding.kind === "param") {
          state.selfReference = true;
        } else {
        }
      } else if (state.outerDeclar || scope.hasGlobal(name)) {
        scope.traverse(node, visitor, state);
      }
      return state;
    }
    function _default({
      node,
      parent,
      scope,
      id
    }, localBinding = false) {
      if (node.id)
        return;
      if ((t2.isObjectProperty(parent) || t2.isObjectMethod(parent, {
        kind: "method"
      })) && (!parent.computed || t2.isLiteral(parent.key))) {
        id = parent.key;
      } else if (t2.isVariableDeclarator(parent)) {
        id = parent.id;
        if (t2.isIdentifier(id) && !localBinding) {
          const binding = scope.parent.getBinding(id.name);
          if (binding && binding.constant && scope.getBinding(id.name) === binding) {
            node.id = t2.cloneNode(id);
            node.id[t2.NOT_LOCAL_BINDING] = true;
            return;
          }
        }
      } else if (t2.isAssignmentExpression(parent, {
        operator: "="
      })) {
        id = parent.left;
      } else if (!id) {
        return;
      }
      let name;
      if (id && t2.isLiteral(id)) {
        name = getNameFromLiteralId(id);
      } else if (id && t2.isIdentifier(id)) {
        name = id.name;
      }
      if (name === void 0) {
        return;
      }
      name = t2.toBindingIdentifierName(name);
      id = t2.identifier(name);
      id[t2.NOT_LOCAL_BINDING] = true;
      const state = visit(node, name, scope);
      return wrap(state, node, id, scope) || node;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toComputedKey = toComputedKey;
    exports2.ensureBlock = ensureBlock;
    exports2.arrowFunctionToShadowed = arrowFunctionToShadowed;
    exports2.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    exports2.arrowFunctionToExpression = arrowFunctionToExpression;
    var t2 = require_lib7();
    var _helperFunctionName = require_lib15();
    function toComputedKey() {
      let key;
      if (this.isMemberExpression()) {
        key = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (t2.isIdentifier(key))
          key = t2.stringLiteral(key.name);
      }
      return key;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key = "argument";
          statements.push(t2.returnStatement(body.node));
        } else {
          key = "expression";
          statements.push(t2.expressionStatement(body.node));
        }
      }
      this.node.body = t2.blockStatement(statements);
      const parentPath = this.get(stringPath);
      body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    function arrowFunctionToShadowed() {
      if (!this.isArrowFunctionExpression())
        return;
      this.arrowFunctionToExpression();
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      specCompliant = false,
      noNewArrows = !specCompliant
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
      this.ensureBlock();
      this.node.type = "FunctionExpression";
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          this.parentPath.scope.push({
            id: checkBinding,
            init: t2.objectExpression([])
          });
        }
        this.get("body").unshiftContainer("body", t2.expressionStatement(t2.callExpression(this.hub.addHelper("newArrowCheck"), [t2.thisExpression(), checkBinding ? t2.identifier(checkBinding.name) : t2.identifier(thisBinding)])));
        this.replaceWith(t2.callExpression(t2.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t2.identifier("bind")), [checkBinding ? t2.identifier(checkBinding.name) : t2.thisExpression()]));
      }
    }
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {
      const thisEnvFn = fnPath.findParent((p) => {
        return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
          static: false
        });
      });
      const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === "constructor";
      if (thisEnvFn.isClassProperty()) {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse({
          Function(child) {
            if (child.isArrowFunctionExpression())
              return;
            child.skip();
          },
          ClassProperty(child) {
            child.skip();
          },
          CallExpression(child) {
            if (!child.get("callee").isSuper())
              return;
            allSuperCalls.push(child);
          }
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = t2.identifier(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => t2.identifier("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return t2.conditionalExpression(t2.binaryExpression("===", t2.unaryExpression("typeof", args()), t2.stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = t2.identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => t2.metaProperty(t2.identifier("new"), t2.identifier("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = t2.identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key = superProp.node.computed ? "" : superProp.get("property").node.name;
          const isAssignment = superProp.parentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superProp.parentPath.isCallExpression({
            callee: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value = superProp.parentPath.node.right;
            args.push(value);
          }
          const call = t2.callExpression(t2.identifier(superBinding), args);
          if (isCall) {
            superProp.parentPath.unshiftContainer("arguments", t2.thisExpression());
            superProp.replaceWith(t2.memberExpression(call, t2.identifier("call")));
            thisPaths.push(superProp.parentPath.get("arguments.0"));
          } else if (isAssignment) {
            superProp.parentPath.replaceWith(call);
          } else {
            superProp.replaceWith(call);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? t2.jsxIdentifier(thisBinding) : t2.identifier(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows)
            thisBinding = null;
        }
      }
      return thisBinding;
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        assignmentPath.node.operator = "=";
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          assignmentPath.get("left").replaceWith(t2.memberExpression(superProp.node.object, t2.assignmentExpression("=", tmp, superProp.node.property), true));
          assignmentPath.get("right").replaceWith(t2.binaryExpression(op, t2.memberExpression(superProp.node.object, t2.identifier(tmp.name), true), value));
        } else {
          assignmentPath.get("left").replaceWith(t2.memberExpression(superProp.node.object, superProp.node.property));
          assignmentPath.get("right").replaceWith(t2.binaryExpression(op, t2.memberExpression(superProp.node.object, t2.identifier(superProp.node.property.name)), value));
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [t2.assignmentExpression("=", tmp, t2.memberExpression(superProp.node.object, computedKey ? t2.assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t2.assignmentExpression("=", t2.memberExpression(superProp.node.object, computedKey ? t2.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t2.binaryExpression("+", t2.identifier(tmp.name), t2.numericLiteral(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(t2.identifier(tmp.name));
        }
        updateExpr.replaceWith(t2.sequenceExpression(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn))
          return t2.thisExpression();
        const supers = new WeakSet();
        thisEnvFn.traverse({
          Function(child) {
            if (child.isArrowFunctionExpression())
              return;
            child.skip();
          },
          ClassProperty(child) {
            child.skip();
          },
          CallExpression(child) {
            if (!child.get("callee").isSuper())
              return;
            if (supers.has(child.node))
              return;
            supers.add(child.node);
            child.replaceWithMultiple([child.node, t2.assignmentExpression("=", t2.identifier(thisBinding), t2.identifier("this"))]);
          }
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return t2.arrowFunctionExpression([t2.restElement(argsBinding)], t2.callExpression(t2.super(), [t2.spreadElement(t2.identifier(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = t2.memberExpression(t2.super(), t2.identifier(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = t2.memberExpression(t2.super(), t2.identifier(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = t2.assignmentExpression("=", fnBody, t2.identifier(valueIdent.name));
        }
        return t2.arrowFunctionExpression(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init) {
      const cacheKey = "binding:" + key;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse({
        ClassProperty(child) {
          child.skip();
        },
        Function(child) {
          if (child.isArrowFunctionExpression())
            return;
          child.skip();
        },
        ThisExpression(child) {
          thisPaths.push(child);
        },
        JSXIdentifier(child) {
          if (child.node.name !== "this")
            return;
          if (!child.parentPath.isJSXMemberExpression({
            object: child.node
          }) && !child.parentPath.isJSXOpeningElement({
            name: child.node
          })) {
            return;
          }
          thisPaths.push(child);
        },
        CallExpression(child) {
          if (child.get("callee").isSuper())
            superCalls.push(child);
        },
        MemberExpression(child) {
          if (child.get("object").isSuper())
            superProps.push(child);
        },
        ReferencedIdentifier(child) {
          if (child.node.name !== "arguments")
            return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments")) {
              curr.rename("arguments");
              return;
            }
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
              break;
            }
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        },
        MetaProperty(child) {
          if (!child.get("meta").isIdentifier({
            name: "new"
          }))
            return;
          if (!child.get("property").isIdentifier({
            name: "target"
          }))
            return;
          newTargetPaths.push(child);
        }
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.matchesPattern = matchesPattern;
    exports2.has = has;
    exports2.isStatic = isStatic;
    exports2.isnt = isnt;
    exports2.equals = equals;
    exports2.isNodeType = isNodeType;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.referencesImport = referencesImport;
    exports2.getSource = getSource;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
    exports2.resolve = resolve;
    exports2._resolve = _resolve;
    exports2.isConstantExpression = isConstantExpression;
    exports2.isInStrictMode = isInStrictMode;
    exports2.is = void 0;
    var t2 = require_lib7();
    function matchesPattern(pattern, allowPartial) {
      return t2.matchesPattern(this.node, pattern, allowPartial);
    }
    function has(key) {
      const val = this.node && this.node[key];
      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    var is = has;
    exports2.is = is;
    function isnt(key) {
      return !this.has(key);
    }
    function equals(key, value) {
      return this.node[key] === value;
    }
    function isNodeType(type) {
      return t2.isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return t2.isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return t2.isExpression(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path = this;
      let first = true;
      do {
        const container = path.container;
        if (path.isFunction() && !first) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || t2.isBlockStatement(this.container)) {
        return false;
      } else {
        return t2.STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t2.isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module")
        return false;
      const path = binding.path;
      const parent = path.parentPath;
      if (!parent.isImportDeclaration())
        return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName)
          return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && t2.isIdentifier(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node = this.node;
      if (node.end) {
        const code = this.hub.getCode();
        if (code)
          return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    function _guessExecutionStatusRelativeTo(target) {
      const funcParent = {
        this: getOuterFunction(this),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
      }
      const paths = {
        target: target.getAncestry(),
        this: this.getAncestry()
      };
      if (paths.target.indexOf(this) >= 0)
        return "after";
      if (paths.this.indexOf(target) >= 0)
        return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = t2.VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    var executionOrderCheckedNodes = new WeakSet();
    function _guessExecutionStatusRelativeToDifferentFunctions(target) {
      if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references)
        return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        if (childOfFunction)
          continue;
        if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
          return "unknown";
        }
        if (executionOrderCheckedNodes.has(path.node))
          continue;
        executionOrderCheckedNodes.add(path.node);
        const status = this._guessExecutionStatusRelativeTo(path);
        executionOrderCheckedNodes.delete(path.node);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function resolve(dangerous, resolved) {
      return this._resolve(dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      if (resolved && resolved.indexOf(this) >= 0)
        return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding)
          return;
        if (!binding.constant)
          return;
        if (binding.kind === "module")
          return;
        if (binding.path !== this) {
          const ret2 = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret2.node))
            return;
          return ret2;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!t2.isLiteral(targetKey))
          return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty())
              continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match)
              return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem)
            return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding)
          return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path) => {
        if (path.isProgram({
          sourceType: "module"
        }))
          return true;
        if (path.isClass())
          return true;
        if (!path.isProgram() && !path.isFunction())
          return false;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        const body = path.isFunction() ? path.node.body : path.node;
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.call = call;
    exports2._call = _call;
    exports2.isBlacklisted = exports2.isDenylisted = isDenylisted;
    exports2.visit = visit;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.setScope = setScope;
    exports2.setContext = setContext;
    exports2.resync = resync;
    exports2._resyncParent = _resyncParent;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.setup = setup;
    exports2.setKey = setKey;
    exports2.requeue = requeue;
    exports2._getQueueContexts = _getQueueContexts;
    var _index = require_lib16();
    var _index2 = require_path2();
    function call(key) {
      const opts = this.opts;
      this.debug(key);
      if (this.node) {
        if (this._call(opts[key]))
          return true;
      }
      if (this.node) {
        return this._call(opts[this.node.type] && opts[this.node.type][key]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns)
        return false;
      for (const fn of fns) {
        if (!fn)
          continue;
        const node = this.node;
        if (!node)
          return true;
        const ret2 = fn.call(this.state, this, this.state);
        if (ret2 && typeof ret2 === "object" && typeof ret2.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret2) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node)
          return true;
        if (this._traverseFlags > 0)
          return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist && denylist.indexOf(this.node.type) > -1;
    }
    function visit() {
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
        return false;
      }
      if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      this.debug("Recursing into...");
      _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      this.call("exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;
    }
    function setScope() {
      if (this.opts && this.opts.noScope)
        return;
      let path = this.parentPath;
      if (this.key === "key" && path.isMethod())
        path = path.parentPath;
      let target;
      while (path && !target) {
        if (path.opts && path.opts.noScope)
          return;
        target = path.scope;
        path = path.parentPath;
      }
      this.scope = this.getScope(target);
      if (this.scope)
        this.scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      this.setScope();
      return this;
    }
    function resync() {
      if (this.removed)
        return;
      this._resyncParent();
      this._resyncList();
      this._resyncKey();
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container)
        return;
      if (this.node === this.container[this.key])
        return;
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            return this.setKey(i);
          }
        }
      } else {
        for (const key of Object.keys(this.container)) {
          if (this.container[key] === this.node) {
            return this.setKey(key);
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList)
        return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer)
        return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        this._markRemoved();
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container, listKey, key) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      this.setKey(key);
    }
    function setKey(key) {
      var _this$node;
      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed)
        return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function _getQueueContexts() {
      let path = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path = path.parentPath;
        if (!path)
          break;
        contexts = path.contexts;
      }
      return contexts;
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hooks = void 0;
    var hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && (self2.key === "consequent" || self2.key === "alternate") || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
    exports2.hooks = hooks;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/removal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.remove = remove;
    exports2._removeFromScope = _removeFromScope;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._remove = _remove;
    exports2._markRemoved = _markRemoved;
    exports2._assertUnremoved = _assertUnremoved;
    var _removalHooks = require_removal_hooks();
    var _cache = require_cache();
    var _index = require_path2();
    function remove() {
      var _this$opts;
      this._assertUnremoved();
      this.resync();
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        this._removeFromScope();
      }
      if (this._callRemovalHooks()) {
        this._markRemoved();
        return;
      }
      this.shareCommentsWithSiblings();
      this._remove();
      this._markRemoved();
    }
    function _removeFromScope() {
      const bindings = this.getBindingIdentifiers();
      Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
    }
    function _callRemovalHooks() {
      for (const fn of _removalHooks.hooks) {
        if (fn(this, this.parentPath))
          return true;
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        this.updateSiblingKeys(this.key, -1);
      } else {
        this._replaceWith(null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent)
        _cache.path.get(this.parent).delete(this.node);
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var t2 = require_lib7();
    var referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && t2.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path.node.name === "this") {
          let scope = path.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope)
            state.breakOnScopePaths.push(scope.path);
        }
        const binding = path.scope.getBinding(path.node.name);
        if (!binding)
          return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path.node.name))
          return;
        state.bindings[path.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key of Object.keys(this.bindings)) {
          const binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path = this._getAttachmentPath();
        if (!path)
          return;
        let targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name))
              continue;
            const binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            }
          }
        }
        return path;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope)
          return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope)
              return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist)
                continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope)
          return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name))
            continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant)
            return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding)
          return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo)
          return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent())
          return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = t2.variableDeclarator(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t2.variableDeclaration("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = t2.jsxExpressionContainer(uid);
        }
        this.path.replaceWith(t2.cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports2.default = PathHoister;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/modification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.insertBefore = insertBefore;
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2.insertAfter = insertAfter;
    exports2.updateSiblingKeys = updateSiblingKeys;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.unshiftContainer = unshiftContainer;
    exports2.pushContainer = pushContainer;
    exports2.hoist = hoist;
    var _cache = require_cache();
    var _hoister = require_hoister();
    var _index = require_path2();
    var t2 = require_lib7();
    function insertBefore(nodes_) {
      this._assertUnremoved();
      const nodes = this._verifyNodeList(nodes_);
      const {
        parentPath
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node)
          nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertBefore(nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(t2.blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      this.updateSiblingKeys(from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        if (this.context && this.context.queue) {
          path.pushContext(this.context);
        }
      }
      const contexts = this._getQueueContexts();
      for (const path of paths) {
        path.setScope();
        path.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return this._containerInsert(this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return this._containerInsert(this.key + 1, nodes);
    }
    function insertAfter(nodes_) {
      this._assertUnremoved();
      const nodes = this._verifyNodeList(nodes_);
      const {
        parentPath
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node) => {
          return t2.isExpression(node) ? t2.expressionStatement(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) {
          const node = this.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            t2.assertExpression(node);
            this.replaceWith(t2.callExpression(t2.arrowFunctionExpression([], node), []));
            this.get("callee.body").insertAfter(nodes);
            return [this];
          }
          if (parentPath.isMethod({
            computed: true,
            key: node
          })) {
            scope = scope.parent;
          }
          const temp = scope.generateDeclaredUidIdentifier();
          nodes.unshift(t2.expressionStatement(t2.assignmentExpression("=", t2.cloneNode(temp), node)));
          nodes.push(t2.expressionStatement(t2.cloneNode(temp)));
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertAfter(nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(t2.blockStatement(shouldInsertCurrentNode ? [node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent)
        return;
      const paths = _cache.path.get(this.parent);
      for (const [, path] of paths) {
        if (path.key >= fromIndex) {
          path.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        let msg;
        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      this._assertUnremoved();
      nodes = this._verifyNodeList(nodes);
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return path._containerInsertBefore(nodes);
    }
    function pushContainer(listKey, nodes) {
      this._assertUnremoved();
      const verifiedNodes = this._verifyNodeList(nodes);
      const container = this.node[listKey];
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context);
      return path.replaceWithMultiple(verifiedNodes);
    }
    function hoist(scope = this.scope) {
      const hoister = new _hoister.default(this, scope);
      return hoister.run();
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/family.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOpposite = getOpposite;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getSibling = getSibling;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getNextSibling = getNextSibling;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.get = get;
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    var _index = require_path2();
    var t2 = require_lib7();
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path, records, context) {
      if (path)
        return records.concat(_getCompletionRecords(path, context));
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c of caseCompletions) {
          if (c.type === NORMAL_COMPLETION) {
            normalCompletions.push(c);
          }
          if (c.type === BREAK_COMPLETION) {
            breakCompletions.push(c);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records = records.concat(breakCompletions);
      }
      records = records.concat(lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c) => {
        if (c.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c.path.replaceWith(t2.unaryExpression("void", t2.numericLiteral(0)));
          } else {
            c.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      let completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions = completions.concat(lastNormalCompletions);
              if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                completions = completions.concat(statementCompletions);
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              completions = completions.concat(statementCompletions);
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions = completions.concat(statementCompletions);
          } else {
            completions = completions.concat(statementCompletions.filter((c) => c.type === BREAK_COMPLETION));
            lastNormalCompletions = statementCompletions.filter((c) => c.type === NORMAL_COMPLETION);
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            completions = completions.concat(pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      let records = [];
      if (path.isIfStatement()) {
        records = addCompletionRecords(path.get("consequent"), records, context);
        records = addCompletionRecords(path.get("alternate"), records, context);
      } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        records = addCompletionRecords(path.get("body"), records, context);
      } else if (path.isProgram() || path.isBlockStatement()) {
        records = records.concat(getStatementListCompletion(path.get("body"), context));
      } else if (path.isFunction()) {
        return _getCompletionRecords(path.get("body"), context);
      } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get("block"), records, context);
        records = addCompletionRecords(path.get("handler"), records, context);
      } else if (path.isCatchClause()) {
        records = addCompletionRecords(path.get("body"), records, context);
      } else if (path.isSwitchStatement()) {
        records = completionRecordForSwitch(path.get("cases"), records, context);
      } else if (path.isSwitchCase()) {
        records = records.concat(getStatementListCompletion(path.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        }));
      } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
      } else {
        records.push(NormalCompletion(path));
      }
      return records;
    }
    function getCompletionRecords() {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map((r) => r.path);
    }
    function getSibling(key) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key, context = true) {
      if (context === true)
        context = this.context;
      const parts = key.split(".");
      if (parts.length === 1) {
        return this._getKey(key, context);
      } else {
        return this._getPattern(parts, context);
      }
    }
    function _getKey(key, context) {
      const node = this.node;
      const container = node[key];
      if (Array.isArray(container)) {
        return container.map((_, i) => {
          return _index.default.get({
            listKey: key,
            parentPath: this,
            parent: node,
            container,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path = this;
      for (const part of parts) {
        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }
      return path;
    }
    function getBindingIdentifiers(duplicates) {
      return t2.getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return t2.getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path = this;
      let search = [].concat(path);
      const ids = Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id)
          continue;
        if (!id.node)
          continue;
        const keys = t2.getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          const declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const child = id.get(key);
            if (Array.isArray(child) || child.node) {
              search = search.concat(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    exports2.addComment = addComment;
    exports2.addComments = addComments;
    var t2 = require_lib7();
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string")
        return;
      const node = this.node;
      if (!node)
        return;
      const trailing = node.trailingComments;
      const leading = node.leadingComments;
      if (!trailing && !leading)
        return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev && !hasNext) {
        prev.addComments("trailing", trailing);
      } else if (hasNext && !hasPrev) {
        next.addComments("leading", leading);
      }
    }
    function addComment(type, content, line) {
      t2.addComment(this.node, type, content, line);
    }
    function addComments(type, comments) {
      t2.addComments(this.node, type, comments);
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/index.js
var require_path2 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/path/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.SHOULD_SKIP = exports2.SHOULD_STOP = exports2.REMOVED = void 0;
    var virtualTypes = require_virtual_types();
    var _debug = require_src();
    var _index = require_lib16();
    var _scope = require_scope();
    var t2 = require_lib7();
    var _cache = require_cache();
    var _generator = require_lib8();
    var NodePath_ancestry = require_ancestry();
    var NodePath_inference = require_inference();
    var NodePath_replacement = require_replacement();
    var NodePath_evaluation = require_evaluation();
    var NodePath_conversion = require_conversion();
    var NodePath_introspection = require_introspection();
    var NodePath_context = require_context2();
    var NodePath_removal = require_removal();
    var NodePath_modification = require_modification();
    var NodePath_family = require_family();
    var NodePath_comments = require_comments();
    var debug2 = _debug("babel");
    var REMOVED = 1 << 0;
    exports2.REMOVED = REMOVED;
    var SHOULD_STOP = 1 << 1;
    exports2.SHOULD_STOP = SHOULD_STOP;
    var SHOULD_SKIP = 1 << 2;
    exports2.SHOULD_SKIP = SHOULD_SKIP;
    var NodePath = class {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      static get({
        hub,
        parentPath,
        parent,
        container,
        listKey,
        key
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container[key];
        let paths = _cache.path.get(parent);
        if (!paths) {
          paths = new Map();
          _cache.path.set(parent, paths);
        }
        let path = paths.get(targetNode);
        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode)
            paths.set(targetNode, path);
        }
        path.setup(parentPath, container, listKey, key);
        return path;
      }
      getScope(scope) {
        return this.isScope() ? new _scope.default(this) : scope;
      }
      setData(key, val) {
        if (this.data == null) {
          this.data = Object.create(null);
        }
        return this.data[key] = val;
      }
      getData(key, def) {
        if (this.data == null) {
          this.data = Object.create(null);
        }
        let val = this.data[key];
        if (val === void 0 && def !== void 0)
          val = this.data[key] = def;
        return val;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key, node) {
        t2.validate(this.node, key, node);
        this.node[key] = node;
      }
      getPathLocation() {
        const parts = [];
        let path = this;
        do {
          let key = path.key;
          if (path.inList)
            key = `${path.listKey}[${key}]`;
          parts.unshift(key);
        } while (path = path.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug2.enabled)
          return;
        debug2(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
      get shouldSkip() {
        return !!(this._traverseFlags & SHOULD_SKIP);
      }
      set shouldSkip(v) {
        if (v) {
          this._traverseFlags |= SHOULD_SKIP;
        } else {
          this._traverseFlags &= ~SHOULD_SKIP;
        }
      }
      get shouldStop() {
        return !!(this._traverseFlags & SHOULD_STOP);
      }
      set shouldStop(v) {
        if (v) {
          this._traverseFlags |= SHOULD_STOP;
        } else {
          this._traverseFlags &= ~SHOULD_STOP;
        }
      }
      get removed() {
        return !!(this._traverseFlags & REMOVED);
      }
      set removed(v) {
        if (v) {
          this._traverseFlags |= REMOVED;
        } else {
          this._traverseFlags &= ~REMOVED;
        }
      }
    };
    Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
    for (const type of t2.TYPES) {
      const typeKey = `is${type}`;
      const fn = t2[typeKey];
      NodePath.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_")
        continue;
      if (t2.TYPES.indexOf(type) < 0)
        t2.TYPES.push(type);
      const virtualType = virtualTypes[type];
      NodePath.prototype[`is${type}`] = function(opts) {
        return virtualType.checkPath(this, opts);
      };
    }
    var _default = NodePath;
    exports2.default = _default;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/context.js
var require_context3 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _path = require_path2();
    var t2 = require_lib7();
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit)
          return true;
        if (opts[node.type])
          return true;
        const keys = t2.VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length))
          return false;
        for (const key of keys) {
          if (node[key])
            return true;
        }
        return false;
      }
      create(node, obj2, key, listKey) {
        return _path.default.get({
          parentPath: this.parentPath,
          parent: node,
          container: obj2,
          key,
          listKey
        });
      }
      maybeQueue(path, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }
      visitMultiple(container, parent, listKey) {
        if (container.length === 0)
          return false;
        const queue = [];
        for (let key = 0; key < container.length; key++) {
          const node = container[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }
      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = new WeakSet();
        let stop = false;
        for (const path of queue) {
          path.resync();
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            path.pushContext(this);
          }
          if (path.key === null)
            continue;
          const {
            node
          } = path;
          if (visited.has(node))
            continue;
          if (node)
            visited.add(node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop)
              break;
          }
        }
        for (const path of queue) {
          path.popContext();
        }
        this.queue = null;
        return stop;
      }
      visit(node, key) {
        const nodes = node[key];
        if (!nodes)
          return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }
    };
    exports2.default = TraversalContext;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/visitors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.explode = explode;
    exports2.verify = verify;
    exports2.merge = merge;
    var virtualTypes = require_virtual_types();
    var t2 = require_lib7();
    function explode(visitor) {
      if (visitor._exploded)
        return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        const parts = nodeType.split("|");
        if (parts.length === 1)
          continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        const wrapper = virtualTypes[nodeType];
        if (!wrapper)
          continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(wrapper, fns[type]);
        }
        delete visitor[nodeType];
        if (wrapper.types) {
          for (const type of wrapper.types) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        const fns = visitor[nodeType];
        let aliases = t2.FLIPPED_ALIAS_KEYS[nodeType];
        const deprecatedKey = t2.DEPRECATED_KEYS[nodeType];
        if (deprecatedKey) {
          console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);
          aliases = [deprecatedKey];
        }
        if (!aliases)
          continue;
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType))
          continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify(visitor) {
      if (visitor._verified)
        return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType))
          continue;
        if (t2.TYPES.indexOf(nodeType) < 0) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
      }
    }
    function merge(visitors, states = [], wrapper) {
      const rootVisitor = {};
      for (let i = 0; i < visitors.length; i++) {
        const visitor = visitors[i];
        const state = states[i];
        explode(visitor);
        for (const type of Object.keys(visitor)) {
          let visitorType = visitor[type];
          if (state || wrapper) {
            visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
          }
          const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
          mergePair(nodeVisitor, visitorType);
        }
      }
      return rootVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const key of Object.keys(oldVisitor)) {
        let fns = oldVisitor[key];
        if (!Array.isArray(fns))
          continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path) {
              return fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state.key, key, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[key] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj2) {
      for (const key of Object.keys(obj2)) {
        if (shouldIgnoreKey(key))
          continue;
        const fns = obj2[key];
        if (typeof fns === "function") {
          obj2[key] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj2) {
      if (obj2.enter && !Array.isArray(obj2.enter))
        obj2.enter = [obj2.enter];
      if (obj2.exit && !Array.isArray(obj2.exit))
        obj2.exit = [obj2.exit];
    }
    function wrapCheck(wrapper, fn) {
      const newFn = function(path) {
        if (wrapper.checkPath(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_")
        return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip")
        return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
        return true;
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const key of Object.keys(src)) {
        dest[key] = [].concat(dest[key] || [], src[key]);
      }
    }
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports2.default = Hub;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/index.js
var require_lib16 = __commonJS({
  "pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/.yarn/cache/@babel-traverse-npm-7.15.0-c9bc8b4682-e13056690a.zip/node_modules/@babel/traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: function() {
        return _path.default;
      }
    });
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return _scope.default;
      }
    });
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    exports2.visitors = exports2.default = void 0;
    var _context = require_context3();
    var visitors = require_visitors();
    exports2.visitors = visitors;
    var t2 = require_lib7();
    var cache = require_cache();
    var _path = require_path2();
    var _scope = require_scope();
    var _hub = require_hub();
    function traverse2(parent, opts = {}, scope, state, parentPath) {
      if (!parent)
        return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!t2.VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      traverse2.node(parent, opts, scope, state, parentPath);
    }
    var _default = traverse2;
    exports2.default = _default;
    traverse2.visitors = visitors;
    traverse2.verify = visitors.verify;
    traverse2.explode = visitors.explode;
    traverse2.cheap = function(node, enter) {
      return t2.traverseFast(node, enter);
    };
    traverse2.node = function(node, opts, scope, state, parentPath, skipKeys) {
      const keys = t2.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      const context = new _context.default(scope, opts, state, parentPath);
      for (const key of keys) {
        if (skipKeys && skipKeys[key])
          continue;
        if (context.visit(node, key))
          return;
      }
    };
    traverse2.clearNode = function(node, opts) {
      t2.removeProperties(node, opts);
      cache.path.delete(node);
    };
    traverse2.removeProperties = function(tree, opts) {
      t2.traverseFast(tree, traverse2.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }
    traverse2.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type))
        return false;
      if (tree.type === type)
        return true;
      const state = {
        has: false,
        type
      };
      traverse2(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse2.cache = cache;
  }
});

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/src/cli.ts
var import_fast_glob = __toModule(require_out4());
var import_promises = __toModule(require("fs/promises"));

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/src/index.ts
var import_debug = __toModule(require_src());
var import_compiler_sfc = __toModule(require_compiler_sfc_cjs());
var import_generator = __toModule(require_lib8());
var t = __toModule(require_lib7());
var import_traverse = __toModule(require_lib16());
var import_template = __toModule(require_lib14());
var debug = (0, import_debug.default)("debug");
function printBlock(block) {
  const attrsString = Object.keys(block.attrs).map((k) => {
    const value = block.attrs[k];
    if (typeof value === "boolean")
      return k;
    return `${k}="${value}"`;
  }).join(" ");
  const tagString = [block.type];
  if (attrsString)
    tagString.push(attrsString);
  const normalizedBlock = block.content.replace(/^\n(.*)\n$/s, "$1");
  return [`<${tagString.join(" ")}>`, normalizedBlock, `</${block.type}>`].join("\n");
}
function transformCode(code) {
  try {
    const parsedCode = (0, import_compiler_sfc.parse)(code);
    if (parsedCode.descriptor.scriptSetup) {
      debug("Already built with script setup, aborting transformation");
      return code;
    }
    const codeScript = parsedCode.descriptor.script;
    const ast = (0, import_compiler_sfc.babelParse)(codeScript.content, {
      sourceType: "module"
    });
    let componentDeclarationNode = void 0;
    let setupFunctionNode = void 0;
    let propsDeclarationNode = void 0;
    let emitsDeclarationNode = void 0;
    (0, import_traverse.default)(ast, {
      ExportDefaultDeclaration(path) {
        const { node } = path;
        if (node.declaration.type === "ObjectExpression") {
          debug("Found default export: component with object declaration");
          const declarationNode = node.declaration;
          componentDeclarationNode = declarationNode;
        } else if (node.declaration.type === "CallExpression" && node.declaration.callee.name === "defineComponent") {
          debug("Found default export: component with defineComponent declaration");
          const declarationNode = node.declaration.arguments[0];
          componentDeclarationNode = declarationNode;
        }
        if (componentDeclarationNode) {
          path.stop();
          path.traverse({
            enter(path2) {
              const { node: node2, parent } = path2;
              if ("key" in node2 && node2.key.name === "setup" && parent === componentDeclarationNode) {
                debug("Found setup function");
                setupFunctionNode = node2;
                path2.remove();
              }
              if ("key" in node2 && node2.key.name === "props" && parent === componentDeclarationNode) {
                debug("Found props declaration");
                propsDeclarationNode = node2.value;
                path2.remove();
              }
              if ("key" in node2 && node2.key.name === "emits" && parent === componentDeclarationNode) {
                debug("Found emits declaration");
                emitsDeclarationNode = node2.value;
                path2.remove();
              }
              if ("key" in node2 && node2.key.name === "components" && parent === componentDeclarationNode) {
                debug("Found components declaration");
                path2.remove();
              }
            }
          });
        }
      }
    });
    if (!componentDeclarationNode) {
      throw new Error("No valid component declaration found");
    }
    if (!setupFunctionNode) {
      debug("No setup function found, aborting transformation");
      return code;
    }
    (0, import_compiler_sfc.walk)(setupFunctionNode, {
      enter(node) {
        if (node.type === "ReturnStatement") {
          this.remove();
        }
      }
    });
    const scriptSetupCodeAst = t.program(setupFunctionNode.body.body);
    if (propsDeclarationNode) {
      const propsTemplate = (0, import_template.default)("const emit = defineEmits(%%emits%%)");
      const ast2 = propsTemplate({
        emits: emitsDeclarationNode
      });
      scriptSetupCodeAst.body.unshift(ast2);
    }
    if (propsDeclarationNode) {
      const propsTemplate = (0, import_template.default)("const props = defineProps(%%props%%)");
      const ast2 = propsTemplate({
        props: propsDeclarationNode
      });
      scriptSetupCodeAst.body.unshift(ast2);
    }
    const regularScriptBlock = componentDeclarationNode.properties.length && {
      type: "script",
      attrs: codeScript.attrs,
      content: (0, import_generator.default)(ast).code
    };
    const setupScriptBlock = {
      type: "script",
      attrs: {
        ...codeScript.attrs,
        setup: true
      },
      content: (0, import_generator.default)(scriptSetupCodeAst).code
    };
    const blocks = [
      ...regularScriptBlock ? [printBlock(regularScriptBlock)] : [],
      printBlock(setupScriptBlock),
      ...parsedCode.descriptor.template ? [printBlock(parsedCode.descriptor.template)] : [],
      ...parsedCode.descriptor.styles.map(printBlock),
      ...parsedCode.descriptor.customBlocks.map(printBlock)
    ];
    return blocks.join("\n");
  } catch (e) {
    debug("Failed to parse component");
    throw e;
  }
  return code;
}

// pnp:/Users/alexandregeissmann/Sites/OSS/vue-script-setup-migrate/src/cli.ts
(async () => {
  const entries = await (0, import_fast_glob.default)("**/*.vue", { dot: true });
  for (const entry of entries) {
    (async () => {
      const input = await import_promises.default.readFile(entry, { encoding: "utf8" });
      const res = transformCode(input);
      import_promises.default.writeFile(entry, res, { encoding: "utf8" });
    })();
  }
})();
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
